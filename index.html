<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deep Research Skill Factory - Aviram OS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0b0d;
      --bg-medium: #14161a;
      --bg-light: #1e2127;
      --glass-bg: rgba(30, 33, 39, 0.4);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --text-primary: #e8eaed;
      --text-secondary: #9aa0a6;
      --accent-primary: #8ab4f8;
      --accent-secondary: #81c995;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #0a0b0d 0%, #14161a 50%, #1e2127 100%);
      background-attachment: fixed;
      min-height: 100vh;
      padding: 24px;
      position: relative;
      overflow-x: hidden;
      color: var(--text-primary);
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 30%, rgba(138, 180, 248, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(129, 201, 149, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.01) 0%, transparent 80%);
      pointer-events: none;
      animation: ambientShift 30s ease-in-out infinite;
      z-index: 0;
    }

    @keyframes ambientShift {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.1); }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    .aviram-surface {
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      background: var(--glass-bg);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      box-shadow:
        0 8px 32px var(--shadow-color),
        inset 0 1px 0 var(--glass-highlight);
      padding: 32px;
      margin-bottom: 24px;
      contain: layout style paint;
      will-change: backdrop-filter, transform;
      transform: translate3d(0, 0, 0);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .aviram-surface:hover {
      backdrop-filter: blur(24px) saturate(140%);
      -webkit-backdrop-filter: blur(24px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.12);
      transform: translate3d(0, -2px, 0);
      box-shadow:
        0 12px 48px var(--shadow-color),
        inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .aviram-surface::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg,
        transparent 0%,
        var(--accent-primary) 50%,
        transparent 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .aviram-surface:hover::before {
      opacity: 0.5;
    }

    .header-surface {
      backdrop-filter: blur(30px) saturate(140%);
      -webkit-backdrop-filter: blur(30px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-radius: 24px;
      padding: 48px 40px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
      font-size: 48px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      letter-spacing: -1px;
      line-height: 1.1;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .stepper {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 32px 0;
      padding: 12px 0;
      position: relative;
    }

    .step {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      position: relative;
      z-index: 2;
    }

    .step-circle {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(30, 33, 39, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--text-secondary);
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .step-circle::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 50%;
      background: conic-gradient(
        var(--accent-primary) 0deg,
        transparent 90deg
      );
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .step-circle.active {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      transform: scale(1.15);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .step-circle.active::before {
      opacity: 0.3;
      animation: rotate 3s linear infinite;
    }

    @keyframes rotate {
      to { transform: rotate(360deg); }
    }

    .step-circle.complete {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow: 0 0 24px rgba(129, 201, 149, 0.3);
    }

    .step-label {
      margin-top: 14px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .step-label.active {
      color: var(--accent-primary);
    }

    .step-line {
      position: absolute;
      top: 32px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: rgba(255, 255, 255, 0.05);
      z-index: 1;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .step-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 12px currentColor;
    }

    .step-line.complete::after {
      width: 100%;
    }

    .step:last-child .step-line {
      display: none;
    }

    textarea {
      width: 100%;
      height: 240px;
      padding: 20px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(20, 22, 26, 0.5);
      border: 1.5px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
      resize: vertical;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    textarea:focus {
      outline: none;
      background: rgba(20, 22, 26, 0.7);
      border-color: var(--accent-primary);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.3),
        0 0 24px rgba(138, 180, 248, 0.2);
    }

    .btn {
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(138, 180, 248, 0.15);
      border: 1.5px solid var(--accent-primary);
      color: var(--accent-primary);
      padding: 18px 36px;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 20px;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(138, 180, 248, 0.2);
      text-shadow: 0 0 20px rgba(138, 180, 248, 0.5);
      transform: translate3d(0, 0, 0);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg,
        rgba(138, 180, 248, 0.2),
        rgba(129, 201, 149, 0.2));
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .btn:hover:not(:disabled)::before {
      opacity: 1;
    }

    .btn:hover:not(:disabled) {
      background: rgba(138, 180, 248, 0.25);
      border-color: rgba(138, 180, 248, 0.8);
      transform: translate3d(0, -3px, 0) scale(1.02);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .btn:active:not(:disabled) {
      transform: translate3d(0, 0, 0) scale(0.98);
    }

    .btn:disabled {
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      cursor: not-allowed;
      opacity: 0.5;
      text-shadow: none;
    }

    .btn.success {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 20px rgba(129, 201, 149, 0.2),
        0 0 30px rgba(129, 201, 149, 0.15);
    }

    .btn.success:hover {
      background: rgba(129, 201, 149, 0.25);
      box-shadow:
        0 8px 32px rgba(129, 201, 149, 0.3),
        0 0 40px rgba(129, 201, 149, 0.2);
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    .button-group .btn {
      flex: 1;
      min-width: 200px;
      margin-top: 0;
    }

    .btn-secondary {
      background: rgba(100, 100, 120, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
      color: var(--text-primary);
      box-shadow: 0 4px 20px rgba(100, 100, 120, 0.2);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(100, 100, 120, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow:
        0 8px 32px rgba(100, 100, 120, 0.3),
        0 0 40px rgba(100, 100, 120, 0.2);
    }

    @media (max-width: 768px) {
      body {
        padding: 16px;
      }

      .button-group {
        flex-direction: column;
      }

      .button-group .btn {
        width: 100%;
        min-width: 0;
      }

      /* Header Responsiveness */
      .header-surface {
        padding: 32px 24px;
      }

      h1 {
        font-size: 28px;
        margin-bottom: 16px;
        letter-spacing: -0.5px;
      }

      .subtitle {
        font-size: 13px;
        line-height: 1.5;
      }

      /* Stepper Responsiveness */
      .aviram-surface {
        padding: 20px 16px;
      }

      .stepper {
        overflow-x: auto;
        overflow-y: hidden;
        justify-content: flex-start;
        margin: 16px -16px;
        padding: 12px 16px;
        gap: 8px;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      .stepper::-webkit-scrollbar {
        display: none; /* Chrome, Safari, Edge */
      }

      .step {
        flex: 0 0 auto;
        min-width: 64px;
        scroll-snap-align: center;
      }

      .step-circle {
        width: 48px;
        height: 48px;
        font-size: 16px;
      }

      .step-circle.active {
        transform: scale(1.1);
      }

      .step-label {
        font-size: 10px;
        margin-top: 10px;
        white-space: nowrap;
        max-width: 64px;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .step-line {
        top: 24px;
      }

      /* Status Badge Responsiveness */
      .status-badge {
        display: block;
        padding: 10px 16px;
        font-size: 14px;
        word-wrap: break-word;
        word-break: break-word;
        margin: 12px 0;
      }

      /* Text Areas and Inputs */
      textarea {
        height: 200px;
        font-size: 13px;
      }

      /* Progress and Error Messages */
      #errorMessage,
      #progressMessage {
        font-size: 13px !important;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        line-height: 1.6;
      }

      /* Long URLs and links */
      a {
        word-break: break-all;
        overflow-wrap: break-word;
      }

      /* Utility Analysis Responsive */
      #utilityResults > div {
        flex-direction: column !important;
        gap: 16px !important;
      }

      #utilityScoreDisplay {
        font-size: 36px !important;
      }

      /* Progress text alignment */
      .progress-text {
        font-size: 12px;
      }

      /* Card headers on mobile */
      h2 {
        font-size: 20px;
      }

      h3 {
        font-size: 16px;
        margin-bottom: 12px;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 12px;
      }

      .header-surface {
        padding: 24px 16px;
      }

      h1 {
        font-size: 24px;
      }

      .subtitle {
        font-size: 12px;
      }

      h2 {
        font-size: 18px;
      }

      .step-circle {
        width: 40px;
        height: 40px;
        font-size: 14px;
      }

      .step-label {
        font-size: 9px;
        margin-top: 8px;
        max-width: 56px;
      }

      .step-line {
        top: 20px;
      }

      /* Stack card headers on very small screens */
      #progressCard > div:first-child,
      #utilityCard > div:first-child {
        flex-direction: column !important;
        align-items: flex-start !important;
        gap: 12px;
      }

      .reset-link {
        float: none;
        display: inline-block;
      }
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(20, 22, 26, 0.6);
      border-radius: 8px;
      overflow: hidden;
      margin: 24px 0;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.05);
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg,
        var(--accent-primary),
        var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 20px currentColor;
      border-radius: 8px;
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .log-container {
      max-height: 520px;
      overflow-y: auto;
      padding: 20px;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(10, 11, 13, 0.6);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 2px 12px rgba(0, 0, 0, 0.5);
    }

    .log-container::-webkit-scrollbar {
      width: 6px;
    }

    .log-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
    }

    .log-container::-webkit-scrollbar-thumb {
      background: rgba(138, 180, 248, 0.3);
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    .log-container::-webkit-scrollbar-thumb:hover {
      background: rgba(138, 180, 248, 0.5);
    }

    .log-entry {
      padding: 14px 18px;
      margin-bottom: 10px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.7;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      transform: translate3d(0, 0, 0);
      animation: logEntryAppear 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes logEntryAppear {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .log-entry.info {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: #aec7fa;
    }

    .log-entry.success {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.2);
      color: #a8dab5;
    }

    .log-entry.warning {
      background: rgba(251, 188, 5, 0.08);
      border-color: rgba(251, 188, 5, 0.2);
      color: #fdd663;
    }

    .log-entry.error {
      background: rgba(242, 139, 130, 0.08);
      border-color: rgba(242, 139, 130, 0.2);
      color: #f8b4ae;
    }

    .log-time {
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      opacity: 0.6;
      margin-right: 12px;
      letter-spacing: 0.5px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    @media (max-width: 1024px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .aviram-surface {
        backdrop-filter: blur(12px) saturate(110%);
        -webkit-backdrop-filter: blur(12px) saturate(110%);
      }

      textarea {
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }
    }

    @media (prefers-contrast: high) {
      .aviram-surface {
        background: rgba(30, 33, 39, 0.95);
        backdrop-filter: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      textarea {
        background: rgba(10, 11, 13, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    .examples {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .example-btn {
      display: block;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 12px 18px;
      text-align: left;
      font-size: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 10px;
      margin-bottom: 8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      width: 100%;
      border: 1px solid transparent;
    }

    .example-btn:hover {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: var(--accent-primary);
      padding-left: 24px;
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.1);
    }

    .status-badge {
      display: inline-block;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 600;
      margin: 16px 0;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.3px;
    }

    .status-badge.success {
      background: rgba(129, 201, 149, 0.12);
      border-color: rgba(129, 201, 149, 0.4);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 16px rgba(129, 201, 149, 0.2),
        0 0 24px rgba(129, 201, 149, 0.1);
    }

    .status-badge.error {
      background: rgba(242, 139, 130, 0.12);
      border-color: rgba(242, 139, 130, 0.4);
      color: #f8b4ae;
      box-shadow:
        0 4px 16px rgba(242, 139, 130, 0.2),
        0 0 24px rgba(242, 139, 130, 0.1);
    }

    /* Phase 0 Complete - Inline Countdown Button */
    .phase-complete {
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(129, 201, 149, 0.08);
      border: 2px solid rgba(129, 201, 149, 0.3);
      border-radius: 16px;
      padding: 24px;
      margin: 24px 0;
      animation: slideInFromTop 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow:
        0 8px 32px rgba(129, 201, 149, 0.15),
        0 0 40px rgba(129, 201, 149, 0.08);
    }

    .phase-complete h3 {
      margin: 0 0 20px 0;
      color: var(--accent-secondary);
      font-size: 22px;
      font-weight: 700;
      letter-spacing: -0.3px;
    }

    .phase-complete p {
      margin: 10px 0;
      color: var(--text-secondary);
      line-height: 1.7;
      font-size: 15px;
    }

    .phase-complete p strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    #continueBtn {
      width: 100%;
      background: linear-gradient(135deg, rgba(138, 180, 248, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
      color: var(--accent-primary);
      border: 2px solid var(--accent-primary);
      padding: 18px 24px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      margin: 20px 0 12px 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.3px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow:
        0 4px 20px rgba(138, 180, 248, 0.25),
        0 0 30px rgba(138, 180, 248, 0.15);
    }

    #continueBtn:hover {
      transform: translateY(-3px);
      background: linear-gradient(135deg, rgba(138, 180, 248, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
      border-color: rgba(138, 180, 248, 0.8);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.35),
        0 0 40px rgba(138, 180, 248, 0.25);
    }

    #continueBtn:active {
      transform: translateY(-1px);
    }

    .countdown-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 16px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #countdownProgress {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), rgba(118, 75, 162, 0.8));
      transition: width 1s linear;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.6);
    }

    .phase-complete a {
      color: var(--accent-primary);
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: color 0.2s ease;
      display: inline-block;
      margin-top: 8px;
    }

    .phase-complete a:hover {
      color: rgba(138, 180, 248, 0.8);
      text-decoration: underline;
    }

    @keyframes slideInFromTop {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .file-tree {
      margin-top: 24px;
      font-family: 'SF Mono', 'Courier New', monospace;
      font-size: 13px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(10, 11, 13, 0.4);
      padding: 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      line-height: 1.8;
    }

    .file-item {
      padding: 4px 0;
      padding-left: 20px;
      color: var(--text-secondary);
      transition: color 0.2s ease;
    }

    .file-item:hover {
      color: var(--accent-primary);
    }

    .file-item.folder {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .hidden {
      display: none;
    }

    /* Collapsible sections for utility analysis */
    .collapsible-section {
      margin: 16px 0;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.02);
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .collapsible-section:hover {
      border-color: rgba(138, 180, 248, 0.2);
      background: rgba(255, 255, 255, 0.04);
      box-shadow: 0 4px 20px rgba(138, 180, 248, 0.08);
    }

    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 18px;
      cursor: pointer;
      background: transparent;
      border: none;
      width: 100%;
      text-align: left;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
      position: relative;
      overflow: hidden;
    }

    .collapsible-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(138, 180, 248, 0.1), transparent);
      transition: left 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .collapsible-header:hover::before {
      left: 100%;
    }

    .collapsible-header:hover {
      background: rgba(138, 180, 248, 0.08);
      padding-left: 22px;
    }

    .collapsible-header:hover h3 {
      color: var(--accent-primary);
      transform: translateX(2px);
    }

    .collapsible-header:active {
      transform: scale(0.99);
    }

    .collapsible-header h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Enhanced Toggle Icon - CSS Chevron */
    .toggle-icon {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: rgba(138, 180, 248, 0.12);
      border: 1.5px solid rgba(138, 180, 248, 0.3);
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
    }

    .toggle-icon::before,
    .toggle-icon::after {
      content: '';
      position: absolute;
      width: 10px;
      height: 2px;
      background: var(--accent-primary);
      border-radius: 2px;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 0 8px rgba(138, 180, 248, 0.4);
    }

    .toggle-icon::before {
      transform: rotate(45deg) translateY(-2px);
    }

    .toggle-icon::after {
      transform: rotate(-45deg) translateY(-2px);
    }

    .collapsible-section.collapsed .toggle-icon {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      transform: rotate(0deg);
    }

    .collapsible-section.collapsed .toggle-icon::before {
      transform: rotate(-45deg) translateY(2px);
    }

    .collapsible-section.collapsed .toggle-icon::after {
      transform: rotate(45deg) translateY(2px);
    }

    .collapsible-header:hover .toggle-icon {
      background: rgba(138, 180, 248, 0.2);
      border-color: var(--accent-primary);
      transform: scale(1.1);
      box-shadow: 0 0 16px rgba(138, 180, 248, 0.3);
    }

    .collapsible-header:hover .toggle-icon::before,
    .collapsible-header:hover .toggle-icon::after {
      background: var(--accent-primary);
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.6);
    }

    /* Pulsing animation for collapsed state */
    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 8px rgba(138, 180, 248, 0.2);
      }
      50% {
        box-shadow: 0 0 16px rgba(138, 180, 248, 0.4);
      }
    }

    .collapsible-section.collapsed .toggle-icon {
      animation: pulse-glow 2s ease-in-out infinite;
    }

    .collapsible-header:hover .toggle-icon {
      animation: none;
    }

    .collapsible-content {
      max-height: 800px;
      overflow: hidden;
      transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                  padding 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                  opacity 0.3s ease;
      padding: 0 18px 18px 18px;
      opacity: 1;
    }

    .collapsible-section.collapsed .collapsible-content {
      max-height: 0;
      padding: 0 18px;
      opacity: 0;
    }

    .utility-summary {
      font-size: 15px;
      color: var(--text-primary);
      margin: 16px 0;
      padding: 16px;
      background: rgba(138, 180, 248, 0.08);
      border-left: 3px solid var(--accent-primary);
      border-radius: 8px;
      line-height: 1.6;
    }

    /* Circular Progress Ring for Utility Score */
    @keyframes fillProgress {
      from {
        stroke-dashoffset: 314;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .utility-score-container {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      animation: fadeIn 0.5s ease-out;
    }

    .svg-container {
      position: relative;
      width: 120px;
      height: 120px;
    }

    .progress-svg {
      transform: rotate(-90deg);
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
    }

    .circle-background {
      fill: none;
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 10;
    }

    .circle-progress {
      fill: none;
      stroke-width: 10;
      stroke-linecap: round;
      stroke-dasharray: 314;
      animation: fillProgress 1.5s ease-out;
      transition: stroke-dashoffset 0.6s ease-out, stroke 0.3s ease;
    }

    .score-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .score-number {
      font-size: 28px;
      font-weight: 700;
      line-height: 1;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .score-max {
      font-size: 18px;
      opacity: 0.7;
    }

    .category-label {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 6px 12px;
      border-radius: 16px;
    }

    .high-utility .circle-progress { stroke: #81c995; }
    .high-utility .score-number { color: #81c995; }
    .high-utility .category-label {
      color: #81c995;
      background: rgba(129, 201, 149, 0.2);
      border: 1px solid rgba(129, 201, 149, 0.4);
    }

    .medium-utility .circle-progress { stroke: #fdd663; }
    .medium-utility .score-number { color: #fdd663; }
    .medium-utility .category-label {
      color: #fdd663;
      background: rgba(253, 214, 99, 0.2);
      border: 1px solid rgba(253, 214, 99, 0.4);
    }

    .low-utility .circle-progress { stroke: #f8b4ae; }
    .low-utility .score-number { color: #f8b4ae; }
    .low-utility .category-label {
      color: #f8b4ae;
      background: rgba(248, 180, 174, 0.2);
      border: 1px solid rgba(248, 180, 174, 0.4);
    }

    .loading-spinner {
      border: 3px solid rgba(138, 180, 248, 0.2);
      border-top: 3px solid var(--accent-primary);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      display: inline-block;
      margin-left: 12px;
      vertical-align: middle;
      box-shadow: 0 0 20px rgba(138, 180, 248, 0.3);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .reset-link {
      color: var(--text-secondary);
      cursor: pointer;
      text-decoration: none;
      font-size: 13px;
      float: right;
      font-weight: 600;
      padding: 10px 18px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(138, 180, 248, 0.08);
      border: 1px solid rgba(138, 180, 248, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .reset-link:hover {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.2);
    }

    h2 {
      color: var(--text-primary);
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 20px;
      letter-spacing: -0.3px;
    }

    h3 {
      color: var(--text-primary);
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      opacity: 0.9;
    }

    p {
      color: var(--text-secondary);
      line-height: 1.7;
    }

    .system-status {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-secondary);
      box-shadow:
        0 0 20px var(--accent-secondary),
        0 0 40px rgba(129, 201, 149, 0.3);
      animation: pulse 3s ease-in-out infinite;
      z-index: 1000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    .api-config {
      margin-bottom: 24px;
      padding: 20px;
      background: rgba(251, 188, 5, 0.08);
      border: 1px solid rgba(251, 188, 5, 0.2);
      border-radius: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config.collapsed {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.3);
      padding: 16px 20px;
    }

    .api-config-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .api-config-status {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    .api-config-status .check-icon {
      color: var(--accent-secondary);
      font-size: 18px;
      font-weight: bold;
    }

    .api-config-status .status-text {
      color: var(--accent-secondary);
      font-weight: 600;
      font-size: 14px;
    }

    .api-config-actions {
      display: flex;
      gap: 8px;
    }

    .api-config-btn {
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 8px;
      border: 1px solid;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .api-config-btn.edit {
      color: var(--accent-primary);
      border-color: rgba(138, 180, 248, 0.3);
    }

    .api-config-btn.edit:hover {
      background: rgba(138, 180, 248, 0.1);
      border-color: var(--accent-primary);
    }

    .api-config-btn.clear {
      color: #f8b4ae;
      border-color: rgba(242, 139, 130, 0.3);
    }

    .api-config-btn.clear:hover {
      background: rgba(242, 139, 130, 0.1);
      border-color: rgba(242, 139, 130, 0.5);
    }

    .api-config-form {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config-form.hidden {
      display: none;
    }

    .api-config input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(10, 11, 13, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: 'SF Mono', monospace;
      font-size: 13px;
      margin-top: 8px;
    }

    .api-config input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.2);
    }

    /* Ideation Mode Toggle */
    .mode-selector {
      display: flex;
      gap: 12px;
      align-items: center;
      margin: 20px 0 16px 0;
      padding: 12px 16px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      background: rgba(30, 33, 39, 0.4);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .mode-selector label {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .mode-toggle {
      display: flex;
      gap: 4px;
      background: rgba(10, 11, 13, 0.6);
      padding: 4px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .mode-option {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
    }

    .mode-option:hover {
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.05);
    }

    .mode-option.active {
      background: rgba(138, 180, 248, 0.15);
      color: var(--accent-primary);
      box-shadow: 0 2px 8px rgba(138, 180, 248, 0.2);
    }

    .research-mode-selector {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    .research-mode-selector select {
      padding: 6px 12px;
      background: rgba(10, 11, 13, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .research-mode-selector select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 8px rgba(138, 180, 248, 0.2);
    }

    .research-mode-selector select:hover {
      border-color: rgba(138, 180, 248, 0.3);
    }

    /* Ideation Results */
    .ideation-variants {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 20px;
      margin-top: 24px;
    }

    .variant-card {
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(30, 33, 39, 0.5);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 24px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .variant-card:hover {
      transform: translateY(-4px);
      border-color: rgba(138, 180, 248, 0.3);
      box-shadow: 0 8px 32px rgba(138, 180, 248, 0.15);
    }

    .variant-card h3 {
      color: var(--accent-primary);
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      letter-spacing: -0.3px;
    }

    .variant-card .variant-purpose {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .variant-card .variant-section {
      margin-bottom: 16px;
    }

    .variant-card .variant-section h4 {
      color: var(--text-primary);
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
    }

    .variant-card .variant-example {
      background: rgba(10, 11, 13, 0.5);
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      line-height: 1.5;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .variant-card .select-variant-btn {
      width: 100%;
      padding: 10px 16px;
      background: rgba(138, 180, 248, 0.1);
      border: 1px solid rgba(138, 180, 248, 0.3);
      border-radius: 8px;
      color: var(--accent-primary);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 12px;
    }

    .variant-card .select-variant-btn:hover {
      background: rgba(138, 180, 248, 0.2);
      border-color: var(--accent-primary);
      transform: translateY(-2px);
    }
  </style>
  <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
  <div class="container">
    <div class="aviram-surface header-surface">
      <h1>üè≠ Deep Research Skill Factory</h1>
      <p class="subtitle">SKILL FACTORY ‚Ä¢ TURN WORKFLOWS INTO CLAUDE SUPERPOWERS</p>
    </div>

    <div class="aviram-surface">
      <div class="stepper" id="stepper"></div>
    </div>

    <div class="grid">
      <div>
        <div class="aviram-surface" id="inputCard">
          <div class="api-config" id="apiConfig">
            <!-- Collapsed State (shown when API key is saved) -->
            <div class="api-config-header hidden" id="apiConfigCollapsed">
              <div class="api-config-status">
                <span class="check-icon">‚úì</span>
                <span class="status-text">API Key Configured</span>
              </div>
              <div class="api-config-actions">
                <button class="api-config-btn edit" onclick="expandApiConfig()">Edit</button>
                <button class="api-config-btn clear" onclick="clearApiKey()">Clear</button>
              </div>
            </div>

            <!-- Expanded State (shown on first visit or when editing) -->
            <div class="api-config-form" id="apiConfigForm">
              <h3>‚öôÔ∏è API Configuration</h3>
              <p style="font-size: 13px; margin-bottom: 8px;">Enter your Anthropic API key to enable skill generation:</p>
              <input
                type="password"
                id="apiKey"
                placeholder="sk-ant-..."
                autocomplete="off"
                onchange="saveApiKey()"
                onkeypress="if(event.key === 'Enter') saveApiKey()"
              />
              <p style="font-size: 11px; margin-top: 8px; opacity: 0.7;">Your key is stored locally in your browser only. Get one at console.anthropic.com</p>
            </div>
          </div>

          <h2>What do you want Claude to know how to do?</h2>
          <p style="color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
            Think of a workflow you repeat. A technical thing you explain constantly. A pattern you wish Claude just *knew*. Write it here. The system researches, architects, and packages it into a skill Claude can use forever.
          </p>
          <textarea
            id="skillInput"
            placeholder="Describe it once, and it becomes a reusable, automated skill."
          ></textarea>

          <!-- Ideation Mode Selector -->
          <div class="mode-selector">
            <label>MODE:</label>
            <div class="mode-toggle">
              <button class="mode-option active" data-mode="single" onclick="setGenerationMode('single')">
                Single Skill
              </button>
              <button class="mode-option" data-mode="ideation" onclick="setGenerationMode('ideation')">
                Ideate 3 Variants
              </button>
            </div>
            <div class="research-mode-selector" id="researchModeSelector" style="display: none;">
              <label style="font-size: 12px; color: var(--text-secondary);">Research:</label>
              <select id="researchModeSelect" onchange="updateResearchMode()">
                <option value="adaptive">Adaptive</option>
                <option value="full">Full</option>
                <option value="frameworks-only">Frameworks Only</option>
              </select>
            </div>
          </div>

          <button class="btn" id="generateBtn" onclick="startGeneration()">
            Generate This Skill ‚Üí
          </button>

          <div class="examples">
            <h3>Skills People Actually Use</h3>
            <button class="example-btn" onclick="setExample('Parse PDF tables and forms into structured JSON. Handle malformed PDFs, extract nested tables, preserve formatting context.')">‚Üí PDF parsing with error handling</button>
            <button class="example-btn" onclick="setExample('Build accessible React forms with real-time validation, error recovery, and keyboard navigation. Include ARIA labels and focus management.')">‚Üí Production-grade React forms</button>
            <button class="example-btn" onclick="setExample('Create REST API clients with token refresh, exponential backoff, request deduplication, and typed responses.')">‚Üí Industrial-strength API wrappers</button>
          </div>
        </div>

        <div class="aviram-surface hidden" id="utilityCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Utility Analysis</h2>
            <a class="reset-link" onclick="resetFactory()">‚Üê New</a>
          </div>

          <div id="utilityResults">
            <!-- Category Badge Section -->
            <div id="categoryBadgeSection" style="margin-bottom: 24px;">
              <!-- Category badge will be injected here -->
            </div>

            <!-- One-line Summary -->
            <div id="utilitySummary" class="utility-summary" style="display: none;">
              <!-- Will be populated by JavaScript -->
            </div>

            <div style="display: flex; align-items: flex-start; gap: 32px; margin-bottom: 20px;">
              <div style="flex: 0 0 auto;">
                <div id="utilityScoreRing" class="utility-score-container high-utility">
                  <div class="svg-container">
                    <svg class="progress-svg" width="120" height="120" viewBox="0 0 120 120">
                      <circle class="circle-background" cx="60" cy="60" r="50" />
                      <circle class="circle-progress" cx="60" cy="60" r="50" style="stroke-dashoffset: 157;" />
                    </svg>
                    <div class="score-text">
                      <div class="score-number">
                        <span class="score-value">-</span><span class="score-max">/10</span>
                      </div>
                    </div>
                  </div>
                  <div class="category-label">UTILITY</div>
                </div>
              </div>
              <div style="flex: 1;">
                <div class="collapsible-section collapsed" id="powerUpSection">
                  <button class="collapsible-header" onclick="toggleCollapsibleSection('powerUpSection')">
                    <h3>Power-Up Statement</h3>
                    <span class="toggle-icon"></span>
                  </button>
                  <div class="collapsible-content">
                    <p id="powerUpStatement" style="font-size: 15px; line-height: 1.6; color: var(--text-primary);"></p>
                  </div>
                </div>
              </div>
            </div>

            <div class="collapsible-section collapsed" id="reasoningSection" style="margin: 24px 0;">
              <button class="collapsible-header" onclick="toggleCollapsibleSection('reasoningSection')">
                <h3>Reasoning</h3>
                <span class="toggle-icon"></span>
              </button>
              <div class="collapsible-content">
                <p id="utilityReasoning" style="color: var(--text-secondary); line-height: 1.7;"></p>
              </div>
            </div>

            <!-- Category Explanation Section -->
            <div id="categoryExplanationSection" class="hidden" style="margin: 24px 0;">
              <!-- Category explanation will be injected here -->
            </div>

            <!-- Constraint Validation Report -->
            <div id="constraintValidationReport" class="hidden"></div>

            <div id="utilityProceedSection" class="hidden">
              <div class="status-badge success">
                ‚úì HIGH UTILITY - Ready for Research
              </div>
              <div class="collapsible-section collapsed" id="researchDirectionSection">
                <button class="collapsible-header" onclick="toggleCollapsibleSection('researchDirectionSection')">
                  <h3>Research Direction</h3>
                  <span class="toggle-icon"></span>
                </button>
                <div class="collapsible-content">
                  <p id="researchDirection" style="color: var(--text-secondary); line-height: 1.7;"></p>
                </div>
              </div>
              <button class="btn success" onclick="continueToResearch()">
                Start Research Phase ‚Üí
              </button>
            </div>

            <div id="utilityRedesignSection" class="hidden">
              <div class="status-badge" style="background: rgba(251, 188, 5, 0.12); border-color: rgba(251, 188, 5, 0.4); color: #fdd663;">
                ‚ö† MEDIUM UTILITY - Redesign Recommended
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                This skill has value but could be more focused. Choose a redesign suggestion or proceed anyway:
              </p>
              <div id="redesignOptions" style="margin: 20px 0;"></div>
              <div class="button-group">
                <button class="btn btn-secondary" onclick="proceedAnyway()">
                  Proceed Anyway
                </button>
                <button class="btn" onclick="resetFactory()">
                  Start Over
                </button>
              </div>
            </div>

            <div id="utilityRejectSection" class="hidden">
              <div class="status-badge error">
                ‚úó LOW UTILITY - Rejected
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                <strong>Rejection Reason:</strong> <span id="rejectionReason"></span>
              </p>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                Consider these high-utility alternatives instead:
              </p>
              <div id="rejectAlternatives" style="margin: 20px 0;"></div>
              <button class="btn" onclick="resetFactory()">
                Try New Skill Request
              </button>
            </div>
          </div>
        </div>

        <div class="aviram-surface hidden" id="progressCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Progress</h2>
            <a class="reset-link" onclick="resetFactory()">‚Üê New</a>
          </div>

          <div id="progressSection">
            <div class="progress-text">
              <span id="progressStage">Initializing...</span>
              <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressMessage" style="margin-top: 14px; font-size: 14px;"></p>
          </div>

          <div id="resultsSection" class="hidden">
            <div class="status-badge success">
              ‚úì Generation Complete
            </div>
            <p id="qualityScore" style="margin: 12px 0;"></p>

            <div class="button-group">
              <button class="btn success" id="downloadBtn" onclick="downloadSkill()">
                ‚¨áÔ∏è Download Skill Package
              </button>
              <button class="btn btn-secondary" id="copyPromptBtn" onclick="copyPromptToClipboard()">
                üìã Copy Prompt
              </button>
            </div>

            <div id="fileTree" class="file-tree"></div>
          </div>

          <!-- Ideation Results Section -->
          <div id="ideationResultsSection" class="hidden">
            <div class="status-badge success">
              ‚úì Ideation Complete - 3 Variants Generated
            </div>
            <p style="margin: 16px 0; color: var(--text-secondary); line-height: 1.6;">
              Choose a variant to continue with full skill generation, or refine your objective and try again.
            </p>
            <div id="ideationVariantsContainer" class="ideation-variants">
              <!-- Variant cards will be injected here -->
            </div>
          </div>

          <div id="errorSection" class="hidden">
            <div class="status-badge error">
              ‚úó Generation Failed
            </div>
            <p id="errorMessage" style="margin: 12px 0;"></p>
            <button class="btn" onclick="resetFactory()">Try Again</button>
          </div>
        </div>
      </div>

      <div class="aviram-surface">
        <h2>Generation Log</h2>
        <div class="log-container" id="logContainer">
          <p style="color: var(--text-secondary); opacity: 0.6;">Logs will appear here during generation...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="system-status" title="System Ready"></div>

  <script>
    function initAviramContext() {
      const supportsBackdropFilter = CSS.supports('backdrop-filter', 'blur(1px)') ||
                                     CSS.supports('-webkit-backdrop-filter', 'blur(1px)');

      if (!supportsBackdropFilter) {
        console.warn('Backdrop filter not supported - using fallback');
        document.querySelectorAll('.aviram-surface').forEach(el => {
          el.style.background = 'rgba(30, 33, 39, 0.95)';
        });
      }

      document.querySelectorAll('.aviram-surface').forEach(surface => {
        surface.addEventListener('mouseenter', function() {
          this.style.willChange = 'backdrop-filter, transform';
        });

        surface.addEventListener('mouseleave', function() {
          this.style.willChange = 'auto';
        });
      });
    }

    let currentStep = 0;
    let generatedSkillData = null;
    let isGenerating = false;

    // Ideation Mode State
    let generationMode = 'single'; // 'single' or 'ideation'
    let researchMode = 'adaptive'; // 'adaptive', 'full', or 'frameworks-only'
    let ideationVariants = null;

    const steps = ['Viability', 'Input', 'Utility', 'Research', 'Generate', 'Validate', 'Package', 'Testing', 'Review'];
    const API_KEY_STORAGE_KEY = 'anthropic_api_key';

    // ============================================
    // CLAUDE CAPABILITIES CONTEXT (October 2025)
    // Single source of truth for what Claude can/cannot do
    // Updated: 2025-10-26
    // ============================================
    const CLAUDE_CAPABILITIES = {
      can_do: {
        web_search_real_time: "Claude HAS web search capability (launched March 2025)",
        bash_execution: "Claude Code CAN execute bash commands locally",
        file_operations: "Claude Code CAN read/write files locally",
        code_execution: "Claude Code CAN run scripts and commands",
        algorithm_application: "Claude CAN apply algorithms and reasoning frameworks",
        api_integration: "Claude CAN help build and execute API calls"
      },

      cannot_do: {
        production_deployment: "Claude CANNOT autonomously deploy to production systems",
        indefinite_operation: "Claude CANNOT run indefinitely without user supervision",
        protected_system_access: "Claude CANNOT access protected systems without user permission",
        permanent_state: "Claude CANNOT maintain state across independent sessions"
      },

      // Convert to prompt format for injection into LLM prompts
      toPromptFormat: function() {
        return `CRITICAL CAPABILITY FACTS (October 2025):
‚úì ${this.can_do.web_search_real_time}
‚úì ${this.can_do.bash_execution}
‚úì ${this.can_do.file_operations}
‚úì ${this.can_do.code_execution}

CLAUDE LIMITATIONS:
‚úó ${this.cannot_do.production_deployment}
‚úó ${this.cannot_do.indefinite_operation}
‚úó ${this.cannot_do.protected_system_access}`;
      }
    };

    /**
     * CLAUDE_CAPABILITIES_FOR_ANALYSIS - Full context for Phase 0 decision-making
     * Used for categorization, utility analysis, and problem identification
     */
    const CLAUDE_CAPABILITIES_FOR_ANALYSIS = {
      can_do: {
        web_search_real_time: "Claude HAS web search capability (launched March 2025)",
        bash_execution: "Claude Code CAN execute bash commands locally",
        file_operations: "Claude Code CAN read/write files locally",
        code_execution: "Claude Code CAN run scripts and commands",
        algorithm_application: "Claude CAN apply algorithms and reasoning frameworks",
        api_integration: "Claude CAN help build and execute API calls",
        web_fetch: "Claude CAN fetch and analyze web content",
        local_sandbox: "Claude Code has a local sandbox for safe code execution"
      },

      cannot_do: {
        production_deployment: "Claude CANNOT autonomously deploy to production systems",
        indefinite_operation: "Claude CANNOT run indefinitely without user supervision",
        protected_system_access: "Claude CANNOT access protected systems without user permission",
        permanent_state: "Claude CANNOT maintain state across independent sessions",
        external_api_without_code: "Claude CANNOT access external APIs without user providing code/keys",
        authenticated_services: "Claude CANNOT access authenticated services without user setup"
      },

      toPromptFormat: function() {
        return `CRITICAL CAPABILITY FACTS (November 2025):

‚úì WHAT CLAUDE CAN DO:
‚úì ${this.can_do.web_search_real_time}
‚úì ${this.can_do.bash_execution}
‚úì ${this.can_do.file_operations}
‚úì ${this.can_do.code_execution}
‚úì ${this.can_do.algorithm_application}
‚úì ${this.can_do.api_integration}
‚úì ${this.can_do.web_fetch}
‚úì ${this.can_do.local_sandbox}

‚úó CLAUDE LIMITATIONS:
‚úó ${this.cannot_do.production_deployment}
‚úó ${this.cannot_do.indefinite_operation}
‚úó ${this.cannot_do.protected_system_access}
‚úó ${this.cannot_do.permanent_state}
‚úó ${this.cannot_do.external_api_without_code}
‚úó ${this.cannot_do.authenticated_services}`;
      }
    };

    /**
     * GENERATION_GUIDELINES - Concise guidelines for Phase 3 skill generation
     * Focuses on length limits, style rules, and brevity
     */
    const GENERATION_GUIDELINES = {
      length_limits: {
        main_skill_md: 500,        // lines maximum
        single_example: 50,        // lines per example
        constraints_section: 100   // lines maximum
      },

      style_rules: [
        "Use progressive disclosure (30-50 tokens at startup)",
        "1-2 detailed examples per major use case (50 lines each MAX)",
        "Constraints: only what's directly relevant to THIS skill",
        "Move extended examples to /references/ directory if needed"
      ],

      capabilities_mention: [
        "Claude Code can execute bash locally",
        "Claude has web_search for current information",
        "Skills cannot access external APIs without code execution"
      ],

      toPromptFormat: function() {
        return `**GENERATION GUIDELINES - BE CONCISE**

üìè LENGTH REQUIREMENTS (STRICT):
- Main SKILL.md: MAXIMUM ${this.length_limits.main_skill_md} lines total
- Each example: MAXIMUM ${this.length_limits.single_example} lines
- Constraints section: MAXIMUM ${this.length_limits.constraints_section} lines
- DO NOT create exhaustive lists of capabilities

üìù STYLE RULES:
${this.style_rules.map(rule => `- ${rule}`).join('\n')}

‚ö° KEY CAPABILITIES (brief mention only):
${this.capabilities_mention.map(cap => `- ${cap}`).join('\n')}

‚ùó CRITICAL:
- Focus on THIS skill's specific use case
- Only mention constraints directly relevant to THIS skill
- DO NOT document all of Claude's capabilities
- Keep examples practical and focused
- If you need more examples, move them to /references/ directory`;
      }
    };

    const KNOWLEDGE_ENHANCEMENT_PROMPT = `You are a domain research specialist helping create the BEST POSSIBLE knowledge skill for Claude.

Your mission: Transform a generic skill concept into a deeply specialized expertise package.

UNDERSTANDING KNOWLEDGE SKILLS:
- KNOWLEDGE skills provide domain expertise, frameworks, and specialized know-how
- They are NOT automation tools, processors, or executors
- They enhance Claude's reasoning and output quality through structured expertise
- Value comes from crystallizing expert knowledge into reusable frameworks

RESEARCH PROCESS:

1. DOMAIN DEEP DIVE
   Investigate the domain thoroughly:
   - What are the specialized sub-domains and focus areas?
   - What frameworks and methodologies do experts use?
   - What techniques differentiate experts from novices?
   - What mental models and decision-making processes exist?
   - What common mistakes do practitioners make?
   - What knowledge is typically learned through years of experience?

2. EXPERTISE SYNTHESIS
   Identify what would elevate Claude's capabilities:
   - Core knowledge domains (the "what")
   - Proven frameworks and methodologies (the "how")
   - Guiding principles and best practices (the "why")
   - Domain-specific terminology and concepts
   - Advanced techniques and expert heuristics
   - Context that transforms output from good to exceptional

3. ENHANCEMENT STRATEGY
   Crystallize findings into a focused skill:
   - What specific expertise areas should this cover?
   - What frameworks can be systematically applied?
   - What knowledge gaps would this fill?
   - What value does this add over Claude's base knowledge?
   - How does this make Claude's output demonstrably better?

CRITICAL RULES:
- Stay within the SAME domain (don't pivot to different skill types)
- Focus on KNOWLEDGE and EXPERTISE (not tools or automation)
- Be SPECIFIC and SPECIALIZED (not generic templates)
- Identify FRAMEWORKS that can be systematically applied
- Crystallize EXPERT-LEVEL insights (not beginner content)

OUTPUT FORMAT (valid JSON only):
{
  "enhanced_concept": "specific, focused skill name",
  "knowledge_domains": [
    "domain 1 with brief description",
    "domain 2 with brief description",
    "domain 3 with brief description"
  ],
  "key_frameworks": [
    "framework 1: what it does",
    "framework 2: what it does",
    "framework 3: what it does"
  ],
  "expertise_areas": [
    "advanced technique/concept 1",
    "advanced technique/concept 2",
    "advanced technique/concept 3"
  ],
  "value_proposition": "Clear statement of how this expertise elevates Claude's capabilities in this domain",
  "research_summary": "2-3 sentence summary of what you discovered about this domain and why this enhancement matters"
}

EXAMPLES OF GOOD ENHANCEMENTS:

Generic: "marketing-expert"
Enhanced: "conversion-psychology-strategist"
Why: Specific focus on psychological triggers, decision-making heuristics, and behavioral economics in marketing

Generic: "senior-copywriter"
Enhanced: "strategic-messaging-architect"
Why: Focus on message hierarchy, audience psychology, brand voice systems, and cross-channel messaging frameworks

Generic: "data-analyst"
Enhanced: "analytical-storytelling-framework"
Why: Bridges quantitative analysis with narrative structure, visualization psychology, and insight communication

YOUR TASK:
Research the provided skill concept deeply, synthesize expert-level knowledge, and output enhanced skill specifications in valid JSON format.`;

    // ============================================
    // REUSABLE CONTEXT RELIABILITY v1.3
    // Assisted Fallback + Adaptive Research + Guards
    // ============================================

    /**
     * ADAPTIVE_RESEARCH_CONFIG - Controls research behavior based on input completeness
     *
     * Modes:
     * - full: Full research when all inputs (audience, goal, constraints) present
     * - adaptive: Patterns-only research when inputs incomplete
     * - none: Framework-only, no external research (when STRICT_MODE=true)
     */
    const ADAPTIVE_RESEARCH_CONFIG = {
      mode: 'adaptive',  // 'full' | 'adaptive' | 'none'
      STRICT_MODE: false,  // If true, forces mode='none'

      getEffectiveMode: function(inputsComplete) {
        if (this.STRICT_MODE) return 'none';
        if (this.mode === 'full' && inputsComplete) return 'full';
        if (this.mode === 'adaptive' && !inputsComplete) return 'adaptive';
        return this.mode;
      },

      shouldUseResearch: function(inputsComplete) {
        const effectiveMode = this.getEffectiveMode(inputsComplete);
        return effectiveMode !== 'none';
      },

      getResearchScope: function(inputsComplete) {
        const effectiveMode = this.getEffectiveMode(inputsComplete);
        if (effectiveMode === 'full') return 'full_research';
        if (effectiveMode === 'adaptive') return 'patterns_only';
        return 'frameworks_only';
      }
    };

    // Global state for context history (for inference)
    let contextHistory = {
      previousInputs: [],
      inferredContext: {}
    };

    /**
     * Check if required inputs (audience, goal, constraints) are present
     * Returns object with completeness status and missing fields
     */
    function checkInputCompleteness(requirements) {
      const missing = [];
      const present = [];

      // Check for audience
      const audienceKeywords = ['audience', 'user', 'for', 'who', 'target', 'practitioner'];
      const hasAudience = requirements.description &&
        audienceKeywords.some(kw => requirements.description.toLowerCase().includes(kw));

      if (!hasAudience && !requirements.audience) {
        missing.push('audience');
      } else {
        present.push('audience');
      }

      // Check for goal
      const goalKeywords = ['goal', 'objective', 'purpose', 'to', 'achieve', 'outcome', 'result'];
      const hasGoal = requirements.description &&
        goalKeywords.some(kw => requirements.description.toLowerCase().includes(kw));

      if (!hasGoal && !requirements.goal) {
        missing.push('goal');
      } else {
        present.push('goal');
      }

      // Check for constraints
      const constraintKeywords = ['cannot', 'limitation', 'constraint', 'requires', 'depends', 'only'];
      const hasConstraints = requirements.description &&
        constraintKeywords.some(kw => requirements.description.toLowerCase().includes(kw));

      if (!hasConstraints && !requirements.constraints) {
        missing.push('constraints');
      } else {
        present.push('constraints');
      }

      return {
        complete: missing.length === 0,
        missing: missing,
        present: present,
        completeness_score: present.length / 3.0
      };
    }

    /**
     * Attempt to infer missing fields from context and history
     * Returns inferred values and records what was inferred
     */
    async function inferMissingFields(requirements, missing) {
      const inferred = {};
      const inferredFields = [];

      // Try to infer from description and domain
      const description = requirements.description || '';
      const skillName = requirements.skill_name || '';
      const domain = requirements.domain || 'general';

      for (const field of missing) {
        if (field === 'audience') {
          // Infer audience from domain and skill name
          let audience = '<needed>';
          if (domain && domain !== 'general') {
            audience = `${domain} practitioners`;
            inferredFields.push('audience');
          } else if (description.includes('developer') || description.includes('engineer')) {
            audience = 'developers and engineers';
            inferredFields.push('audience');
          } else if (description.includes('designer') || description.includes('creative')) {
            audience = 'designers and creatives';
            inferredFields.push('audience');
          }
          inferred.audience = audience;
        }

        if (field === 'goal') {
          // Infer goal from description
          let goal = '<needed>';
          if (description.includes('improve') || description.includes('enhance')) {
            goal = 'improve effectiveness';
            inferredFields.push('goal');
          } else if (description.includes('automate') || description.includes('streamline')) {
            goal = 'automate and streamline workflow';
            inferredFields.push('goal');
          } else if (description.includes('learn') || description.includes('understand')) {
            goal = 'understand and apply concepts';
            inferredFields.push('goal');
          }
          inferred.goal = goal;
        }

        if (field === 'constraints') {
          // Always infer some basic constraints
          inferred.constraints = ['<needed - specify any limitations>'];
          // Don't mark as inferred since we're just providing a placeholder
        }
      }

      // Store inference in context history
      contextHistory.inferredContext = {
        ...contextHistory.inferredContext,
        ...inferred,
        timestamp: new Date().toISOString()
      };

      return {
        inferred: inferred,
        inferredFields: inferredFields
      };
    }

    /**
     * Generate mini examples for assisted prompt pack
     * Creates 3 short, practical examples
     */
    async function generateMiniExamples(requirements, domain) {
      const prompt = `Generate 3 concise, practical examples for a prompt pack.

Domain: ${domain}
Skill: ${requirements.skill_name}
Description: ${requirements.description}

Create 3 mini-examples (1-2 lines each) that show different approaches:
1. Outcome-first approach
2. Risk-reversal approach
3. Proof-led approach

Return ONLY valid JSON:
{
  "examples": [
    "Example 1 text here",
    "Example 2 text here",
    "Example 3 text here"
  ]
}`;

      try {
        let response = await callClaude(prompt, 500, 'utility');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        return parsed.examples || [
          'Outcome-first headline approach',
          'Risk-reversal CTA pattern',
          'Proof-led alternative headline'
        ];
      } catch (err) {
        // Fallback examples
        return [
          'Outcome-first: Focus on the end result',
          'Risk-reversal: Address objections proactively',
          'Proof-led: Lead with evidence or examples'
        ];
      }
    }

    /**
     * Generate research notes for assisted prompt pack
     * Creates short summary of frameworks/patterns discovered
     */
    async function generateResearchNotes(requirements, domain) {
      const scope = ADAPTIVE_RESEARCH_CONFIG.getResearchScope(false);

      if (scope === 'frameworks_only') {
        return [
          'Framework-only mode - no external research conducted',
          'Using built-in Claude capabilities and patterns'
        ];
      }

      const prompt = `Generate 2-3 brief research notes about ${domain} for ${requirements.skill_name}.

Focus on:
- Top frameworks or patterns in this domain
- Recent best practices or testing approaches
- Key considerations for practitioners

Return ONLY valid JSON:
{
  "notes": [
    "Note 1",
    "Note 2",
    "Note 3"
  ]
}`;

      try {
        let response = await callClaude(prompt, 500, 'research');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        return parsed.notes || [
          'Top frameworks surfaced for this domain',
          'Recent testing patterns identified'
        ];
      } catch (err) {
        return [
          'Top frameworks surfaced for this domain',
          'Recent testing patterns identified'
        ];
      }
    }

    /**
     * Generate 3 clarifying questions for assisted prompt pack
     */
    function generateClarifyingQuestions(missing, requirements) {
      const questions = [];

      if (missing.includes('audience')) {
        questions.push('Who is the primary audience for this skill?');
      }

      if (missing.includes('goal')) {
        questions.push('What is the single most important success goal?');
      }

      if (missing.includes('constraints')) {
        questions.push('Are there any tone, brand, or technical constraints?');
      }

      // Add a general question if we have less than 3
      if (questions.length < 3) {
        questions.push('What specific use cases do you have in mind?');
      }

      return questions.slice(0, 3);  // Max 3 questions
    }

    /**
     * Create ASSISTED_PROMPT_PACK output
     * Returns a structured mini prompt pack with examples, notes, and questions
     */
    async function createAssistedPromptPack(requirements, completenessCheck, inferenceResult) {
      addLog('Creating assisted prompt pack...', 'info');
      updateProgress('Assisted Fallback', 50, 'Generating mini examples and research notes...');

      const domain = requirements.domain || 'general';

      // Generate mini examples and research notes in parallel
      const [miniExamples, researchNotes] = await Promise.all([
        generateMiniExamples(requirements, domain),
        generateResearchNotes(requirements, domain)
      ]);

      // Generate clarifying questions
      const questions = generateClarifyingQuestions(completenessCheck.missing, requirements);

      // Build the assisted prompt pack
      const assistedPack = {
        type: 'prompt_pack_assisted',
        meta: {
          route: 'fallback',
          inferred: inferenceResult.inferredFields.length > 0,
          inferred_fields: inferenceResult.inferredFields,
          research_mode: ADAPTIVE_RESEARCH_CONFIG.getEffectiveMode(false),
          completeness_score: completenessCheck.completeness_score
        },
        contents: {
          domain: domain,
          audience: inferenceResult.inferred.audience || '<needed>',
          goal: inferenceResult.inferred.goal || '<needed>',
          constraints: inferenceResult.inferred.constraints || ['<needed>'],
          mini_examples: miniExamples,
          research_notes: researchNotes
        },
        questions: questions,
        actions: {
          continue_with_answers: {
            description: 'Continue generation with your answers',
            endpoint: '/factory/continue',
            method: 'POST',
            payload_template: {
              idempotency_key: `${requirements.skill_name}-${Date.now()}`,
              answers: {
                audience: '<your answer>',
                goal: '<your answer>',
                constraints: ['<your answer>']
              }
            }
          }
        },
        test_metadata: {
          metric: 'CTR',
          variants: ['emotional', 'rational', 'hybrid'],
          threshold: 'baseline +10%'
        }
      };

      addLog('Assisted prompt pack created', 'success');
      updateProgress('Assisted Fallback', 100, 'Ready for clarification');

      return assistedPack;
    }

    /**
     * Display assisted prompt pack to user
     */
    async function showAssistedPromptPack(assistedPack) {
      // Hide progress card
      document.getElementById('progressCard').classList.add('hidden');

      // Create and show assisted pack UI
      const container = document.getElementById('resultsContainer');
      container.innerHTML = '';

      const card = document.createElement('div');
      card.className = 'aviram-surface';
      card.innerHTML = `
        <h2 style="color: var(--accent-primary); margin-bottom: 1.5rem;">üì¶ Mini Prompt Pack (Assisted)</h2>

        <div style="margin-bottom: 2rem;">
          <h3 style="color: var(--text-primary); font-size: 1.1rem; margin-bottom: 0.5rem;">üìã Context</h3>
          <div style="background: rgba(20, 22, 26, 0.5); padding: 1rem; border-radius: 12px; margin-bottom: 1rem;">
            <p><strong>Domain:</strong> ${assistedPack.contents.domain}</p>
            <p><strong>Audience:</strong> ${assistedPack.contents.audience}</p>
            <p><strong>Goal:</strong> ${assistedPack.contents.goal}</p>
            <p><strong>Constraints:</strong> ${assistedPack.contents.constraints.join(', ')}</p>
          </div>
          ${assistedPack.meta.inferred ? `
            <div style="background: rgba(138, 180, 248, 0.1); padding: 0.75rem; border-radius: 8px; border-left: 3px solid var(--accent-primary); margin-bottom: 1rem;">
              <p style="margin: 0; font-size: 0.9rem;">
                ‚ÑπÔ∏è <strong>Inferred fields:</strong> ${assistedPack.meta.inferred_fields.join(', ')}
              </p>
            </div>
          ` : ''}
        </div>

        <div style="margin-bottom: 2rem;">
          <h3 style="color: var(--text-primary); font-size: 1.1rem; margin-bottom: 0.5rem;">‚ú® Mini Examples</h3>
          <div style="background: rgba(20, 22, 26, 0.5); padding: 1rem; border-radius: 12px;">
            ${assistedPack.contents.mini_examples.map((ex, i) => `
              <div style="margin-bottom: 0.75rem;">
                <span style="color: var(--accent-secondary);">${i + 1}.</span> ${ex}
              </div>
            `).join('')}
          </div>
        </div>

        <div style="margin-bottom: 2rem;">
          <h3 style="color: var(--text-primary); font-size: 1.1rem; margin-bottom: 0.5rem;">üìö Research Notes</h3>
          <div style="background: rgba(20, 22, 26, 0.5); padding: 1rem; border-radius: 12px;">
            ${assistedPack.contents.research_notes.map(note => `
              <div style="margin-bottom: 0.5rem;">‚Ä¢ ${note}</div>
            `).join('')}
          </div>
        </div>

        <div style="margin-bottom: 2rem;">
          <h3 style="color: var(--text-primary); font-size: 1.1rem; margin-bottom: 0.5rem;">‚ùì Clarifying Questions</h3>
          <div style="background: rgba(20, 22, 26, 0.5); padding: 1rem; border-radius: 12px;">
            ${assistedPack.questions.map((q, i) => `
              <div style="margin-bottom: 1rem;">
                <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary);">
                  ${i + 1}. ${q}
                </label>
                <input type="text" id="answer_${i}"
                  style="width: 100%; padding: 0.75rem; background: rgba(20, 22, 26, 0.8); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; color: var(--text-primary);"
                  placeholder="Your answer..." />
              </div>
            `).join('')}
          </div>
        </div>

        <div style="margin-bottom: 1rem;">
          <h3 style="color: var(--text-primary); font-size: 1.1rem; margin-bottom: 0.5rem;">üß™ Test Metadata</h3>
          <div style="background: rgba(20, 22, 26, 0.5); padding: 1rem; border-radius: 12px;">
            <p><strong>Metric:</strong> ${assistedPack.test_metadata.metric}</p>
            <p><strong>Variants:</strong> ${assistedPack.test_metadata.variants.join(', ')}</p>
            <p><strong>Threshold:</strong> ${assistedPack.test_metadata.threshold}</p>
          </div>
        </div>

        <div class="button-group">
          <button class="btn" onclick="continueWithAnswers()">
            Continue with Answers ‚Üí
          </button>
          <button class="btn btn-secondary" onclick="resetFactory()">
            Start Over
          </button>
        </div>

        <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(138, 180, 248, 0.05); border-radius: 8px; border: 1px solid rgba(138, 180, 248, 0.2);">
          <h4 style="color: var(--accent-primary); font-size: 0.95rem; margin-bottom: 0.5rem;">üìä Routing Decision</h4>
          <p style="margin: 0; font-size: 0.9rem;">
            <strong>Decision:</strong> NOT VIABLE ‚Üí Route: ASSISTED_PROMPT_PACK
            ${assistedPack.meta.inferred_fields.length > 0 ? `(inferred=[${assistedPack.meta.inferred_fields.map(f => `'${f}'`).join(', ')}])` : ''}
          </p>
          <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">
            <strong>Research Mode:</strong> ${assistedPack.meta.research_mode}
          </p>
        </div>
      `;

      container.appendChild(card);
      container.classList.remove('hidden');

      // Store assisted pack globally for continue function
      window.currentAssistedPack = assistedPack;
    }

    /**
     * Continue generation with user-provided answers
     */
    async function continueWithAnswers() {
      const assistedPack = window.currentAssistedPack;
      if (!assistedPack) {
        addLog('No assisted pack found', 'error');
        return;
      }

      // Collect answers from input fields
      const answers = {};
      assistedPack.questions.forEach((q, i) => {
        const input = document.getElementById(`answer_${i}`);
        if (input && input.value.trim()) {
          const key = q.toLowerCase().includes('audience') ? 'audience' :
                     q.toLowerCase().includes('goal') ? 'goal' :
                     q.toLowerCase().includes('constraint') ? 'constraints' :
                     `answer_${i}`;

          if (key === 'constraints') {
            answers[key] = [input.value.trim()];
          } else {
            answers[key] = input.value.trim();
          }
        }
      });

      // Validate that at least some answers provided
      if (Object.keys(answers).length === 0) {
        addLog('Please provide at least one answer to continue', 'warning');
        return;
      }

      addLog('Continuing with provided answers...', 'info');

      // Merge answers into current requirements
      if (currentRequirements) {
        Object.assign(currentRequirements, answers);

        // Re-trigger generation pipeline from research phase
        document.getElementById('resultsContainer').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');

        try {
          // Set generating flag
          isGenerating = true;

          // Continue to research phase with updated requirements
          setStep(3);
          await continueResearchPhase(currentRequirements);
        } catch (err) {
          showError(err.message);
          addLog(`Generation failed: ${err.message}`, 'error');
        } finally {
          isGenerating = false;
        }
      }
    }

    /**
     * Continue the research phase after user provides answers
     * This continues the normal pipeline from research ‚Üí generation ‚Üí validation ‚Üí package
     */
    async function continueResearchPhase(requirements) {
      addLog('Resuming generation pipeline from research phase...', 'success');

      try {
        // Research phase
        setStep(3);
        const research = await conductResearch(requirements);

        // Generate phase with auto-validation loop
        setStep(4);
        const result = await generateWithAutoValidation(requirements, research);

        // Log auto-validation result
        if (result.status === 'production_ready') {
          addLog(`‚úì Auto-validation succeeded in ${result.attempt} attempt(s)`, 'success');
        } else if (result.status === 'partially_validated') {
          addLog(`‚ö†Ô∏è Partial validation after ${result.attempt} attempt(s). ${result.remainingIssues.length} issue(s) remain.`, 'warning');
        } else {
          addLog(`‚ö†Ô∏è Max validation attempts reached. Proceeding with best version.`, 'warning');
        }

        const skillPackage = result.skillPackage;

        // Final validation phase
        setStep(5);
        const validation = await validateGeneration(skillPackage);

        if (validation.issues.length > 0) {
          throw new Error(`Validation failed: ${validation.issues.join(', ')}`);
        }

        // Package phase
        setStep(6);
        const resourceData = research.resourceData || null;
        const pkg = await packageSkill(skillPackage, requirements.skill_name, resourceData);

        // Testing phase
        setStep(7);
        addLog('Starting skill testing phase...', 'info');
        const testResults = await stage7_testSkill(skillPackage, requirements);

        // Iterate if needed based on test results
        const iterationResult = await stage8_iterateIfNeeded(
          skillPackage,
          testResults,
          requirements,
          0
        );

        // Use the final skill from iteration result
        const finalSkill = iterationResult.finalSkill || skillPackage;
        const finalTestResults = iterationResult.testResults || testResults;

        // Build comprehensive metadata
        const skillMetadata = {
          skill_name: requirements.skill_name,
          description: requirements.description,
          created: new Date().toISOString(),
          viability_score: requirements.viability_check?.viability_score || 0,
          test_pass_rate: finalTestResults.passRate,
          tests_passed: finalTestResults.passedTests,
          tests_total: finalTestResults.totalTests,
          iterations: iterationResult.iterations || 0,
          status: iterationResult.status,
          research_sources: research.domainKnowledge ?
            Object.values(research.domainKnowledge)
              .flatMap(r => r.sources || [])
              .filter(s => s && s !== 'web-research') : [],
          resources: {
            scripts: resourceData ? Object.keys(resourceData.resources.scripts) : [],
            references: resourceData ? Object.keys(resourceData.resources.references) : [],
            assets: resourceData ? Object.keys(resourceData.resources.assets) : []
          }
        };

        // Re-package with final skill and metadata
        const finalPkg = await packageSkill(
          finalSkill,
          requirements.skill_name,
          resourceData,
          skillMetadata
        );

        // Pre-format the prompt for clipboard
        const skillContent = `---\n${finalSkill.metadata}\n---\n\n${finalSkill.documentation}`;
        const promptForClipboard = `You are now equipped with the following skill:

---
${skillContent}
---

When the user asks questions or requests tasks related to the topics covered in this skill, use the knowledge and guidelines from this skill to assist them.`;

        // Store test results in package
        generatedSkillData = {
          package: finalPkg.content,
          filename: finalPkg.filename,
          tree: finalPkg.tree,
          validation,
          testResults: finalTestResults,
          iterations: iterationResult.iterations,
          status: iterationResult.status,
          metadata: skillMetadata,
          promptForClipboard: promptForClipboard
        };

        // Show final results
        setStep(8);
        await showResults(finalSkill, finalPkg.tree, validation, finalTestResults, skillMetadata);

        addLog('Skill generation complete!', 'success');

      } catch (err) {
        throw err;
      }
    }

    // API Key localStorage Management
    function loadApiKey() {
      const savedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
      if (savedKey) {
        document.getElementById('apiKey').value = savedKey;
        collapseApiConfig();
      }
    }

    function saveApiKey() {
      const apiKey = document.getElementById('apiKey').value.trim();
      if (apiKey) {
        localStorage.setItem(API_KEY_STORAGE_KEY, apiKey);
        collapseApiConfig();
        addLog('API key saved locally', 'success');
      }
    }

    function collapseApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.add('collapsed');
      collapsedView.classList.remove('hidden');
      formView.classList.add('hidden');
    }

    function expandApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.remove('collapsed');
      collapsedView.classList.add('hidden');
      formView.classList.remove('hidden');

      // Focus the input field
      document.getElementById('apiKey').focus();
    }

    function toggleCollapsibleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.classList.toggle('collapsed');
      }
    }

    function updateUtilityScoreRing(score, max = 10) {
      const percentage = (score / max) * 100;
      const radius = 50;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percentage / 100) * circumference;

      const getUtilityClass = (score) => {
        if (score >= 7) return 'high-utility';
        if (score >= 4) return 'medium-utility';
        return 'low-utility';
      };

      const getCategory = (score) => {
        if (score >= 7) return 'HIGH UTILITY';
        if (score >= 4) return 'MEDIUM UTILITY';
        return 'LOW UTILITY';
      };

      const utilityClass = getUtilityClass(score);
      const category = getCategory(score);

      const ringElement = document.getElementById('utilityScoreRing');
      if (ringElement) {
        ringElement.className = `utility-score-container ${utilityClass}`;
        ringElement.querySelector('.circle-progress').style.strokeDashoffset = offset;
        ringElement.querySelector('.score-value').textContent = score;
        ringElement.querySelector('.category-label').textContent = category;
      }
    }

    function clearApiKey() {
      if (confirm('Are you sure you want to clear your saved API key?')) {
        localStorage.removeItem(API_KEY_STORAGE_KEY);
        document.getElementById('apiKey').value = '';
        expandApiConfig();
        addLog('API key cleared', 'info');
      }
    }

    function init() {
      initAviramContext();
      renderStepper();
      loadApiKey();
    }

    function renderStepper() {
      const stepper = document.getElementById('stepper');
      stepper.innerHTML = '';

      steps.forEach((stepName, index) => {
        const step = document.createElement('div');
        step.className = 'step';

        const circle = document.createElement('div');
        circle.className = 'step-circle';
        if (index === currentStep) circle.classList.add('active');
        if (index < currentStep) circle.classList.add('complete');
        circle.textContent = index < currentStep ? '‚úì' : index + 1;

        const label = document.createElement('div');
        label.className = 'step-label';
        if (index === currentStep) label.classList.add('active');
        label.textContent = stepName;

        const line = document.createElement('div');
        line.className = 'step-line';
        if (index < currentStep) line.classList.add('complete');

        step.appendChild(circle);
        step.appendChild(label);
        step.appendChild(line);
        stepper.appendChild(step);
      });
    }

    function setStep(step) {
      currentStep = step;
      renderStepper();
    }

    function setExample(text) {
      document.getElementById('skillInput').value = text;
    }

    // Ideation Mode Functions
    function setGenerationMode(mode) {
      generationMode = mode;

      // Update UI button states
      document.querySelectorAll('.mode-option').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-mode') === mode) {
          btn.classList.add('active');
        }
      });

      // Show/hide research mode selector when in ideation mode
      const researchModeSelector = document.getElementById('researchModeSelector');
      if (mode === 'ideation') {
        researchModeSelector.style.display = 'flex';
        document.getElementById('generateBtn').innerHTML = 'Ideate 3 Variants ‚Üí';
      } else {
        researchModeSelector.style.display = 'none';
        document.getElementById('generateBtn').innerHTML = 'Generate This Skill ‚Üí';
      }
    }

    function updateResearchMode() {
      researchMode = document.getElementById('researchModeSelect').value;
    }

    function addLog(message, type = 'info') {
      const container = document.getElementById('logContainer');

      if (container.querySelector('p')) {
        container.innerHTML = '';
      }

      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;

      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `<span class="log-time">${time}</span>${message}`;

      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }

    /**
     * Model router configuration for UI display
     */
    const ModelSpeedIndicators = {
      // Haiku phases (fast model)
      'stage0': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },
      'extraction': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },
      'utility': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },
      'categorization': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },
      'autofix': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },
      'testing': { icon: '‚ö°', label: 'fast mode', color: '#10b981' },

      // Sonnet phases (quality model)
      'research': { icon: 'üéØ', label: 'quality mode', color: '#667eea' },
      'research_workers': { icon: 'üéØ', label: 'quality mode', color: '#667eea' },
      'generation': { icon: 'üéØ', label: 'quality mode', color: '#667eea' },
      'metadata': { icon: 'üéØ', label: 'quality mode', color: '#667eea' },
      'refinement': { icon: 'üéØ', label: 'quality mode', color: '#667eea' },
      'validation': { icon: 'üéØ', label: 'quality mode', color: '#667eea' }
    };

    function updateProgress(stage, percent, message, phase = null) {
      // Update basic progress
      document.getElementById('progressPercent').textContent = `${percent}%`;
      document.getElementById('progressFill').style.width = `${percent}%`;
      document.getElementById('progressMessage').textContent = message;

      // Update stage with optional model indicator
      const stageElement = document.getElementById('progressStage');
      if (phase && ModelSpeedIndicators[phase]) {
        const indicator = ModelSpeedIndicators[phase];
        stageElement.innerHTML = `
          ${stage}
          <span style="
            font-size: 12px;
            opacity: 0.7;
            margin-left: 8px;
            color: ${indicator.color};
            font-weight: 500;
          ">${indicator.icon} ${indicator.label}</span>
        `;
      } else {
        stageElement.textContent = stage;
      }
    }

    function showError(message) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('errorSection').classList.remove('hidden');
      document.getElementById('errorMessage').textContent = message;
    }

    async function showClarificationUI(clarificationData) {
      // Hide progress, show input card with clarification options
      document.getElementById('progressCard').classList.add('hidden');
      document.getElementById('inputCard').classList.remove('hidden');

      const inputSection = document.getElementById('inputCard');

      // Create clarification UI
      const clarificationHTML = `
        <div style="margin-top: 20px; padding: 20px; background: rgba(255, 152, 0, 0.1); border: 2px solid var(--warning); border-radius: 8px;">
          <h3 style="color: var(--warning); margin-top: 0;">ü§î Which skill did you mean?</h3>
          <p style="margin-bottom: 15px;">Your input <strong>"${clarificationData.original_input}"</strong> could mean different things. Please choose:</p>
          <div id="clarificationOptions" style="display: flex; flex-direction: column; gap: 10px;">
            ${clarificationData.alternatives.map((alt, idx) => `
              <button class="clarification-option" data-index="${idx}" style="
                padding: 15px;
                background: var(--surface);
                border: 2px solid var(--border);
                border-radius: 8px;
                cursor: pointer;
                text-align: left;
                transition: all 0.2s;
              ">
                <strong style="color: var(--accent-primary);">${alt.skill_name}</strong>
                <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9em;">${alt.description}</p>
              </button>
            `).join('')}
            <button id="refineInputBtn" style="
              padding: 15px;
              background: var(--surface);
              border: 2px dashed var(--border);
              border-radius: 8px;
              cursor: pointer;
              color: var(--text-secondary);
            ">
              ‚úèÔ∏è Or refine my input instead
            </button>
          </div>
        </div>
      `;

      // Insert after the input textarea
      const skillInput = document.getElementById('skillInput');
      const existingClarification = document.getElementById('clarificationSection');
      if (existingClarification) {
        existingClarification.remove();
      }

      const clarificationDiv = document.createElement('div');
      clarificationDiv.id = 'clarificationSection';
      clarificationDiv.innerHTML = clarificationHTML;
      skillInput.parentNode.insertBefore(clarificationDiv, skillInput.nextSibling);

      // Add event listeners
      document.querySelectorAll('.clarification-option').forEach(btn => {
        btn.addEventListener('mouseover', function() {
          this.style.borderColor = 'var(--accent-primary)';
          this.style.background = 'rgba(139, 92, 246, 0.1)';
        });
        btn.addEventListener('mouseout', function() {
          this.style.borderColor = 'var(--border)';
          this.style.background = 'var(--surface)';
        });
        btn.addEventListener('click', function() {
          const idx = parseInt(this.dataset.index);
          const chosen = clarificationData.alternatives[idx];
          // Update the input field and regenerate
          document.getElementById('skillInput').value = chosen.skill_name;
          clarificationDiv.remove();
          startGeneration();
        });
      });

      document.getElementById('refineInputBtn').addEventListener('click', function() {
        clarificationDiv.remove();
        document.getElementById('skillInput').focus();
      });
    }

    function showResults(validation, tree, filename) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('resultsSection').classList.remove('hidden');
      document.getElementById('qualityScore').textContent = `Quality Score: ${validation.qualityScore}/100`;

      const treeHtml = renderFileTree(tree);
      document.getElementById('fileTree').innerHTML = `<strong style="color: var(--accent-primary);">üì¶ Package Contents</strong>${treeHtml}`;
    }

    function renderFileTree(node, depth = 0) {
      let html = '';
      const indent = '  '.repeat(depth);

      if (node.type === 'folder') {
        html += `<div class="file-item folder">${indent}üìÅ ${node.name}/</div>`;
        if (node.children) {
          node.children.forEach(child => {
            html += renderFileTree(child, depth + 1);
          });
        }
      } else {
        const size = node.size ? ` (${(node.size / 1024).toFixed(1)} KB)` : '';
        html += `<div class="file-item file">${indent}üìÑ ${node.name}${size}</div>`;
      }

      return html;
    }

    function sanitizeFileName(name) {
      return name
        .toLowerCase()
        .replace(/[<>:"/\\|?*\x00-\x1F]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 255);
    }

    /**
     * Retry a function with exponential backoff
     * @param {Function} fn - Async function to retry
     * @param {number} maxRetries - Maximum number of retry attempts (default: 4)
     * @param {number} initialDelay - Initial delay in milliseconds (default: 2000)
     * @returns {Promise} - Result of the function
     */
    async function retryWithExponentialBackoff(fn, maxRetries = 4, initialDelay = 2000) {
      let lastError;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn();
        } catch (err) {
          lastError = err;

          // Don't retry on certain errors (API key issues, validation errors, etc.)
          if (err.message.includes('API key') ||
              err.message.includes('400') ||
              err.message.includes('401') ||
              err.message.includes('403')) {
            throw err;
          }

          // If this was the last attempt, throw the error
          if (attempt === maxRetries) {
            throw err;
          }

          // Calculate delay with exponential backoff: 2s, 4s, 8s, 16s
          const delay = initialDelay * Math.pow(2, attempt);
          addLog(`Network error on attempt ${attempt + 1}/${maxRetries + 1}. Retrying in ${delay/1000}s...`, 'warning');

          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      throw lastError;
    }

    async function callClaude(prompt, maxTokens = 2000, phase = null) {
      const apiKey = document.getElementById('apiKey').value.trim();

      if (!apiKey) {
        throw new Error('Please enter your Anthropic API key');
      }

      // Wrap the fetch call with retry logic
      return await retryWithExponentialBackoff(async () => {
        try {
          const response = await fetch("/api/claude", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              apiKey,
              prompt,
              maxTokens,
              phase
            })
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error || `API request failed with status ${response.status}`);
          }

          const data = await response.json();
          return data.text;
        } catch (err) {
          if (err.message.includes('API request failed')) {
            throw err;
          }
          throw new Error(`Network error: ${err.message}. Check your API key and internet connection.`);
        }
      });
    }

    async function extractRequirements(input) {
      addLog('Analyzing input and extracting requirements...', 'info');
      updateProgress('Input Processing', 10, 'Parsing requirements...', 'extraction');

      const prompt = `Extract skill requirements from this natural language input as JSON.

IMPORTANT: Users may phrase requests conversationally. Interpret their intent:
- "skills for X" ‚Üí they want a single skill about X
- "help me with X" ‚Üí they want an X helper/guide skill
- "I need X" ‚Üí they want an X tool/framework skill
- Plural "skills" often means they want ONE skill that covers that domain

INPUT: ${input}

Your task:
1. Identify the CORE CONCEPT they want help with (even if phrased as plural/conversational)
2. Create a singular, concrete skill name
3. Define what that skill would do

If the input is truly ambiguous (could mean 2+ completely different skills), set "needs_clarification": true and provide "alternatives" array.

Return ONLY valid JSON (no markdown):
{
  "skill_name": "lowercase-hyphenated-name",
  "description": "what it does and when to use it",
  "programming_language": "python|javascript|bash",
  "complexity": "simple|moderate|complex",
  "required_apis": ["api1", "api2"],
  "key_features": ["feature1", "feature2"],
  "needs_scripts": true|false,
  "needs_references": false,
  "needs_clarification": false,
  "alternatives": []
}

EXAMPLES:
Input: "skills for navigating a recession"
Output: {
  "skill_name": "recession-navigation-guide",
  "description": "Provides strategic frameworks and decision-making tools for business resilience during economic downturns",
  ...
}

Input: "help me debug code"
Output: {
  "skill_name": "code-debugger",
  "description": "Systematic debugging methodology and troubleshooting framework",
  ...
}`;

      try {
        let response = await callClaude(prompt, 2000, 'extraction');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const extracted = JSON.parse(response);

        // Check if clarification is needed
        if (extracted.needs_clarification && extracted.alternatives && extracted.alternatives.length > 0) {
          addLog('Input is ambiguous - needs clarification', 'warning');
          return {
            needs_clarification: true,
            alternatives: extracted.alternatives,
            original_input: input
          };
        }

        // Validate that required fields are present and not undefined
        if (!extracted.skill_name || extracted.skill_name === 'undefined') {
          throw new Error('Could not determine a single skill name from your input. Try being more specific (e.g., "weather forecast skill" instead of "skills for...")');
        }

        if (!extracted.description || extracted.description === 'undefined') {
          throw new Error('Could not determine what the skill should do. Please provide more details about the desired functionality.');
        }

        addLog(`Extracted skill: ${extracted.skill_name}`, 'success');
        updateProgress('Input Processing', 100, 'Requirements extracted');
        return extracted;
      } catch (err) {
        throw new Error(`Failed to extract requirements: ${err.message}`);
      }
    }

    async function analyzeUtility(requirements) {
      addLog('Analyzing skill utility...', 'info');
      updateProgress('Utility Analysis', 10, 'Evaluating utility value...', 'utility');

      const prompt = `You are the Universal Utility Analyzer. Your job is to determine whether
a skill request will genuinely power up Claude.

Your north star: Skills power up Claude by providing NEW CAPABILITIES or by ORGANIZING/STRUCTURING
knowledge in ways that make Claude measurably more effective. Both are valuable.

${CLAUDE_CAPABILITIES_FOR_ANALYSIS.toPromptFormat()}

Evaluate this skill request using these key questions:

1. NOVELTY: Does this provide something Claude doesn't have?
   - New algorithms, data, or processing logic? (+3-4 points)
   - Domain-specific knowledge not in training? (+3-4 points)
   - Executable code for hard problems? (+3-4 points)

2. ORGANIZATIONAL VALUE: Does this structure/organize knowledge effectively?
   - Provides ready-to-use templates/frameworks? (+2-3 points)
   - Structures decision trees or methodologies? (+2-3 points)
   - Organizes scattered knowledge into coherent guide? (+1-2 points)
   - Includes concrete examples/patterns? (+1-2 points)

   IMPORTANT: Even if Claude "knows" the domain, structured frameworks and templates
   ARE valuable power-ups. A recession navigation guide with organized frameworks is
   MORE useful than Claude generating generic advice from scratch each time.

3. APPLICABILITY: Can Claude actually use this?
   - Applies methodology directly in reasoning? (GOOD)
   - Uses knowledge in analysis/recommendations? (GOOD)
   - Generates correct code for external systems? (GOOD)
   - Just static examples with no application path? (LOW)

4. SPECIFICITY: Is it focused and actionable?
   - Targets specific domain/use case? (+1-2 points)
   - Provides concrete patterns/methods? (+1-2 points)
   - Too vague or generic? (-2-3 points)

5. Can you complete: "This skill powers up Claude by: [SPECIFIC CAPABILITY]"?
   Valid examples:
   - "...providing structured recession-response frameworks and decision templates"
   - "...embedding regex optimization algorithms not in training data"
   - "...executing FFmpeg video processing in sandbox"

SCORING RUBRIC:
- HIGH (7-10): New capabilities OR excellent organization of valuable knowledge
  * Examples: Novel algorithms, specialized domain knowledge, methodologies, structured frameworks
- MEDIUM (4-6): Moderate value through organization or supplementary knowledge
  * Examples: Organizing known concepts well, decent templates, helpful but not essential
- LOW (0-3): Minimal value - truly generic or redundant
  * Examples: Basic info Claude already explains well, exact duplicate of existing skill

ANTI-PATTERNS TO AVOID:
- Don't penalize skills just because "Claude knows the domain" - organization IS value
- Don't score METHODOLOGY/KNOWLEDGE categories harshly - structured knowledge is a real power-up
- Don't dismiss templates/frameworks - they make Claude more effective even if it could generate them

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

Output your analysis as JSON with these exact fields:
{
  "utility_score": 0-10,
  "utility_category": "HIGH_UTILITY|MEDIUM_UTILITY|LOW_UTILITY",
  "power_up_statement": "This skill powers up Claude by: [specific and testable capability]",
  "reasoning": "Why this scores as high/medium/low",
  "research_direction": "What to research to make THIS skill excellent (focus on the requested skill, not alternatives)",
  "rejection_reason": "Why rejected (only if LOW_UTILITY)",
  "recommended_redesigns": ["Alternative 1", "Alternative 2", "Alternative 3"],
  "domain": "detected domain",
  "phase_routing": "PROCEED|REDESIGN|REJECT"
}

IMPORTANT: research_direction should guide research for the REQUESTED skill.
- If KNOWLEDGE skill: "Find the best [domain] knowledge, principles, patterns to include"
- If PROCESSOR skill: "Research [domain] processing logic and algorithms"
- If METHODOLOGY skill: "Find the most effective [domain] methodologies and frameworks"
- DO NOT use research_direction to suggest pivoting to different skills - that's Problem Identifier's job

recommended_redesigns can suggest alternatives, but research_direction must stay focused on the actual request.

ROUTING RULES:
- Score 7-10: "PROCEED" (HIGH_UTILITY)
- Score 4-6: "PROCEED" for real power-ups, "REDESIGN" for marginal cases
- Score 0-3: "REJECT" (LOW_UTILITY) - suggest 2-3 alternatives

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1500, 'utility');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const analysis = JSON.parse(response);

        // Validate response structure
        if (!analysis.utility_score || !analysis.utility_category || !analysis.phase_routing) {
          throw new Error('Invalid analysis structure received');
        }

        addLog(`Utility score: ${analysis.utility_score}/10 (${analysis.utility_category})`,
               analysis.utility_score >= 7 ? 'success' : analysis.utility_score >= 4 ? 'warning' : 'error');
        addLog(`Power-up: ${analysis.power_up_statement}`, 'info');
        updateProgress('Utility Analysis', 100, `Analysis complete: ${analysis.phase_routing}`);

        return analysis;
      } catch (err) {
        throw new Error(`Utility analysis failed: ${err.message}`);
      }
    }

    async function categorizeSkill(skillInput, requirements) {
      /**
       * PHASE 0 CATEGORIZATION GATE
       *
       * Categorize skill request to determine if it's a real power-up.
       * This gate prevents template/executor skills from scoring HIGH_UTILITY.
       *
       * Categories:
       * - TEMPLATE: Code generation (NOT power-up, max 3/10)
       * - METHODOLOGY: Reasoning frameworks (REAL power-up, max 9/10)
       * - KNOWLEDGE: Domain knowledge (REAL power-up, max 9/10)
       * - PROCESSOR: Processing/analysis logic (REAL power-up, max 9/10)
       * - REFERENCE_CODEGEN: Documentation/API reference for external tools (REAL power-up, max 9/10)
       * - EXECUTOR (v2.1 UPDATE):
       *   - AGENTIC subtype: Runs in Claude's sandbox (REAL power-up, max 6/10)
       *   - EXTERNAL subtype: Requires external systems (NOT power-up, max 2/10)
       */
      addLog('Categorizing skill type...', 'info');

      const prompt = `Categorize this skill request. The category determines the maximum
utility score and whether it's a real power-up for Claude.

Skill request: ${skillInput}
Skill name: ${requirements.skill_name}
Description: ${requirements.description}

Return ONLY valid JSON (no markdown, no extra text):
{
  "category": "TEMPLATE|METHODOLOGY|KNOWLEDGE|PROCESSOR|REFERENCE_CODEGEN|EXECUTOR",
  "category_reasoning": "why this category",
  "is_real_power_up": boolean,
  "max_utility_score": integer (0-10),
  "power_up_description": "if true, what new capability Claude gains",
  "indicators_found": ["list of words/phrases that indicated category"],
  "executor_subtype": "agentic|external|null (only for EXECUTOR category)"
}

DEFINITION GUIDE:

TEMPLATE: Code templates/examples for humans to implement
- Claude does: Recommend code patterns
- Claude gains: Nothing (already knows these patterns from training)
- Examples: "boilerplate generator", "scaffolding templates", "starter code", "code snippet library"
- Max utility: 3/10
- Indicators: "templates", "examples", "boilerplate", "scaffolding", "starter", "snippet"
- Key test: Can Claude USE this itself? If NO (just static code examples) ‚Üí TEMPLATE

METHODOLOGY: Reasoning frameworks Claude applies directly
- Claude does: Use reasoning process
- Claude gains: New way of thinking about problems
- Examples: "contradiction detector", "research methodology", "verification framework"
- Max utility: 9/10
- Indicators: "methodology", "framework for thinking", "systematic approach", "process"

KNOWLEDGE: Domain knowledge Claude uses in reasoning
- Claude does: Apply knowledge in analysis
- Claude gains: New domain expertise
- Examples: "constraint patterns", "best practices", "optimization algorithms"
- Max utility: 9/10
- Indicators: "patterns", "rules", "algorithms", "best practices", "knowledge base"

PROCESSOR: Processing/analysis logic Claude executes
- Claude does: Execute processing/analysis
- Claude gains: New capability to analyze/process
- Examples: "query analyzer", "contradiction detector", "web researcher", "fact checker", "data analyzer"
- Max utility: 9/10
- Indicators: "analyzer", "detector", "researcher", "checker", "processor", "generator"
- IMPORTANT: Web research, fact-checking, data analysis ARE PROCESSOR skills
  (Claude has web search capability and can execute these tasks)

REFERENCE_CODEGEN: Documentation/API reference for external tools
- Claude does: Generate code for external execution
- Claude gains: Knowledge to produce correct code for external systems/tools
- Examples: "Hammerspoon API docs", "Docker patterns", "Terraform templates", "Arduino reference", "GitHub Actions workflows"
- Max utility: 9/10
- Indicators: "API reference", "documentation", "patterns", "automation framework", "scripting guide"
- Key distinction: Claude CANNOT execute these tools, but CAN generate correct code/configs for them
- Use case: User asks Claude to generate code ‚Üí User executes in external environment
- IMPORTANT: This is NOT about execution - it's about code generation quality improvement

EXECUTOR: Automation that involves code execution
- IMPORTANT: EXECUTOR skills now have TWO subtypes with different utility ceilings:

EXECUTOR (AGENTIC subtype): Claude can execute safely in sandbox
- Claude does: Execute code/tools in sandbox environment
- Claude gains: New executable capability (can run FFmpeg, Python, file operations, etc.)
- Examples: "FFmpeg video processor", "Python data pipeline", "image processing with ImageMagick", "file format converter"
- Max utility: 6/10
- Indicators: "bash commands", "python script", "file operations", "data processing", "ffmpeg", "imagemagick", "tool orchestration", "sandbox"
- Key tests:
  * Can run entirely in Claude's sandbox? YES
  * Requires no external systems/services? YES
  * No privileged operations (sudo, system daemons)? YES
  * If all YES ‚Üí EXECUTOR (agentic subtype, 6/10)

EXECUTOR (EXTERNAL subtype): Requires systems Claude cannot control
- Claude does: Recommend automation scripts for external execution
- Claude gains: Nothing (requires live external systems with security/safety concerns)
- Examples: "Live CI/CD pipeline runner", "Hammerspoon automation", "production cloud deployer", "system daemon controller"
- Max utility: 2/10
- Indicators: "system daemon", "hardware control", "live database", "production deployment", "external service", "privileged access", "hammerspoon", "autohotkey", "systemd", "cron"
- Key test: Requires external systems, privileged access, or live services? If YES ‚Üí EXECUTOR (external subtype, 2/10)

${CLAUDE_CAPABILITIES_FOR_ANALYSIS.toPromptFormat()}

CRITICAL: Be strict about categorization based on ACTUAL capabilities.
- If unsure between TEMPLATE and METHODOLOGY, ask: "Can Claude apply
  this in reasoning?" If NO ‚Üí TEMPLATE. If YES ‚Üí METHODOLOGY.
- If unsure between PROCESSOR and EXECUTOR, ask: "Can Claude Code execute
  this locally?" If YES ‚Üí PROCESSOR. If NO (needs external infrastructure) ‚Üí check next rule.
- If unsure between REFERENCE_CODEGEN and EXECUTOR, ask: "Is this documentation/reference
  for code generation OR does it require runtime integration?"
  Documentation/API reference ‚Üí REFERENCE_CODEGEN. Live system integration ‚Üí EXECUTOR.
- For EXECUTOR skills, determine subtype:
  * Can run in Claude's sandbox with no external dependencies? ‚Üí AGENTIC (6/10 max)
  * Requires external systems, privileged access, or live services? ‚Üí EXTERNAL (2/10 max)
  * Examples:
    - "FFmpeg video processor" ‚Üí EXECUTOR (agentic, 6/10)
    - "Python data pipeline" ‚Üí EXECUTOR (agentic, 6/10)
    - "Hammerspoon automation" ‚Üí EXECUTOR (external, 2/10)
    - "Live database migrator" ‚Üí EXECUTOR (external, 2/10)
- Web research/fact-checking skills are PROCESSOR, not TEMPLATE
  (Claude has web search capability)
- If skill name contains "generator" or "framework" BUT generates content/logic
  (not just code templates), classify as PROCESSOR not TEMPLATE.
  Example: "physics motion generator" ‚Üí PROCESSOR (Claude generates motion)
  Example: "API client framework" ‚Üí TEMPLATE (just code templates)
  Example: "web researcher" ‚Üí PROCESSOR (Claude has web search)
  Example: "Hammerspoon automation docs" ‚Üí REFERENCE_CODEGEN (generates code for external execution)
  Example: "Docker container patterns" ‚Üí REFERENCE_CODEGEN (generates Docker configs)
  Example: "live deploy runner" ‚Üí EXECUTOR (external subtype, requires runtime integration with live systems)
  Example: "FFmpeg batch processor" ‚Üí EXECUTOR (agentic subtype, runs in Claude sandbox)`;

      try {
        let response = await callClaude(prompt, 500, 'utility');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const categorization = JSON.parse(response);

        addLog(`‚úì Category: ${categorization.category}`, 'info');
        if (categorization.category === 'EXECUTOR' && categorization.executor_subtype) {
          addLog(`‚úì Executor subtype: ${categorization.executor_subtype.toUpperCase()}`, 'info');
          // Update is_real_power_up based on subtype
          if (categorization.executor_subtype === 'agentic') {
            categorization.is_real_power_up = true;
          } else {
            categorization.is_real_power_up = false;
          }
        }
        addLog(`‚úì Real power-up: ${categorization.is_real_power_up}`, 'info');
        addLog(`‚úì Max utility for ${categorization.category}: ${categorization.max_utility_score}/10`, 'info');

        return categorization;
      } catch (err) {
        throw new Error(`Categorization failed: ${err.message}`);
      }
    }

    // ========== FACTORY MODE DETECTION ==========
    // Determines routing: ENHANCEMENT (knowledge depth), REDESIGN (alternatives), or GENERATE (proceed)

    function determineFactoryMode(skillAnalysis) {
      const { skill_category, utility_score, is_real_power_up } = skillAnalysis;

      // KNOWLEDGE skills with low utility need enhancement, not alternatives
      if (skill_category === 'KNOWLEDGE' && utility_score <= 4 && is_real_power_up) {
        return {
          mode: 'ENHANCEMENT',
          reason: 'Generic knowledge concept - needs domain research and depth'
        };
      }

      // High utility skills proceed normally
      if (utility_score >= 7) {
        return {
          mode: 'GENERATE',
          reason: 'Specific skill with clear utility - proceed to generation'
        };
      }

      // Low utility non-knowledge skills get alternatives
      return {
        mode: 'REDESIGN',
        reason: 'Low utility - suggest alternative approaches'
      };
    }

    // ========== DOMAIN EXTRACTION & VALIDATION ==========
    // Prevents domain pivoting bug by extracting practitioners and validating suggestions

    async function extractDomainContext(requirements, detectedDomain) {
      /**
       * Extract comprehensive domain context including practitioners and exclusions
       * Returns domain metadata to constrain Problem Identifier Agent
       */
      const prompt = `Extract domain context from this skill request to prevent domain pivoting.

Skill Request: ${requirements.skill_name}
Description: ${requirements.description || 'N/A'}
Detected Domain: ${detectedDomain}

Return JSON with:
{
  "primary_domain": "exact domain name (e.g., 'web research', 'motion design', 'backend coding')",
  "domain_category": "CREATIVE|CODING|RESEARCH|AUTOMATION|FINANCE|DESIGN|WORKFLOW|DATA|COMMUNICATION",
  "domain_practitioners": ["list of 2-4 specific practitioner types who work in this domain"],
  "domain_context": "brief 1-sentence explanation of what this domain involves",
  "excluded_domains": ["list of 3-5 related but DIFFERENT domains to NOT pivot to"]
}

Examples:

Input: "web research analyst skill"
Output: {
  "primary_domain": "web research",
  "domain_category": "RESEARCH",
  "domain_practitioners": ["journalists", "researchers", "competitive analysts", "fact-checkers"],
  "domain_context": "Research and verification of information from web sources",
  "excluded_domains": ["investment research", "financial analysis", "M&A due diligence", "market research", "academic research"]
}

Input: "motion design skill"
Output: {
  "primary_domain": "motion design",
  "domain_category": "CREATIVE",
  "domain_practitioners": ["animators", "motion designers", "VFX artists", "animation directors"],
  "domain_context": "Creating animated motion graphics and visual effects",
  "excluded_domains": ["product design", "UX design", "frontend development", "game development", "video editing"]
}

Input: "database schema generator"
Output: {
  "primary_domain": "backend coding",
  "domain_category": "CODING",
  "domain_practitioners": ["backend engineers", "database engineers", "API developers", "systems architects"],
  "domain_context": "Server-side development and database management",
  "excluded_domains": ["frontend development", "DevOps", "data science", "data analytics", "cloud architecture"]
}

Return ONLY the JSON object.`;

      try {
        let response = await callClaude(prompt, 500, 'utility');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        return JSON.parse(response);
      } catch (err) {
        // Fallback to basic domain context
        return {
          primary_domain: detectedDomain,
          domain_category: "GENERAL",
          domain_practitioners: ["practitioners", "users", "professionals"],
          domain_context: `Work in the ${detectedDomain} domain`,
          excluded_domains: ["other domains", "unrelated industries"]
        };
      }
    }

    async function validateDomainRelevance(userDomain, problemAnalysis, practitioners) {
      /**
       * Validate that ALL suggestions stay within the user's specified domain
       * Returns validation results with scores and issues
       */
      const suggestions = problemAnalysis.redesign_suggestions || [];
      const validationResults = [];
      const scores = [];

      for (let i = 0; i < suggestions.length; i++) {
        const suggestion = suggestions[i];

        // Check if domain_relevance_score is present and sufficient
        const score = suggestion.domain_relevance_score || 0;
        scores.push(score);

        if (score < 7) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Low domain relevance score: ${score}/10 (minimum 7 required)`,
            score: score,
            recommendation: 'REJECT'
          });
        }

        // Validate that suggestion mentions user domain practitioners or domain
        const suggestionText = JSON.stringify(suggestion).toLowerCase();
        const domainLower = userDomain.toLowerCase();
        const practitionersFound = practitioners.some(p =>
          suggestionText.includes(p.toLowerCase())
        );
        const domainMentioned = suggestionText.includes(domainLower);

        if (!practitionersFound && !domainMentioned) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Does not mention ${userDomain} domain or its practitioners`,
            score: score,
            recommendation: 'REJECT'
          });
        }
      }

      return {
        domain: userDomain,
        total_suggestions: suggestions.length,
        validation_issues: validationResults,
        all_relevant: validationResults.length === 0,
        scores: scores,
        issues: validationResults,
        recommendation: validationResults.length === 0 ? 'PROCEED' : 'REVISE'
      };
    }

    // ========== PROBLEM IDENTIFIER AGENT ==========

    async function analyzeProblem(requirements, utilityAnalysis) {
      addLog('Identifying real practitioner problems...', 'info');
      updateProgress('Problem Analysis', 30, 'Researching domain pain points...');

      // Step 1: Enhanced domain extraction with practitioners
      addLog(`Extracting domain context for: ${utilityAnalysis.domain}`, 'info');
      const domainContext = await extractDomainContext(requirements, utilityAnalysis.domain);
      addLog(`‚úì Domain identified: ${domainContext.primary_domain}`, 'success');
      addLog(`‚úì Domain practitioners: ${domainContext.domain_practitioners.join(', ')}`, 'info');

      // Helper function to escape strings for safe embedding in JSON examples
      const escapeForJSON = (str) => {
        if (!str) return str;
        return str.replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\n/g, '\\n')
                  .replace(/\r/g, '\\r')
                  .replace(/\t/g, '\\t');
      };

      const practitionersStr = escapeForJSON(domainContext.domain_practitioners.join(' or '));
      const primaryDomainStr = escapeForJSON(domainContext.primary_domain);
      const primaryDomainUpperStr = escapeForJSON(domainContext.primary_domain.toUpperCase());

      const prompt = `You are the Problem Identifier Agent for the ${domainContext.primary_domain} domain.

‚ö†Ô∏è CRITICAL CONSTRAINT - DOMAIN LOCK ‚ö†Ô∏è
ALL problem identification and redesign suggestions must be grounded EXCLUSIVELY
in the ${domainContext.primary_domain} domain and for practitioners who work in
this domain. Do NOT pivot to other industries or domains.

Domain: ${domainContext.primary_domain}
Practitioners: ${domainContext.domain_practitioners.join(', ')}
Domain Context: ${domainContext.domain_context}

üö´ DO NOT PIVOT TO THESE UNRELATED DOMAINS:
${domainContext.excluded_domains.map(d => `- ${d}`).join('\n')}

Your job is to research what practitioners in the ${domainContext.primary_domain}
domain actually struggle with, then suggest skill redesigns grounded in those
real problems.

${CLAUDE_CAPABILITIES_FOR_ANALYSIS.toPromptFormat()}

Given a skill request, answer:

1. PRACTITIONER PAIN POINTS (MUST BE IN ${domainContext.primary_domain.toUpperCase()})
   - What do ${domainContext.domain_practitioners.join(' or ')} struggle with? (Be specific, not generic)
   - What's their current workaround? (How do they solve it today?)
   - What does this problem cost them? (Time, money, errors)
   - How often do they face this? (Daily, per project, rare?)
   - Example: Not "budgeting is hard" but "predicting multi-location
     shoot costs with labor conflicts takes 8+ hours per production"

   ‚ö†Ô∏è VERIFY: Does this problem apply to ${domainContext.domain_practitioners.join(' or ')}
   in ${domainContext.primary_domain}? If NO, find a different problem.

2. CLAUDE CAPABILITY GAP (SPECIFIC TO ${domainContext.primary_domain.toUpperCase()})
   - What specifically can't Claude do well for ${domainContext.primary_domain}? (Not "general advice")
   - What would Claude need to do this? (Be concrete)
   - Consider the capabilities listed above - don't suggest gaps for capabilities Claude already has
   - Example: "Claude can discuss budgeting but cannot model
     constraint satisfaction with location-specific dependencies"

3. VALUE UNLOCK (MEASURABLE FOR ${domainContext.primary_domain.toUpperCase()} PRACTITIONERS)
   - What would solving this unlock for ${domainContext.domain_practitioners.join(' or ')}? (Measurable outcome)
   - How much time/money would it save? (Be specific)
   - What becomes possible? (New capability)
   - Example: "Generating accurate cost predictions in minutes vs.
     8+ hours, preventing 5-15% budget overruns"

Then suggest 2-3 redesigns where each:
- Targets ONE specific practitioner pain point IN ${domainContext.primary_domain.toUpperCase()}
- States what Claude can't do that's needed FOR ${domainContext.primary_domain.toUpperCase()}
- Shows why it would be HIGH_UTILITY
- Includes measurable outcome FOR ${domainContext.domain_practitioners.join(' or ')}
- Describes specific implementation (what data in ‚Üí what out)

Focus on PROBLEMS in ${domainContext.primary_domain}, not generic technical additions.

‚ùå EXAMPLE OF BAD DOMAIN PIVOTING (DO NOT DO THIS):
  User domain: "web research"
  Bad suggestion: "Investment analyst due diligence problems" ‚Üê WRONG! Different domain!

‚úÖ EXAMPLE OF GOOD DOMAIN-CONSTRAINED APPROACH:
  User domain: "web research"
  Good suggestion: "Cross-reference contradiction detector for journalists" ‚Üê CORRECT! Same domain!

If you cannot find domain-relevant problems that would be solved by a higher-utility
skill in ${domainContext.primary_domain}, explicitly state:
"No high-utility redesign opportunities identified in ${domainContext.primary_domain}.
The original skill concept may not have sufficient problem-solving potential in this domain."

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

CURRENT UTILITY ANALYSIS:
Score: ${utilityAnalysis.utility_score}/10
Category: ${utilityAnalysis.utility_category}
Domain: ${utilityAnalysis.domain}
Power-up: ${utilityAnalysis.power_up_statement}

Return JSON with this exact structure:
{
  "domain_analysis": {
    "user_specified_domain": "${primaryDomainStr}",
    "domain_verified": true,
    "domain_constraints_applied": true,
    "practitioners_analyzed": ${JSON.stringify(domainContext.domain_practitioners)}
  },
  "domain_research": {
    "practitioner_pain_points": [
      {
        "problem": "Specific problem practitioners face IN ${primaryDomainUpperStr}",
        "why_hard": "What makes this challenging",
        "current_workaround": "How they solve it now",
        "cost_of_problem": "Time/money/errors cost",
        "frequency": "How often this occurs",
        "domain_relevance_score": 8-10
      }
    ],
    "claude_capability_gap": "What Claude specifically cannot do well for ${primaryDomainStr}",
    "value_unlock": "What would be unlocked by solving this FOR ${practitionersStr}"
  },
  "redesign_suggestions": [
    {
      "original_skill": "${escapeForJSON(requirements.skill_name)}",
      "redesigned_skill": "new-skill-name with specific capability",
      "problem_it_solves": "Specific practitioner pain point addressed IN ${primaryDomainUpperStr}",
      "claude_power_up": "Specific capability this adds to Claude FOR ${primaryDomainUpperStr}",
      "estimated_utility_score": 7-9,
      "why_higher_utility": "Why this scores higher than original",
      "measurable_outcome": "Concrete, measurable result FOR ${practitionersStr}",
      "specific_implementation": "What data goes in ‚Üí what comes out",
      "domain_relevance_score": 8-10,
      "domain_fit_explanation": "Why this is relevant to ${primaryDomainStr}"
    }
  ]
}

‚ö†Ô∏è FINAL VALIDATION BEFORE RETURNING:
Review ALL suggestions and verify EVERY problem/redesign is exclusively relevant
to ${domainContext.primary_domain} and its practitioners. If ANY suggestion
mentions or targets a different domain, REJECT it and replace with an in-domain
alternative.

Return ONLY the JSON object, no markdown, no other text.`;

      try {
        let response = await callClaude(prompt, 2500, 'utility');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const problemAnalysis = JSON.parse(response);

        // Step 2: Validate domain relevance of all suggestions
        addLog('Validating problem domain relevance...', 'info');
        const validation = await validateDomainRelevance(
          domainContext.primary_domain,
          problemAnalysis,
          domainContext.domain_practitioners
        );

        if (validation.all_relevant) {
          addLog(`‚úì All ${validation.total_suggestions} suggestions verified in-domain`, 'success');
          addLog(`‚úì Domain relevance scores: ${validation.scores.join(', ')}`, 'info');
        } else {
          addLog(`‚ö† ${validation.issues.length} domain pivoting issues detected`, 'warning');
          validation.issues.forEach(issue => {
            addLog(`  - ${issue.suggestion}: ${issue.issue}`, 'warning');
          });
          throw new Error('Domain pivoting detected - suggestions cross into unrelated domains');
        }

        addLog('Problem analysis complete', 'success');
        updateProgress('Problem Analysis', 100, 'Problem-grounded redesigns identified');

        return problemAnalysis;
      } catch (err) {
        addLog('Problem analysis failed - using fallback', 'warning');
        addLog(`Error details: ${err.message}`, 'error');
        console.error('Problem analysis error:', err);
        // Return a basic structure if analysis fails
        return {
          domain_research: {
            practitioner_pain_points: [{
              problem: "Generic workflow inefficiency",
              why_hard: "Manual process",
              current_workaround: "Manual work",
              cost_of_problem: "Time consuming",
              frequency: "Regular"
            }],
            claude_capability_gap: "Needs more specific capabilities",
            value_unlock: "Improved efficiency"
          },
          redesign_suggestions: utilityAnalysis.recommended_redesigns.map(r => ({
            original_skill: requirements.skill_name,
            redesigned_skill: r,
            problem_it_solves: "Addresses domain-specific challenges",
            claude_power_up: "Enhanced capabilities for this domain",
            estimated_utility_score: 7,
            why_higher_utility: "More focused on solving specific problems",
            measurable_outcome: "Improved workflow efficiency",
            specific_implementation: "Framework-based approach"
          }))
        };
      }
    }

    // ========== KNOWLEDGE ENHANCEMENT ENGINE ==========
    // Transforms generic KNOWLEDGE skills into specialized expertise

    async function enhanceKnowledgeSkill(skillConcept, domainContext) {
      console.log('=== ENHANCEMENT API CALL DEBUG ===');
      console.log('Skill Concept:', skillConcept);
      console.log('Domain Context:', domainContext);
      console.log('Timestamp:', new Date().toISOString());

      // Get API key from localStorage
      const apiKey = document.getElementById('apiKey').value.trim();
      console.log('API key present:', apiKey ? 'Yes (length: ' + apiKey.length + ')' : 'No');

      if (!apiKey) {
        console.error('API key missing!');
        return {
          success: false,
          error: 'Please enter your Anthropic API key',
          diagnostics: {
            errorType: 'MissingAPIKey',
            errorMessage: 'No API key found in input field'
          }
        };
      }

      const prompt = `${KNOWLEDGE_ENHANCEMENT_PROMPT}

SKILL CONCEPT: ${skillConcept}
DOMAIN CONTEXT: ${domainContext || 'Not specified - infer from skill name'}

Begin your research and synthesis.`;

      console.log('Prompt length:', prompt.length, 'characters');

      // Use backend proxy structure (matches callClaude function)
      const requestBody = {
        apiKey: apiKey,
        prompt: prompt,
        maxTokens: 4000
      };

      console.log('Request body prepared for /api/claude backend');
      console.log('Backend proxy will use model: claude-haiku-4-5');

      try {
        console.log('Calling backend proxy at /api/claude...');
        const startTime = Date.now();

        const response = await fetch('/api/claude', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        const fetchDuration = Date.now() - startTime;
        console.log(`Backend fetch completed in ${fetchDuration}ms`);
        console.log('Response status:', response.status);
        console.log('Response ok:', response.ok);
        console.log('Response headers:', JSON.stringify([...response.headers.entries()]));

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          const errorText = errorData.error || `API request failed with status ${response.status}`;
          console.error('Backend returned non-OK status:', response.status);
          console.error('Error response:', errorData);
          return {
            success: false,
            error: `API error ${response.status}: ${errorText}`,
            diagnostics: {
              status: response.status,
              duration: fetchDuration,
              errorBody: errorData
            }
          };
        }

        console.log('Parsing JSON response from backend...');
        const data = await response.json();
        console.log('Backend response structure:', Object.keys(data));

        if (!data.text) {
          console.error('Unexpected backend response structure');
          console.error('Expected: data.text');
          console.error('Got:', JSON.stringify(data, null, 2));
          return {
            success: false,
            error: 'Unexpected backend response structure',
            diagnostics: {
              receivedStructure: Object.keys(data),
              fullResponse: data
            }
          };
        }

        const responseText = data.text;
        console.log('Response text length:', responseText.length, 'characters');
        console.log('Response text preview (first 500 chars):', responseText.substring(0, 500));

        // Clean up response (remove markdown code blocks if present)
        console.log('Cleaning response text...');
        let cleanedResponse = responseText.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        console.log('Cleaned response length:', cleanedResponse.length, 'characters');

        console.log('Attempting to parse response as JSON...');
        let enhancement;
        try {
          enhancement = JSON.parse(cleanedResponse);
          console.log('JSON parse successful!');
          console.log('Enhancement structure:', Object.keys(enhancement));
        } catch (parseError) {
          console.error('JSON parse failed!');
          console.error('Parse error:', parseError.message);
          console.error('Cleaned response that failed to parse:', cleanedResponse);
          console.error('Original response:', responseText);
          return {
            success: false,
            error: `JSON parse error: ${parseError.message}`,
            diagnostics: {
              parseError: parseError.message,
              cleanedResponse: cleanedResponse,
              originalResponse: responseText,
              responseLength: responseText.length
            }
          };
        }

        const requiredFields = ['enhanced_concept', 'knowledge_domains', 'key_frameworks', 'expertise_areas', 'value_proposition'];
        const missingFields = requiredFields.filter(field => !enhancement[field]);

        if (missingFields.length > 0) {
          console.error('Enhancement missing required fields:', missingFields);
          console.error('Present fields:', Object.keys(enhancement));
          console.error('Enhancement object:', enhancement);
          return {
            success: false,
            error: `Enhancement missing fields: ${missingFields.join(', ')}`,
            diagnostics: {
              missingFields,
              receivedFields: Object.keys(enhancement),
              enhancement
            }
          };
        }

        console.log('=== ENHANCEMENT SUCCESS ===');
        console.log('Enhanced concept:', enhancement.enhanced_concept);
        console.log('Knowledge domains count:', enhancement.knowledge_domains?.length);
        console.log('Key frameworks count:', enhancement.key_frameworks?.length);
        console.log('Expertise areas count:', enhancement.expertise_areas?.length);
        console.log('Value proposition:', enhancement.value_proposition);

        return {
          success: true,
          enhancedConcept: enhancement.enhanced_concept,
          knowledgeDomains: enhancement.knowledge_domains,
          keyFrameworks: enhancement.key_frameworks,
          expertiseAreas: enhancement.expertise_areas,
          valueProposition: enhancement.value_proposition,
          researchSummary: enhancement.research_summary || 'No summary provided',
          diagnostics: {
            duration: fetchDuration,
            status: response.status
          }
        };

      } catch (error) {
        console.error('=== ENHANCEMENT CATCH BLOCK ===');
        console.error('Error type:', error.constructor.name);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);

        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          console.error('DIAGNOSIS: Network/fetch error - Backend proxy unreachable');
          console.error('Check that /api/claude endpoint is available');
        } else if (error.name === 'SyntaxError') {
          console.error('DIAGNOSIS: JSON parsing error - response is not valid JSON');
        } else if (error.message.includes('timeout')) {
          console.error('DIAGNOSIS: Request timeout - Backend took too long to respond');
        } else if (error.message.includes('API key')) {
          console.error('DIAGNOSIS: API key error - Check that API key is valid');
        } else {
          console.error('DIAGNOSIS: Unknown error type');
        }

        return {
          success: false,
          error: error.message,
          diagnostics: {
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack
          }
        };
      }
    }

    // ========== CONSTRAINT VALIDATION GATE ==========
    // Prevents false power-up claims that contradict skill's own constraints

    function extractYAMLConstraints(text) {
      /**
       * Extract constraints from YAML frontmatter (primary source)
       * Looks for metadata.constraints field in YAML section
       */
      // Add null/undefined check
      if (!text || typeof text !== 'string') {
        return [];
      }

      const constraints = [];

      try {
        // Find YAML frontmatter (between --- delimiters)
        const yamlMatch = text.match(/^---\s*\n([\s\S]*?)\n---/);
        if (!yamlMatch) {
          return constraints; // No YAML frontmatter found
        }

        const yamlText = yamlMatch[1];

        // Simple YAML parsing for constraints field
        // Look for "constraints:" or "  constraints:" (nested in metadata)
        const constraintsMatch = yamlText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
        if (constraintsMatch) {
          // Found top-level constraints
          const constraintStr = constraintsMatch[1].trim();
          // Split by period or newline
          const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
          constraints.push(...splitConstraints.map(c => c.trim()));
        }

        // Also check for nested metadata.constraints
        const metadataSection = yamlText.match(/metadata:\s*\n([\s\S]*?)(?=\n\S|\n---|\n$)/);
        if (metadataSection) {
          const metadataText = metadataSection[1];
          const metadataConstraintsMatch = metadataText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
          if (metadataConstraintsMatch) {
            const constraintStr = metadataConstraintsMatch[1].trim();
            const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
            constraints.push(...splitConstraints.map(c => c.trim()));
          }
        }
      } catch (err) {
        // If YAML parsing fails, return empty and fall back to text extraction
        console.warn('YAML constraint extraction failed:', err);
      }

      return constraints;
    }

    function extractTextConstraints(description) {
      /**
       * Extract constraint statements from text (secondary source)
       * Looks for constraint keywords in description body
       */
      // Add null/undefined check
      if (!description || typeof description !== 'string') {
        return [];
      }

      const constraintKeywords = [
        'Cannot',
        'cannot',
        'Cannot access',
        'Cannot perform',
        'No access to',
        'Does not',
        'Cannot provide',
        'Limited to',
        'Restricted',
        'No real-time',
        'Users must',
        'User must',
        'Requires user to',
        'Not available',
        'Unable to',
        'No live',
        'Not capable'
      ];

      const constraints = [];
      const lines = description.split(/[.!?\n]/);

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Skip YAML frontmatter lines
        if (trimmed === '---') continue;
        if (trimmed.includes(':') && trimmed.split(':')[0].match(/^\s*[a-z_]+$/)) {
          // Likely a YAML field, skip
          continue;
        }

        for (const keyword of constraintKeywords) {
          if (trimmed.includes(keyword)) {
            // Clean up markdown formatting
            let cleaned = trimmed.replace(/^[*\-]\s*/, '').replace(/^\*\*/, '').replace(/\*\*$/, '');
            cleaned = cleaned.trim();
            if (cleaned && cleaned.length > 10) { // Avoid single words
              constraints.push(cleaned);
              break; // Don't add same line multiple times
            }
          }
        }
      }

      return constraints;
    }

    function extractConstraints(description) {
      /**
       * Extract ALL constraints from YAML metadata + description text
       * Returns array of constraint strings
       */
      // Add null/undefined check
      if (!description || typeof description !== 'string') {
        return [];
      }

      const constraints = [];

      // Priority 1: YAML metadata constraints (most reliable)
      const yamlConstraints = extractYAMLConstraints(description);
      constraints.push(...yamlConstraints);

      // Priority 2: Text-based constraints (supplementary)
      const textConstraints = extractTextConstraints(description);

      // Deduplicate - avoid repeating similar constraints
      for (const textConstraint of textConstraints) {
        const textLower = textConstraint.toLowerCase();
        const isDuplicate = constraints.some(existing => {
          const existingLower = existing.toLowerCase();
          // Check for substantial overlap
          return existingLower.includes(textLower) || textLower.includes(existingLower);
        });

        if (!isDuplicate) {
          constraints.push(textConstraint);
        }
      }

      return constraints;
    }

    function extractPowerUpClaims(powerUpStatement) {
      /**
       * Extract specific capability claims from power-up statement
       * Returns array of claimed capabilities
       */
      // Add null/undefined check
      if (!powerUpStatement || typeof powerUpStatement !== 'string') {
        return [];
      }

      const claims = [];
      const statement = powerUpStatement.toLowerCase();

      // Common claim markers
      const markers = [
        'providing',
        'enables',
        'powers up',
        'generates',
        'creates',
        'executes',
        'performs',
        'offers',
        'delivers',
        'gives',
        'adds'
      ];

      // Extract phrases after markers
      for (const marker of markers) {
        const regex = new RegExp(marker + '\\s+([^,;.]+)', 'gi');
        const matches = statement.matchAll(regex);

        for (const match of matches) {
          if (match[1]) {
            claims.push(match[1].trim());
          }
        }
      }

      // Also look for capability keywords directly
      const capabilityKeywords = [
        'web scraping',
        'data extraction',
        'real-time',
        'live data',
        'api calls',
        'database access',
        'authentication',
        'automated',
        'executable',
        'integration'
      ];

      for (const keyword of capabilityKeywords) {
        if (statement.includes(keyword)) {
          claims.push(keyword);
        }
      }

      return [...new Set(claims)]; // Remove duplicates
    }

    function validateConstraints(requirements, utilityAnalysis) {
      /**
       * Main constraint validation function
       * Checks if power-up claims contradict skill's own constraints
       * Returns validation report with revised score if needed
       */
      const description = requirements.description;
      const powerUpStatement = utilityAnalysis.power_up_statement;

      // Step 1: Extract constraints
      const constraints = extractConstraints(description);

      if (constraints.length === 0) {
        // No constraints found, analysis is valid as-is
        return {
          hasConstraints: false,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 2: Extract power-up claims
      const claims = extractPowerUpClaims(powerUpStatement);

      if (claims.length === 0) {
        // No specific claims found, analysis is valid as-is
        return {
          hasConstraints: true,
          constraints: constraints,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 3: Check for contradictions
      const contradictions = [];
      const validClaims = [];

      for (const claim of claims) {
        let isContradicted = false;
        let conflictingConstraint = null;

        for (const constraint of constraints) {
          if (detectContradiction(claim, constraint)) {
            isContradicted = true;
            conflictingConstraint = constraint;
            contradictions.push({
              claim: claim,
              constraint: conflictingConstraint,
              reason: 'Claim contradicts explicit constraint'
            });
            break;
          }
        }

        if (!isContradicted) {
          validClaims.push(claim);
        }
      }

      // Step 4: If no contradictions, return original analysis
      if (contradictions.length === 0) {
        return {
          hasConstraints: true,
          constraints: constraints,
          claimsChecked: claims.length,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 5: Contradictions found - recalculate score
      const validClaimsRatio = validClaims.length / claims.length;
      const originalScore = utilityAnalysis.utility_score;
      const newScore = recalculateUtilityScore(
        originalScore,
        contradictions.length,
        validClaimsRatio
      );

      // Step 6: Rebuild power-up statement
      const revisedPowerUp = validClaims.length > 0
        ? `This skill powers up Claude by: ${validClaims.join(', ')}`
        : '‚ö†Ô∏è No valid power-up statement (claims contradicted by constraints)';

      // Step 7: Update category based on new score
      const revisedCategory = categorizeUtilityScore(newScore);

      // Step 8: Update phase routing based on new score
      const revisedRouting = newScore >= 7 ? 'PROCEED'
        : newScore >= 4 ? 'REDESIGN'
        : 'REJECT';

      // Step 9: Build revised analysis
      const revisedAnalysis = {
        ...utilityAnalysis,
        utility_score: newScore,
        utility_category: revisedCategory,
        power_up_statement: revisedPowerUp,
        phase_routing: revisedRouting,
        reasoning: utilityAnalysis.reasoning +
          `\n\n‚ö†Ô∏è CONSTRAINT VALIDATION ADJUSTMENT: Original score ${originalScore}/10 reduced to ${newScore}/10. ` +
          `${contradictions.length} power-up claim(s) contradicted by skill's own constraints.`
      };

      return {
        hasConstraints: true,
        constraints: constraints,
        claimsChecked: claims.length,
        hasContradictions: true,
        contradictions: contradictions,
        validClaims: validClaims,
        originalScore: originalScore,
        revisedScore: newScore,
        scoreChange: newScore - originalScore,
        validClaimsRatio: validClaimsRatio,
        originalAnalysis: utilityAnalysis,
        revisedAnalysis: revisedAnalysis
      };
    }

    function detectContradiction(claim, constraint) {
      /**
       * Check if a claim contradicts a constraint
       * Returns true if contradiction detected
       *
       * IMPORTANT: Only explicit prohibitions (cannot, no access, etc.) are contradictions.
       * Requirements like "users must provide API key" are NOT contradictions - they indicate
       * the capability exists but needs user input.
       */
      const claimLower = claim.toLowerCase();
      const constraintLower = constraint.toLowerCase();

      // Contradiction patterns - ONLY explicit prohibitions
      const contradictionMap = {
        'web scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'data extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'real-time': ['cannot real-time', 'no real-time', 'cannot access live', 'not real-time', 'no access to'],
        'live data': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'live': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'api calls': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'api': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'authentication': ['cannot authenticate', 'no auth', 'cannot access', 'no access to'],
        'database': ['cannot access', 'no database', 'no access to'],
        'automated': ['cannot automate', 'no automation'],
        'executable': ['cannot execute', 'no execution'],
        'integration': ['cannot integrate', 'no integration', 'no access to']
      };

      // Check if claim matches any contradiction pattern
      for (const [keyword, blockPatterns] of Object.entries(contradictionMap)) {
        if (claimLower.includes(keyword)) {
          for (const pattern of blockPatterns) {
            if (constraintLower.includes(pattern)) {
              return true;
            }
          }
        }
      }

      // Additional word-overlap check - ONLY for explicit prohibitions
      const claimWords = new Set(claimLower.split(/\s+/).filter(w => w.length > 3));
      const constraintWords = constraintLower.split(/\s+/).filter(w => w.length > 3);

      // If constraint says "cannot X" or "no access to X" and claim includes "X", it's a contradiction
      if (constraintLower.includes('cannot') || constraintLower.includes('no access')) {
        for (const word of claimWords) {
          if (constraintWords.includes(word)) {
            return true;
          }
        }
      }

      return false;
    }

    function recalculateUtilityScore(originalScore, contradictionCount, validClaimsRatio) {
      /**
       * Recalculate utility score based on constraint contradictions
       * Each contradiction = -2 points
       * If <50% of claims are valid = -4 additional points
       */
      let penalty = contradictionCount * 2;

      if (validClaimsRatio < 0.5) {
        penalty += 4;
      }

      const newScore = Math.max(0, originalScore - penalty);
      return newScore;
    }

    function categorizeUtilityScore(score) {
      /**
       * Convert numeric score to category
       */
      if (score >= 7) return 'HIGH_UTILITY';
      if (score >= 4) return 'MEDIUM_UTILITY';
      return 'LOW_UTILITY';
    }

    let utilityAnalysisResult = null;
    let currentRequirements = null;
    let problemAnalysisResult = null;

    async function showUtilityResults(analysis, validationResult = null) {
      document.getElementById('utilityCard').classList.remove('hidden');

      // Display category badge and explanation
      const categoryBadgeSection = document.getElementById('categoryBadgeSection');
      const categoryExplanationSection = document.getElementById('categoryExplanationSection');

      if (analysis.skill_category) {
        // Category color and icon mapping
        const categoryConfig = {
          'TEMPLATE': {
            color: '#f8b4ae',
            icon: 'üìÑ',
            label: 'TEMPLATE',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'Code templates'
          },
          'METHODOLOGY': {
            color: '#8ab4f8',
            icon: 'üß†',
            label: 'METHODOLOGY',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Reasoning framework'
          },
          'KNOWLEDGE': {
            color: '#81c995',
            icon: 'üìö',
            label: 'KNOWLEDGE',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Domain expertise'
          },
          'PROCESSOR': {
            color: '#fdd663',
            icon: '‚öôÔ∏è',
            label: 'PROCESSOR',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Analysis logic'
          },
          'REFERENCE_CODEGEN': {
            color: '#c58af9',
            icon: 'üìñ',
            label: 'REFERENCE_CODEGEN',
            powerUp: true,
            capabilityGain: 'high',
            description: 'API reference'
          },
          'EXECUTOR': {
            color: '#f8b4ae',
            icon: 'ü§ñ',
            label: 'EXECUTOR',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'External automation'
          },
          'EXECUTOR_AGENTIC': {
            color: '#81c995',
            icon: 'üü¢',
            label: 'Agentic Skill',
            powerUp: true,
            capabilityGain: 'strong',
            description: 'Runs safely here'
          },
          'EXECUTOR_EXTERNAL': {
            color: '#f8b4ae',
            icon: 'üü†',
            label: 'External Skill',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'Runs elsewhere'
          }
        };

        // Handle executor subtypes
        let categoryKey = analysis.skill_category;
        if (analysis.skill_category === 'EXECUTOR' && analysis.executor_subtype) {
          categoryKey = `EXECUTOR_${analysis.executor_subtype.toUpperCase()}`;
        }

        const config = categoryConfig[categoryKey] || {
          color: '#9aa0a6',
          icon: '‚ùì',
          label: analysis.skill_category,
          powerUp: false,
          capabilityGain: 'unknown',
          description: 'Unknown type'
        };

        // Display category badge with capability gain
        const capabilityGainLabels = {
          'high': { text: 'High Capability Gain', color: '#81c995' },
          'strong': { text: 'Strong Capability Gain', color: '#81c995' },
          'limited': { text: 'Limited Capability Gain', color: '#f8b4ae' },
          'unknown': { text: 'Unknown', color: '#9aa0a6' }
        };
        const gainLabel = capabilityGainLabels[config.capabilityGain] || capabilityGainLabels['unknown'];

        categoryBadgeSection.innerHTML = `
          <div style="background: rgba(${config.powerUp ? '138, 180, 248' : '248, 180, 174'}, 0.1); border: 1px solid ${config.color}; border-radius: 12px; padding: 16px; display: flex; align-items: center; gap: 12px;">
            <div style="font-size: 32px;">${config.icon}</div>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 4px; flex-wrap: wrap;">
                <span style="background: ${config.color}; color: #0a0b0d; border-radius: 6px; padding: 4px 12px; font-size: 12px; font-weight: 700; letter-spacing: 0.5px;">
                  ${config.label}
                </span>
                <span style="color: ${gainLabel.color}; font-weight: 600; font-size: 13px;">
                  ${config.powerUp ? '‚úì' : '‚óã'} ${gainLabel.text}
                </span>
                ${analysis.category_capped ?
                  `<span style="color: #fdd663; font-size: 13px; font-weight: 600;">‚ö†Ô∏è Capped: ${analysis.original_score} ‚Üí ${analysis.utility_score}</span>` : ''}
              </div>
              <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
                ${config.description} ‚Äî ${analysis.category_reasoning}
              </div>
            </div>
          </div>
        `;

        // Display category explanation (human-readable)
        const categoryExplanations = {
          'TEMPLATE': 'Code templates and examples. Claude already knows how to generate these patterns from its training data.',
          'METHODOLOGY': 'Reasoning framework that Claude can apply directly. Expands how Claude thinks about problems.',
          'KNOWLEDGE': 'Domain expertise that Claude can use in its analysis. Adds specialized knowledge Claude needs.',
          'PROCESSOR': 'Analysis logic Claude can execute. Gives Claude new ways to process and understand information.',
          'REFERENCE_CODEGEN': 'API documentation that helps Claude write better code for external tools. Improves code generation quality.',
          'EXECUTOR': 'Automation that runs outside Claude. Helpful for you, but not a new Claude capability.',
          'EXECUTOR_AGENTIC': 'Runs safely inside Claude\'s environment. Adds real executable capability ‚Äî Claude can now process data, run scripts, and transform files directly.',
          'EXECUTOR_EXTERNAL': 'Runs on your system, not in Claude. Still useful (generates code you can run), but doesn\'t expand what Claude itself can do.'
        };

        // Show explanation for non-power-ups OR agentic executors (to explain capability gain)
        if (!analysis.is_real_power_up || (analysis.skill_category === 'EXECUTOR' && analysis.executor_subtype === 'agentic')) {
          categoryExplanationSection.classList.remove('hidden');
          const explanationStyle = analysis.is_real_power_up ?
            'background: rgba(129, 201, 149, 0.08); border-left: 4px solid #81c995;' :
            'background: rgba(248, 180, 174, 0.08); border-left: 4px solid #f8b4ae;';
          const explanationTitle = analysis.is_real_power_up ?
            `<strong style="color: #81c995;">‚úì What This Adds:</strong>` :
            `<strong style="color: #f8b4ae;">‚óã Capability Limitation:</strong>`;

          categoryExplanationSection.innerHTML = `
            <div style="${explanationStyle} border-radius: 8px; padding: 16px;">
              ${explanationTitle}
              <p style="margin: 8px 0 0 0; color: var(--text-secondary); line-height: 1.6;">
                ${categoryExplanations[categoryKey]}
              </p>
            </div>
          `;
        } else {
          categoryExplanationSection.classList.add('hidden');
        }

        // Add contextual "What is Capability Gain?" info card (v2.1)
        if (analysis.skill_category === 'EXECUTOR') {
          const capabilityGainInfo = document.createElement('div');
          capabilityGainInfo.style.cssText = 'background: rgba(138, 180, 248, 0.08); border: 1px solid rgba(138, 180, 248, 0.3); border-radius: 8px; padding: 14px; margin-top: 12px; font-size: 12px; line-height: 1.5;';
          capabilityGainInfo.innerHTML = `
            <strong style="color: #8ab4f8;">üí° What is Capability Gain?</strong>
            <p style="margin: 6px 0 0 0; color: var(--text-secondary);">
              Capability Gain measures what <em>Claude itself</em> can now do, not how helpful the idea is to you.
              Skills that run inside Claude's environment add real execution capability.
              Skills that run on your system are still useful (they help Claude write better code for you),
              but they don't expand Claude's own abilities.
            </p>
          `;
          categoryExplanationSection.parentElement.insertBefore(capabilityGainInfo, categoryExplanationSection.nextSibling);
        }
      }

      // Display constraint validation report if there were contradictions
      const validationContainer = document.getElementById('constraintValidationReport');
      if (validationResult && validationResult.hasContradictions) {
        let validationHTML = `
          <div style="background: rgba(248, 180, 174, 0.08); border: 1px solid rgba(248, 180, 174, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #f8b4ae; margin-bottom: 16px;">üõë CONSTRAINT CONTRADICTIONS DETECTED</h3>

            <div style="margin-bottom: 16px;">
              <div style="display: flex; gap: 20px; margin-bottom: 12px;">
                <div>
                  <strong style="color: var(--text-secondary);">Original Score:</strong>
                  <span style="color: var(--text-primary); font-size: 18px; margin-left: 8px;">${validationResult.originalScore}/10</span>
                </div>
                <div>
                  <strong style="color: var(--text-secondary);">Revised Score:</strong>
                  <span style="color: #f8b4ae; font-size: 18px; margin-left: 8px;">${validationResult.revisedScore}/10</span>
                  <span style="color: #f8b4ae; margin-left: 4px;">‚¨áÔ∏è ${validationResult.scoreChange}</span>
                </div>
              </div>
            </div>

            <div style="margin-bottom: 16px;">
              <strong style="color: var(--text-primary);">Contradicted Claims:</strong>
              <div style="margin-top: 8px;">`;

        validationResult.contradictions.forEach(c => {
          validationHTML += `
                <div style="background: rgba(0, 0, 0, 0.2); border-left: 3px solid #f8b4ae; padding: 12px; margin-bottom: 8px; border-radius: 4px;">
                  <div style="color: var(--text-primary); margin-bottom: 4px;">
                    <span style="color: #f8b4ae;">‚úó</span> "${c.claim}"
                  </div>
                  <div style="color: var(--text-secondary); font-size: 13px; margin-left: 20px;">
                    Conflicts with: "${c.constraint}"
                  </div>
                </div>`;
        });

        validationHTML += `
              </div>
            </div>`;

        if (validationResult.validClaims && validationResult.validClaims.length > 0) {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <strong style="color: var(--text-primary);">Valid Claims Remaining:</strong>
              <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                ${validationResult.validClaims.join(', ')}
              </div>
            </div>`;
        } else {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: #f8b4ae;">
              ‚ö†Ô∏è No valid power-up claims remain after constraint validation
            </div>`;
        }

        validationHTML += `
            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
              <strong>Routing:</strong> ${validationResult.scoreChange <= -3 ? 'Score dropped significantly - REDESIGN RECOMMENDED' : 'Proceeding with revised score'}
            </div>
          </div>
        `;

        if (validationContainer) {
          validationContainer.innerHTML = validationHTML;
          validationContainer.classList.remove('hidden');
        }
      } else if (validationContainer) {
        validationContainer.classList.add('hidden');
      }

      // Update circular progress ring
      updateUtilityScoreRing(analysis.utility_score, 10);

      document.getElementById('powerUpStatement').textContent = analysis.power_up_statement;
      document.getElementById('utilityReasoning').textContent = analysis.reasoning;

      // Populate one-line summary
      const summaryDiv = document.getElementById('utilitySummary');
      if (summaryDiv) {
        // Generate a concise one-line summary based on category
        let summaryText = '';
        if (analysis.skill_category) {
          const categoryName = analysis.skill_category.replace(/_/g, ' ').toLowerCase();
          summaryText = `${analysis.utility_category.replace('_', ' ')} ${categoryName} skill`;
        } else {
          summaryText = `${analysis.utility_category.replace('_', ' ')} skill`;
        }

        // Add domain context if available
        if (analysis.domain) {
          summaryText += ` for ${analysis.domain}`;
        }

        summaryDiv.textContent = summaryText;
        summaryDiv.style.display = 'block';
      }

      // Hide all routing sections first
      document.getElementById('utilityProceedSection').classList.add('hidden');
      document.getElementById('utilityRedesignSection').classList.add('hidden');
      document.getElementById('utilityRejectSection').classList.add('hidden');

      // Show appropriate section based on routing
      if (analysis.phase_routing === 'PROCEED') {
        // Populate the research direction (for when user clicks "Review Details")
        document.getElementById('researchDirection').textContent = analysis.research_direction;

        // Show auto-proceed modal instead of immediate button
        showPhase0AutoProceedModal();
      } else if (analysis.phase_routing === 'REDESIGN' || analysis.phase_routing === 'REJECT') {
        // For MEDIUM and LOW utility, run Problem Identifier Agent
        addLog('Deploying Problem Identifier Agent...', 'info');

        // Show loading state
        const targetSection = analysis.phase_routing === 'REDESIGN' ?
                             'utilityRedesignSection' : 'utilityRejectSection';
        document.getElementById(targetSection).classList.remove('hidden');
        const containerDiv = analysis.phase_routing === 'REDESIGN' ?
                            document.getElementById('redesignOptions') :
                            document.getElementById('rejectAlternatives');
        containerDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Analyzing real problems in this domain...<span class="loading-spinner"></span></p>';

        try {
          // Run problem analysis
          const problemAnalysis = await analyzeProblem(currentRequirements, analysis);
          problemAnalysisResult = problemAnalysis;

          // Display problem-grounded results
          displayProblemAnalysis(problemAnalysis, analysis);
        } catch (err) {
          addLog('Problem analysis encountered an error, showing basic redesigns', 'warning');
          // Fallback to basic redesigns
          displayBasicRedesigns(analysis);
        }
      }

      // Color coding is now handled by the circular progress ring
    }

    function displayProblemAnalysis(problemAnalysis, utilityAnalysis) {
      const isRedesign = utilityAnalysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      const research = problemAnalysis.domain_research;
      const domainAnalysis = problemAnalysis.domain_analysis || {};

      let html = `
        <div style="background: rgba(138, 180, 248, 0.08); border: 1px solid rgba(138, 180, 248, 0.2); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <h3 style="color: var(--accent-primary); margin: 0;">‚ö†Ô∏è Real Problem Identified</h3>
            ${domainAnalysis.user_specified_domain ? `
              <span style="background: rgba(138, 180, 248, 0.15); border: 1px solid rgba(138, 180, 248, 0.4); border-radius: 6px; padding: 4px 10px; font-size: 11px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase; letter-spacing: 0.5px;">
                ${domainAnalysis.user_specified_domain}
              </span>
            ` : ''}
          </div>
      `;

      // Display pain points
      if (research.practitioner_pain_points && research.practitioner_pain_points.length > 0) {
        const painPoint = research.practitioner_pain_points[0];
        html += `
          <div style="margin-bottom: 16px;">
            <strong style="color: var(--text-primary);">Problem:</strong>
            <p style="margin: 8px 0; line-height: 1.6;">${painPoint.problem}</p>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; font-size: 13px;">
            <div>
              <strong style="color: var(--text-secondary);">Current Workaround:</strong>
              <p style="margin: 4px 0;">${painPoint.current_workaround}</p>
            </div>
            <div>
              <strong style="color: var(--text-secondary);">Cost:</strong>
              <p style="margin: 4px 0;">${painPoint.cost_of_problem}</p>
            </div>
          </div>
        `;
      }

      html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <strong style="color: var(--text-primary);">Claude Capability Gap:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--text-secondary);">${research.claude_capability_gap}</p>
          </div>
          <div style="margin-top: 12px;">
            <strong style="color: var(--text-primary);">Value Unlock:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--accent-secondary);">${research.value_unlock}</p>
          </div>
        </div>
      `;

      // Display redesign suggestions
      html += '<h3 style="margin: 24px 0 16px 0;">Problem-Grounded Redesigns</h3>';

      if (problemAnalysis.redesign_suggestions && problemAnalysis.redesign_suggestions.length > 0) {
        problemAnalysis.redesign_suggestions.forEach((suggestion, index) => {
          const scoreColor = suggestion.estimated_utility_score >= 8 ? 'var(--accent-secondary)' : '#fdd663';
          const domainRelevanceScore = suggestion.domain_relevance_score || 'N/A';
          const domainRelevanceColor = domainRelevanceScore >= 8 ? 'var(--accent-secondary)' : domainRelevanceScore >= 7 ? '#fdd663' : '#f8b4ae';

          html += `
            <div class="redesign-card" data-skill-name="${suggestion.redesigned_skill.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}"
                 style="background: rgba(30, 33, 39, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 16px; cursor: pointer; transition: all 0.3s ease;"
                 onmouseover="this.style.borderColor='var(--accent-primary)'; this.style.background='rgba(138, 180, 248, 0.08)';"
                 onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.background='rgba(30, 33, 39, 0.6)';">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px; gap: 8px;">
                <div style="flex: 1;">
                  <h4 style="color: var(--accent-primary); margin: 0 0 8px 0; font-size: 16px;">${suggestion.redesigned_skill}</h4>
                  ${domainAnalysis.user_specified_domain ? `
                    <div style="display: inline-flex; align-items: center; gap: 6px;">
                      <span style="background: rgba(138, 180, 248, 0.12); border: 1px solid rgba(138, 180, 248, 0.3); border-radius: 4px; padding: 2px 8px; font-size: 10px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase;">
                        ${domainAnalysis.user_specified_domain}
                      </span>
                      <span style="color: ${domainRelevanceColor}; font-size: 10px; font-weight: 600;">
                        Domain Fit: ${domainRelevanceScore}/10
                      </span>
                    </div>
                  ` : ''}
                </div>
                <div style="background: ${scoreColor}20; border: 1px solid ${scoreColor}; border-radius: 8px; padding: 4px 12px; font-size: 12px; font-weight: 600; color: ${scoreColor}; white-space: nowrap;">
                  ${suggestion.estimated_utility_score}/10 ‚¨ÜÔ∏è
                </div>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Solves:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.problem_it_solves}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Power-up:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6; color: var(--accent-primary);">${suggestion.claude_power_up}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Outcome:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.measurable_outcome}</p>
              </div>
              ${suggestion.domain_fit_explanation ? `
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Domain Fit:</strong>
                <p style="margin: 4px 0; font-size: 13px; line-height: 1.5; color: var(--accent-primary);">${suggestion.domain_fit_explanation}</p>
              </div>
              ` : ''}
              <div style="background: rgba(10, 11, 13, 0.4); border-radius: 8px; padding: 12px; margin-top: 12px;">
                <strong style="color: var(--text-secondary); font-size: 12px;">Implementation:</strong>
                <p style="margin: 4px 0; font-size: 13px; font-family: 'SF Mono', monospace; line-height: 1.5;">${suggestion.specific_implementation}</p>
              </div>
            </div>
          `;
        });
      }

      containerDiv.innerHTML = html;

      // Add click event listeners to redesign cards
      const redesignCards = containerDiv.querySelectorAll('.redesign-card');
      redesignCards.forEach(card => {
        card.addEventListener('click', function() {
          const skillName = this.getAttribute('data-skill-name');
          selectRedesign(skillName);
        });
      });
    }

    function displayBasicRedesigns(analysis) {
      const isRedesign = analysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      containerDiv.innerHTML = '';

      if (analysis.recommended_redesigns && analysis.recommended_redesigns.length > 0) {
        analysis.recommended_redesigns.forEach((redesign, index) => {
          const btn = document.createElement('button');
          btn.className = 'example-btn';
          btn.textContent = `‚Üí ${redesign}`;
          btn.style.marginBottom = '12px';
          btn.onclick = () => selectRedesign(redesign);
          containerDiv.appendChild(btn);
        });
      }
    }

    function selectRedesign(redesign) {
      // Populate input field with suggested skill
      document.getElementById('skillInput').value = redesign;

      // Trigger new factory analysis instead of resetting
      addLog(`Running analysis for suggested skill: ${redesign}`, 'info');
      startGeneration();
    }

    // ============================================================
    // AUTO-VALIDATION & SELF-REDESIGN LOOP
    // ============================================================

    // Helper: Parse YAML metadata string into flat object for validation
    function parseMetadataYAML(yamlString) {
      const obj = {};
      const lines = yamlString.split('\n');
      let inMetadataSection = false;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) continue;

        if (trimmed === 'metadata:') {
          inMetadataSection = true;
          continue;
        }

        // Parse root-level fields (name, description)
        if (!inMetadataSection) {
          const match = trimmed.match(/^([a-z-]+):\s*"?(.+?)"?$/);
          if (match) {
            const key = match[1];
            let value = match[2];
            // Remove quotes if present
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            obj[key] = value;
          }
        } else {
          // Parse nested metadata fields (version, complexity, etc.)
          const match = trimmed.match(/^([a-z-]+):\s*"?(.+?)"?$/);
          if (match) {
            const key = match[1];
            let value = match[2];
            // Remove quotes if present
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            obj[key] = value;
          }
        }
      }

      return obj;
    }

    // Helper: Convert flat metadata object back to YAML string
    function metadataObjectToYAML(obj) {
      // Separate root-level and metadata fields
      const rootFields = ['name', 'description', 'license', 'allowed-tools'];
      const metadataFields = ['version', 'complexity', 'author', 'constraints', 'tags'];

      const lines = [];

      // Add root-level fields
      if (obj.name) {
        lines.push(`name: ${obj.name}`);
      }
      if (obj.description) {
        const safeDesc = sanitizeForYAML(obj.description);
        lines.push(`description: "${safeDesc}"`);
      }
      if (obj.license) {
        lines.push(`license: ${obj.license}`);
      }
      if (obj['allowed-tools']) {
        lines.push(`allowed-tools: ${obj['allowed-tools']}`);
      }

      // Add metadata section
      const metadataEntries = {};
      for (const field of metadataFields) {
        if (obj[field]) {
          metadataEntries[field] = obj[field];
        }
      }

      if (Object.keys(metadataEntries).length > 0) {
        lines.push('metadata:');
        for (const [key, value] of Object.entries(metadataEntries)) {
          const safeValue = sanitizeForYAML(String(value));
          lines.push(`  ${key}: "${safeValue}"`);
        }
      }

      return lines.join('\n');
    }

    const SKILL_VALIDATION_RULES = {
      power_up_honest: {
        name: 'Power-up Honesty',
        description: 'Power-up claim matches actual capability gap',
        check: checkPowerUpHonesty,
        fixable: true,
        auto_fix: fixPowerUpHonesty
      },

      focused_scope: {
        name: 'Focused Scope',
        description: 'Skill scope is 1-2 topics, not 5+',
        check: checkFocusedScope,
        fixable: true,
        auto_fix: fixFocusedScope
      },

      progressive_disclosure: {
        name: 'Progressive Disclosure',
        description: 'Main SKILL.md under 200 lines, secondary content separated',
        check: checkProgressiveDisclosure,
        fixable: true,
        auto_fix: fixProgressiveDisclosure
      },

      constraint_clarity: {
        name: 'Constraint Clarity',
        description: 'Constraints reframed as responsibility boundaries',
        check: checkConstraintClarity,
        fixable: true,
        auto_fix: fixConstraintClarity
      },

      dependencies_documented: {
        name: 'Dependencies Documented',
        description: 'All version requirements and prerequisites listed',
        check: checkDependenciesDocumented,
        fixable: true,
        auto_fix: fixDependenciesDocumented
      },

      metadata_complete: {
        name: 'Metadata Complete',
        description: 'All metadata fields present and valid',
        check: checkMetadataComplete,
        fixable: true,
        auto_fix: fixMetadataComplete
      }
    };

    // ============================================================
    // CHECK FUNCTIONS
    // ============================================================

    function checkPowerUpHonesty(skillPackage) {
      const { metadata, documentation } = skillPackage;

      // Extract power-up claims from description
      const description = metadata.description || '';
      const lowerDesc = description.toLowerCase();

      // Check for overpromising keywords
      const overPromisePatterns = [
        'executable validation tools',
        'automated testing',
        'real-time',
        'live testing',
        'device testing',
        'interactive testing'
      ];

      // Check for contradictions with limitations
      const hasLimitations = documentation.toLowerCase().includes('limitations') ||
                            documentation.toLowerCase().includes('cannot') ||
                            documentation.toLowerCase().includes('does not');

      const hasOverPromise = overPromisePatterns.some(pattern => lowerDesc.includes(pattern));

      if (hasOverPromise && hasLimitations) {
        return {
          pass: false,
          issue: `Power-up statement may overpromise capabilities. Found claims like "executable validation" but documentation lists limitations.`,
          severity: 'high'
        };
      }

      return { pass: true };
    }

    function checkFocusedScope(skillPackage) {
      const { documentation } = skillPackage;

      // Count distinct major topics by looking for ## headings
      const headings = documentation.match(/^##\s+(.+)$/gm) || [];
      const topics = headings.map(h => h.replace(/^##\s+/, '').trim());

      // Common topic categories to detect
      const topicCategories = {
        colors: ['color', 'palette', 'theme'],
        components: ['component', 'widget', 'control'],
        testing: ['test', 'validation', 'verify'],
        migration: ['migrat', 'upgrad', 'transition'],
        accessibility: ['accessibility', 'a11y', 'voiceover'],
        architecture: ['architect', 'structure', 'pattern'],
        performance: ['performance', 'optimiz', 'efficiency']
      };

      // Identify which categories are present
      const categoriesFound = new Set();
      topics.forEach(topic => {
        const lowerTopic = topic.toLowerCase();
        Object.entries(topicCategories).forEach(([category, keywords]) => {
          if (keywords.some(kw => lowerTopic.includes(kw))) {
            categoriesFound.add(category);
          }
        });
      });

      if (categoriesFound.size > 3) {
        return {
          pass: false,
          issue: `Skill covers too many topics (${categoriesFound.size}): ${Array.from(categoriesFound).join(', ')}. Should focus on 1-2 core topics.`,
          severity: 'high',
          metadata: { topics: Array.from(categoriesFound) }
        };
      }

      return { pass: true };
    }

    function checkProgressiveDisclosure(skillPackage) {
      const { documentation } = skillPackage;

      // Count lines in documentation
      const lines = documentation.split('\n').length;

      if (lines > 200) {
        return {
          pass: false,
          issue: `Documentation is ${lines} lines, exceeds 200 line target. Consider splitting into multiple files.`,
          severity: 'medium',
          metadata: { lineCount: lines }
        };
      }

      return { pass: true };
    }

    function checkConstraintClarity(skillPackage) {
      const { documentation } = skillPackage;

      const lowerDoc = documentation.toLowerCase();

      // Check for negative constraint framing (bad)
      const negativePatterns = [
        'cannot test on actual',
        'cannot access real',
        'unable to',
        'does not support',
        'not possible'
      ];

      // Check for responsibility boundary framing (good)
      const boundaryPatterns = [
        'claude responsibility',
        'user responsibility',
        'you implement',
        'you test',
        'claude generates',
        'claude provides'
      ];

      const hasNegativeFraming = negativePatterns.some(p => lowerDoc.includes(p));
      const hasBoundaryFraming = boundaryPatterns.some(p => lowerDoc.includes(p));

      if (hasNegativeFraming && !hasBoundaryFraming) {
        return {
          pass: false,
          issue: `Constraints use negative framing ("cannot", "unable") instead of clear responsibility boundaries.`,
          severity: 'medium'
        };
      }

      return { pass: true };
    }

    function checkDependenciesDocumented(skillPackage) {
      const { documentation, requirements } = skillPackage;

      const lowerDoc = documentation.toLowerCase();

      // Check if skill mentions versions/requirements
      const hasVersionRequirements = lowerDoc.includes('requires') ||
                                     lowerDoc.includes('prerequisite') ||
                                     lowerDoc.includes('## requirements') ||
                                     lowerDoc.includes('## dependencies');

      // If language-specific, should document version requirements
      const language = requirements.programming_language;
      if (language && language.toLowerCase() !== 'general') {
        if (!hasVersionRequirements) {
          return {
            pass: false,
            issue: `Language-specific skill (${language}) should document version requirements and prerequisites.`,
            severity: 'low'
          };
        }
      }

      return { pass: true };
    }

    function checkMetadataComplete(skillPackage) {
      const { metadata } = skillPackage;

      const requiredFields = ['name', 'description', 'version', 'complexity'];
      const missingFields = requiredFields.filter(field => !metadata[field]);

      if (missingFields.length > 0) {
        return {
          pass: false,
          issue: `Missing required metadata fields: ${missingFields.join(', ')}`,
          severity: 'high',
          metadata: { missingFields }
        };
      }

      // Check if constraints are documented in metadata
      if (!metadata.constraints) {
        return {
          pass: false,
          issue: `Metadata should include 'constraints' field documenting limitations.`,
          severity: 'medium'
        };
      }

      return { pass: true };
    }

    // ============================================================
    // AUTO-FIX FUNCTIONS
    // ============================================================

    async function fixPowerUpHonesty(skillPackage) {
      addLog('Auto-fixing: Rewriting power-up statement to match actual capabilities...', 'info');

      const { metadata, documentation, requirements } = skillPackage;

      // Use Claude to rewrite the description to be more honest
      const prompt = `You are fixing a skill's power-up statement to be honest about capabilities.

CURRENT DESCRIPTION: "${metadata.description}"

SKILL DOCUMENTATION EXCERPT:
${documentation.substring(0, 500)}

CONSTRAINTS FROM VALIDATION:
- Claude cannot execute validation tools or test on actual devices
- Claude CAN provide: templates, patterns, frameworks, analysis, recommendations
- Claude CANNOT provide: real-time testing, device testing, executable validation

Rewrite the description to accurately reflect what Claude provides (knowledge, patterns, templates) without promising execution capabilities.

Return ONLY the rewritten description (max 200 chars), nothing else.`;

      try {
        const newDescription = await callClaude(prompt, 300, 'autofix');
        metadata.description = newDescription.trim().replace(/^["']|["']$/g, '');
        addLog(`‚úì Power-up rewritten: "${metadata.description}"`, 'success');
      } catch (err) {
        addLog(`‚ö†Ô∏è Auto-fix failed, using fallback`, 'warning');
        // Fallback: Generic safe description
        metadata.description = `${requirements.skill_name} implementation patterns and best practices for ${requirements.programming_language || 'development'}`;
      }

      return skillPackage;
    }

    async function fixFocusedScope(skillPackage) {
      addLog('Auto-fixing: Skill scope too broad, adding focus note...', 'warning');

      // Note: Auto-splitting into separate skills is complex and requires user decision
      // For now, we'll add a note to the documentation to help users navigate

      // Add a note about scope
      const note = `> **Scope Note:** This skill covers multiple topics. Focus on the sections most relevant to your current task.\n\n`;
      skillPackage.documentation = note + skillPackage.documentation;

      addLog('‚úì Added scope navigation note to documentation', 'success');
      return skillPackage;
    }

    async function fixProgressiveDisclosure(skillPackage) {
      addLog('Auto-fixing: Documentation too long, extracting sections...', 'info');

      const lineCount = skillPackage.documentation.split('\n').length;

      // If under limit, nothing to fix
      if (lineCount <= 200) {
        return skillPackage;
      }

      // Use the autoExtractToReferences function
      const result = await autoExtractToReferences(
        skillPackage.documentation,
        skillPackage.requirements?.skill_name || 'skill'
      );

      if (result.modified) {
        skillPackage.documentation = result.documentation;

        // Store references for packaging later
        if (!skillPackage.references) {
          skillPackage.references = {};
        }
        Object.assign(skillPackage.references, result.references);

        // Generate FULL_PROMPT_EXPORT
        let fullExport = result.documentation;
        for (const [filename, content] of Object.entries(result.references)) {
          fullExport += `\n\n---\n\n${content}`;
        }
        skillPackage.fullPromptExport = fullExport;

        addLog(`‚úì Extracted sections, reduced to ${result.lineCount} lines`, 'success');
        return skillPackage;
      }

      // If extraction didn't help enough, add navigation note as fallback
      if (!skillPackage.documentation.includes('**Progressive Disclosure:**')) {
        const note = `> **Progressive Disclosure:** This documentation is comprehensive. Use Ctrl+F to find specific sections.\n\n`;
        skillPackage.documentation = note + skillPackage.documentation;
        addLog('‚úì Added navigation note (extraction insufficient)', 'info');
      }

      return skillPackage;
    }

    async function fixConstraintClarity(skillPackage) {
      addLog('Auto-fixing: Reframing constraints as responsibility boundaries...', 'info');

      const { documentation } = skillPackage;

      // Use Claude to reframe constraints
      const prompt = `You are reframing constraints in a skill's documentation to be clearer about responsibility boundaries.

CURRENT DOCUMENTATION (first 800 chars):
${documentation.substring(0, 800)}

Find any negative constraint language like "cannot", "unable to", "does not support" and reframe them as:

**Responsibility Boundaries:**
- **Claude provides:** [what Claude does - patterns, templates, analysis]
- **You implement:** [what user does - testing, deployment, integration]
- **Claude is halted by:** [technical limitations stated positively]

Return ONLY the "Responsibility Boundaries" section (markdown format), nothing else.`;

      try {
        const boundariesSection = await callClaude(prompt, 400, 'autofix');

        // Find limitations section and replace or add boundaries section
        if (documentation.includes('## Limitations')) {
          skillPackage.documentation = documentation.replace(
            /## Limitations[\s\S]*?(?=##|$)/,
            `## Limitations\n\n${boundariesSection}\n\n`
          );
        } else {
          // Add before examples section or at end
          const insertPoint = documentation.indexOf('## Examples');
          if (insertPoint > -1) {
            skillPackage.documentation = documentation.substring(0, insertPoint) +
              `## Limitations\n\n${boundariesSection}\n\n` +
              documentation.substring(insertPoint);
          } else {
            skillPackage.documentation = documentation + `\n\n## Limitations\n\n${boundariesSection}\n`;
          }
        }

        addLog('‚úì Constraints reframed as responsibility boundaries', 'success');
      } catch (err) {
        addLog('‚ö†Ô∏è Auto-fix failed, using fallback', 'warning');
        // Fallback: Add generic boundaries
        const fallback = `\n\n## Responsibility Boundaries\n\n**Claude provides:** Implementation patterns, code templates, and best practices guidance.\n\n**You implement:** Integration with your project, testing, and deployment.\n`;
        skillPackage.documentation += fallback;
      }

      return skillPackage;
    }

    async function fixDependenciesDocumented(skillPackage) {
      addLog('Auto-fixing: Adding dependencies section...', 'info');

      const { requirements } = skillPackage;

      // Create a requirements section
      const reqSection = `\n\n## Requirements\n\n`;

      if (requirements.programming_language && requirements.programming_language !== 'general') {
        const lang = requirements.programming_language;
        skillPackage.documentation = reqSection +
          `- **Language:** ${lang}\n` +
          `- **Version:** Latest stable release recommended\n` +
          (requirements.required_apis ? `- **APIs/Libraries:** ${requirements.required_apis.join(', ')}\n` : '') +
          `\n` +
          skillPackage.documentation;
      } else {
        skillPackage.documentation = reqSection +
          `- **Environment:** General development environment\n` +
          (requirements.required_apis ? `- **Tools:** ${requirements.required_apis.join(', ')}\n` : '') +
          `\n` +
          skillPackage.documentation;
      }

      addLog('‚úì Dependencies section added', 'success');
      return skillPackage;
    }

    async function fixMetadataComplete(skillPackage) {
      addLog('Auto-fixing: Completing metadata fields...', 'info');

      const { metadata } = skillPackage;

      // Fill in missing required fields
      if (!metadata.version) {
        metadata.version = '1.0.0';
      }

      if (!metadata.complexity) {
        // Infer from documentation length
        const docLength = skillPackage.documentation.length;
        metadata.complexity = docLength > 3000 ? 'complex' : docLength > 1500 ? 'moderate' : 'simple';
      }

      if (!metadata.author) {
        metadata.author = 'Skill Factory';
      }

      if (!metadata.constraints) {
        // Extract from documentation or use default
        const docLower = skillPackage.documentation.toLowerCase();
        if (docLower.includes('limitations') || docLower.includes('cannot')) {
          metadata.constraints = 'See Limitations section in documentation';
        } else {
          metadata.constraints = 'Claude provides patterns and templates. User implements and tests.';
        }
      }

      addLog('‚úì Metadata completed', 'success');
      return skillPackage;
    }

    // ============================================================
    // SAFETY ASSESSMENT (v2.1)
    // ============================================================

    function assessSkillSafety(skillPackage) {
      /**
       * Assesses safety of executor skills for agentic execution
       * Returns safety level and any warnings/adjustments needed
       */
      const assessment = {
        level: 'safe',
        utilityAdjustment: 0,
        warnings: []
      };

      // Only assess EXECUTOR skills with agentic subtype
      if (skillPackage.category !== 'EXECUTOR' || skillPackage.executor_subtype !== 'agentic') {
        return assessment;
      }

      const codeContent = JSON.stringify(skillPackage.scripts || skillPackage.content || '');

      // Check for unsafe patterns
      const unsafePatterns = [
        { pattern: /rm\s+-rf\s+\/(?!tmp|var\/tmp)/gi, desc: 'Dangerous file deletion outside safe directories' },
        { pattern: /sudo\s+/gi, desc: 'Privileged operations not allowed in sandbox' },
        { pattern: /eval\s*\(/gi, desc: 'Code injection risk with eval()' },
        { pattern: /exec\s*\(/gi, desc: 'Arbitrary code execution risk' },
        { pattern: /connect.*production/gi, desc: 'Production system access not allowed' },
        { pattern: /--force|--no-verify/gi, desc: 'Bypass safety checks' }
      ];

      for (const { pattern, desc } of unsafePatterns) {
        if (pattern.test(codeContent)) {
          assessment.level = 'unsafe';
          assessment.utilityAdjustment = -10; // Force rejection
          assessment.warnings.push(`‚ö†Ô∏è UNSAFE: ${desc}`);
        }
      }

      // Check for semi-safe patterns (need extra caution)
      if (assessment.level === 'safe') {
        const semiSafePatterns = [
          { pattern: /api[_\s]*key/gi, desc: 'API key handling - ensure proper secrets management' },
          { pattern: /password|credential/gi, desc: 'Credential management - ensure secure handling' },
          { pattern: /DELETE\s+FROM|DROP\s+TABLE/gi, desc: 'Data deletion operations' },
          { pattern: /\$\(.*\)/g, desc: 'Shell command substitution - verify input sanitization' }
        ];

        for (const { pattern, desc } of semiSafePatterns) {
          if (pattern.test(codeContent)) {
            assessment.level = 'semi-safe';
            assessment.warnings.push(`‚ö†Ô∏è CAUTION: ${desc}`);
          }
        }
      }

      // Bonus for verified safe sandbox operations
      if (assessment.level === 'safe') {
        const safeIndicators = [
          /ffmpeg\s+-i/gi,
          /python3?\s+/gi,
          /imagemagick|convert\s+/gi,
          /jq\s+/gi,
          /awk|sed/gi
        ];

        const hasSafeOps = safeIndicators.some(pattern => pattern.test(codeContent));
        if (hasSafeOps) {
          assessment.utilityAdjustment = 1; // Small bonus for verified safe operations
        }
      }

      return assessment;
    }

    // ============================================================
    // VALIDATION LOOP ORCHESTRATION
    // ============================================================

    async function validateSkillPackage(skillPackage) {
      const results = {
        allPass: true,
        failures: [],
        passes: [],
        safetyAssessment: null
      };

      // Run safety assessment for executor skills (v2.1)
      if (skillPackage.category === 'EXECUTOR') {
        const safety = assessSkillSafety(skillPackage);
        results.safetyAssessment = safety;

        if (safety.level === 'unsafe') {
          results.allPass = false;
          results.failures.push({
            rule: 'safety_assessment',
            name: 'Safety Assessment',
            issue: `Unsafe patterns detected: ${safety.warnings.join(', ')}`,
            severity: 'high',
            fixable: false
          });
        } else if (safety.level === 'semi-safe') {
          addLog(`‚ö†Ô∏è Safety warnings: ${safety.warnings.join(', ')}`, 'warning');
        }
      }

      for (const [ruleKey, rule] of Object.entries(SKILL_VALIDATION_RULES)) {
        const result = rule.check(skillPackage);

        if (result.pass) {
          results.passes.push({
            rule: ruleKey,
            name: rule.name
          });
        } else {
          results.allPass = false;
          results.failures.push({
            rule: ruleKey,
            name: rule.name,
            issue: result.issue,
            severity: result.severity,
            fixable: rule.fixable,
            auto_fix: rule.auto_fix,
            metadata: result.metadata
          });
        }
      }

      return results;
    }

    async function generateWithAutoValidation(requirements, research) {
      addLog('Starting generation with auto-validation loop...', 'info');

      // Extract research components (research now includes findings and resources)
      const researchFindings = typeof research === 'string' ? research : research.findings;
      const resourceData = research.resourceData || null;

      // Initial generation (returns YAML string)
      let metadataYAML = await generateMetadata(requirements, researchFindings);
      let documentation = await generateDocumentation(requirements, researchFindings, metadataYAML, resourceData);

      // Parse YAML metadata into object for validation
      let metadataObj = parseMetadataYAML(metadataYAML);
      let skillPackage = { metadata: metadataObj, documentation, requirements };

      // Validation loop
      const maxAttempts = 3;
      let attempt = 0;

      while (attempt < maxAttempts) {
        attempt++;
        addLog(`Validation attempt ${attempt}/${maxAttempts}...`, 'info');

        const validation = await validateSkillPackage(skillPackage);

        // Log passed checks
        if (validation.passes.length > 0) {
          addLog(`‚úì Passed: ${validation.passes.map(p => p.name).join(', ')}`, 'success');
        }

        if (validation.allPass) {
          addLog('üéâ All validation checks passed! Skill is production-ready.', 'success');

          // Convert metadata object back to YAML string for packaging
          skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

          return {
            status: 'production_ready',
            skillPackage,
            attempt
          };
        }

        // Log failures
        addLog(`Found ${validation.failures.length} issue(s) to fix:`, 'warning');
        validation.failures.forEach(failure => {
          addLog(`  ‚úó ${failure.name}: ${failure.issue}`, 'warning');
        });

        // Try to auto-fix
        let fixedAny = false;
        for (const failure of validation.failures) {
          if (failure.fixable && failure.auto_fix) {
            try {
              skillPackage = await failure.auto_fix(skillPackage);
              fixedAny = true;
            } catch (err) {
              addLog(`‚ö†Ô∏è Auto-fix failed for ${failure.name}: ${err.message}`, 'error');
            }
          } else {
            addLog(`‚ö†Ô∏è Cannot auto-fix: ${failure.name}`, 'warning');
          }
        }

        if (!fixedAny) {
          addLog('No fixes could be applied. Proceeding with current version.', 'warning');

          // Convert metadata object back to YAML string for packaging
          skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

          return {
            status: 'partially_validated',
            skillPackage,
            attempt,
            remainingIssues: validation.failures
          };
        }
      }

      // Max attempts reached
      addLog(`‚ö†Ô∏è Reached maximum validation attempts (${maxAttempts}). Proceeding with best version.`, 'warning');

      // Convert metadata object back to YAML string for packaging
      skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

      return {
        status: 'max_attempts_reached',
        skillPackage,
        attempt: maxAttempts
      };
    }

    // ============================================================
    // END AUTO-VALIDATION & SELF-REDESIGN LOOP
    // ============================================================

    // ============================================================
    // IDEATION MODE - GENERATE 3 SKILL VARIANTS
    // ============================================================

    async function generateIdeationVariants(requirements, research) {
      addLog('Generating 3 skill variants in ideation mode...', 'info');

      const researchFindings = typeof research === 'string' ? research : research.findings;
      const researchSummary = researchFindings.split('\n').slice(0, 10).join('\n'); // Use first 10 lines for context

      const prompt = `You are an expert skill designer. Based on the following objective and research, generate 3 DIFFERENT approaches to building a Claude skill.

OBJECTIVE:
${requirements.description || requirements.skill_name}

RESEARCH CONTEXT:
${researchSummary}

Generate 3 distinct skill variants that take different approaches to solving this problem. For each variant provide:

1. **name**: A clear, hyphenated skill name (e.g., "api-client-builder")
2. **purpose**: One sentence describing what this variant does
3. **approach**: What makes this variant unique compared to the others
4. **category**: One of: METHODOLOGY, KNOWLEDGE, PROCESSOR, REFERENCE_CODEGEN, EXECUTOR_AGENTIC, EXECUTOR_EXTERNAL
5. **example_prompts**: 2 concrete examples of prompts that would use this skill
6. **eval_task**: 1 specific task to validate the skill works

IMPORTANT: Make each variant genuinely different in approach:
- Variant 1: Could focus on a template-based approach
- Variant 2: Could focus on a framework/methodology approach
- Variant 3: Could focus on a knowledge/reference approach

Return ONLY valid JSON in this exact format:
{
  "variants": [
    {
      "name": "skill-name-1",
      "purpose": "One sentence purpose",
      "approach": "What makes this unique",
      "category": "CATEGORY_NAME",
      "example_prompts": ["Example prompt 1", "Example prompt 2"],
      "eval_task": "Specific validation task"
    },
    {
      "name": "skill-name-2",
      "purpose": "One sentence purpose",
      "approach": "What makes this unique",
      "category": "CATEGORY_NAME",
      "example_prompts": ["Example prompt 1", "Example prompt 2"],
      "eval_task": "Specific validation task"
    },
    {
      "name": "skill-name-3",
      "purpose": "One sentence purpose",
      "approach": "What makes this unique",
      "category": "CATEGORY_NAME",
      "example_prompts": ["Example prompt 1", "Example prompt 2"],
      "eval_task": "Specific validation task"
    }
  ]
}`;

      try {
        const response = await callClaude(prompt, 4000, 'ideation');

        // Extract JSON from response
        let jsonText = response.trim();

        // Remove markdown code blocks if present
        if (jsonText.includes('```')) {
          const jsonMatch = jsonText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
          if (jsonMatch) {
            jsonText = jsonMatch[1];
          }
        }

        const result = JSON.parse(jsonText);

        if (!result.variants || result.variants.length !== 3) {
          throw new Error('Expected exactly 3 variants in response');
        }

        addLog(`‚úì Generated ${result.variants.length} skill variants`, 'success');
        return result;

      } catch (error) {
        addLog(`Error generating ideation variants: ${error.message}`, 'error');
        throw error;
      }
    }

    function displayIdeationVariants(variantsData) {
      const container = document.getElementById('ideationVariantsContainer');
      container.innerHTML = '';

      variantsData.variants.forEach((variant, index) => {
        const card = document.createElement('div');
        card.className = 'variant-card';
        card.innerHTML = `
          <h3>${index + 1}. ${variant.name}</h3>
          <p class="variant-purpose">${variant.purpose}</p>

          <div class="variant-section">
            <h4>Approach</h4>
            <p style="color: var(--text-secondary); font-size: 13px; line-height: 1.6;">${variant.approach}</p>
          </div>

          <div class="variant-section">
            <h4>Category</h4>
            <p style="color: var(--text-primary); font-size: 13px; font-weight: 600;">${variant.category}</p>
          </div>

          <div class="variant-section">
            <h4>Example Prompts</h4>
            ${variant.example_prompts.map(prompt =>
              `<div class="variant-example">"${prompt}"</div>`
            ).join('')}
          </div>

          <div class="variant-section">
            <h4>Validation Task</h4>
            <p style="color: var(--text-secondary); font-size: 13px; line-height: 1.6;">${variant.eval_task}</p>
          </div>

          <button class="select-variant-btn" onclick="selectVariantForGeneration(${index})">
            Select & Generate Full Skill ‚Üí
          </button>
        `;
        container.appendChild(card);
      });

      // Show ideation results section
      document.getElementById('ideationResultsSection').classList.remove('hidden');
      document.getElementById('progressSection').classList.add('hidden');
    }

    async function selectVariantForGeneration(variantIndex) {
      const variant = ideationVariants.variants[variantIndex];

      addLog(`Selected variant: ${variant.name}`, 'success');
      addLog('Switching to full skill generation...', 'info');

      // Hide ideation results and show progress
      document.getElementById('ideationResultsSection').classList.add('hidden');
      document.getElementById('progressSection').classList.remove('hidden');

      // Update requirements with selected variant
      currentRequirements.skill_name = variant.name;
      currentRequirements.description = variant.purpose;
      currentRequirements.skill_category = variant.category;

      // Continue with normal generation flow from research phase
      setStep(3); // Research step

      // Get research (may have been cached from ideation)
      let research;
      if (currentRequirements._cachedResearch) {
        research = currentRequirements._cachedResearch;
        addLog('Using cached research from ideation phase', 'info');
      } else {
        updateProgress('Research', 50, 'Conducting focused research...');
        research = await conductResearch(currentRequirements);
      }

      // Phase 4: Generate with Auto-Validation
      setStep(4);
      updateProgress('Generate', 65, 'Generating skill with quality checks...');
      const generationResult = await generateWithAutoValidation(currentRequirements, research);

      // Phase 5: Final Validate (quality scoring)
      setStep(5);
      updateProgress('Validate', 80, 'Validating skill quality...');
      const validation = await validateSkill(generationResult.skillPackage);

      // Phase 6: Package
      setStep(6);
      updateProgress('Package', 90, 'Creating skill package...');
      const skillName = currentRequirements.skill_name;
      const skillPackage = await packageSkill(
        generationResult.skillPackage,
        skillName,
        research.resourceData,
        generationResult.skillPackage.metadata
      );

      // Phase 7: Testing evaluation
      setStep(7);
      updateProgress('Testing', 95, 'Evaluating testing recommendations...');

      // Complete
      setStep(8);
      updateProgress('Complete', 100, 'Skill generation complete!');

      generatedSkillData = {
        package: skillPackage,
        metadata: generationResult.skillPackage.metadata,
        validation: validation,
        requirements: currentRequirements
      };

      displayResults(validation.score);
      isGenerating = false;
    }

    // ============================================================
    // END IDEATION MODE
    // ============================================================

    // ============================================================
    // AUTO-PROCEED INLINE COUNTDOWN
    // ============================================================

    let phase0CountdownInterval = null;

    function showPhase0AutoProceedModal() {
      // Get utility analysis results for display
      const category = currentRequirements?.category?.primary || 'Unknown';
      const utilityScore = utilityAnalysisResult?.score || 0;
      const estimatedValue = utilityScore >= 7 ? 'High' : utilityScore >= 4 ? 'Medium' : 'Low';
      const powerUp = currentRequirements?.enhanced_requirements?.power_up || 'Advanced skill capabilities';

      // Show the utility proceed section (existing UI) with countdown
      const proceedSection = document.getElementById('utilityProceedSection');
      proceedSection.innerHTML = `
        <div class="phase-complete">
          <h3>‚úÖ Phase 0 Complete</h3>

          <p><strong>Category:</strong> ${category}</p>
          <p><strong>Utility Score:</strong> ${utilityScore}/10</p>
          <p><strong>Estimated Value:</strong> ${estimatedValue}</p>
          <p><strong>Power-up:</strong> ${powerUp}</p>

          <button id="continueBtn" onclick="skipCountdown()">
            Continue to Research (<span id="countdown">10</span>s)
          </button>

          <div class="countdown-bar">
            <div id="countdownProgress" style="width: 100%"></div>
          </div>

          <a href="#" onclick="showFullAnalysis(); return false;">View Full Analysis</a>
        </div>
      `;

      proceedSection.classList.remove('hidden');

      // Scroll to the section smoothly
      document.getElementById('utilityCard').scrollIntoView({ behavior: 'smooth', block: 'nearest' });

      // Start 10-second countdown
      startResearchCountdown();
    }

    function startResearchCountdown() {
      let seconds = 10;
      const countdownElement = document.getElementById('countdown');
      const progressBar = document.getElementById('countdownProgress');

      phase0CountdownInterval = setInterval(() => {
        seconds--;

        // Update countdown text
        if (countdownElement) {
          countdownElement.textContent = seconds;
        }

        // Update progress bar (width decreases as time runs out)
        if (progressBar) {
          progressBar.style.width = `${(seconds / 10) * 100}%`;
        }

        // Auto-proceed when countdown finishes
        if (seconds === 0) {
          clearInterval(phase0CountdownInterval);
          phase0CountdownInterval = null;
          continueToResearch();
        }
      }, 1000);
    }

    function skipCountdown() {
      // Clear countdown
      if (phase0CountdownInterval) {
        clearInterval(phase0CountdownInterval);
        phase0CountdownInterval = null;
      }

      // Proceed immediately
      continueToResearch();
    }

    function showFullAnalysis() {
      // Clear countdown
      if (phase0CountdownInterval) {
        clearInterval(phase0CountdownInterval);
        phase0CountdownInterval = null;
      }

      // Expand all collapsible sections in the utility card
      const collapsibleSections = document.querySelectorAll('#utilityCard .collapsible-section');
      collapsibleSections.forEach(section => {
        section.classList.remove('collapsed');
      });

      // Scroll to the utility card
      document.getElementById('utilityCard').scrollIntoView({ behavior: 'smooth', block: 'start' });

      addLog('Review the full Phase 0 analysis above. Click "Continue to Research" when ready.', 'info');
    }

    // Legacy function name for compatibility
    function proceedToResearchNow() {
      skipCountdown();
    }

    function reviewPhase0Details() {
      showFullAnalysis();
    }

    // ============================================================
    // END AUTO-PROCEED INLINE COUNTDOWN
    // ============================================================

    async function continueToResearch() {
      if (!currentRequirements || !utilityAnalysisResult) {
        addLog('Missing requirements or utility analysis', 'error');
        return;
      }

      if (isGenerating) {
        addLog('Generation already in progress', 'warning');
        return;
      }

      try {
        isGenerating = true;
        document.getElementById('utilityCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');

        // ========== IDEATION MODE BRANCH ==========
        if (generationMode === 'ideation') {
          addLog(`üé® Ideation Mode Active - Research: ${researchMode}`, 'info');

          setStep(3); // Research phase
          updateProgress('Research', 40, `Conducting ${researchMode} research...`);

          // Conduct research once (shared by all variants)
          const research = await conductResearch(currentRequirements);

          // Cache research for later use
          currentRequirements._cachedResearch = research;

          // Generate 3 ideation variants
          updateProgress('Ideation', 70, 'Generating 3 skill variants...');
          ideationVariants = await generateIdeationVariants(currentRequirements, research);

          // Display the variants
          displayIdeationVariants(ideationVariants);

          // Generation stops here - user will select a variant
          isGenerating = false;
          return;
        }
        // ========== END IDEATION MODE BRANCH ==========

        setStep(3); // Research phase (now step 3 instead of 2)
        const research = await conductResearch(currentRequirements);

        setStep(4); // Generate phase with auto-validation loop (now step 4 instead of 3)
        const result = await generateWithAutoValidation(currentRequirements, research);

        // Log auto-validation result
        if (result.status === 'production_ready') {
          addLog(`‚úì Auto-validation succeeded in ${result.attempt} attempt(s)`, 'success');
        } else if (result.status === 'partially_validated') {
          addLog(`‚ö†Ô∏è Partial validation after ${result.attempt} attempt(s). ${result.remainingIssues.length} issue(s) remain.`, 'warning');
        } else {
          addLog(`‚ö†Ô∏è Max validation attempts reached. Proceeding with best version.`, 'warning');
        }

        const skillPackage = result.skillPackage;

        setStep(5); // Final validation phase (now step 5 instead of 4)
        const validation = await validateGeneration(skillPackage);

        if (validation.issues.length > 0) {
          throw new Error(`Validation failed: ${validation.issues.join(', ')}`);
        }

        setStep(6); // Package phase (now step 6 instead of 5)
        const resourceData = research.resourceData || null;
        const pkg = await packageSkill(skillPackage, currentRequirements.skill_name, resourceData);

        setStep(7); // Testing phase (step 7, displays as "8")
        // NEW: Stage 7 - Test the skill with Claude
        addLog('Starting skill testing phase...', 'info');
        const testResults = await stage7_testSkill(skillPackage, currentRequirements);

        // NEW: Stage 8 - Iterate if needed based on test results
        const iterationResult = await stage8_iterateIfNeeded(
          skillPackage,
          testResults,
          currentRequirements,
          0
        );

        // Use the final skill from iteration result (may be refined)
        const finalSkill = iterationResult.finalSkill || skillPackage;
        const finalTestResults = iterationResult.testResults || testResults;

        // Build comprehensive metadata
        const skillMetadata = {
          skill_name: currentRequirements.skill_name,
          description: currentRequirements.description,
          created: new Date().toISOString(),
          viability_score: currentRequirements.viability_check?.viability_score || 0,
          test_pass_rate: finalTestResults.passRate,
          tests_passed: finalTestResults.passedTests,
          tests_total: finalTestResults.totalTests,
          iterations: iterationResult.iterations || 0,
          status: iterationResult.status,
          research_sources: research.domainKnowledge ?
            Object.values(research.domainKnowledge)
              .flatMap(r => r.sources || [])
              .filter(s => s && s !== 'web-research') : [],
          resources: {
            scripts: resourceData ? Object.keys(resourceData.resources.scripts) : [],
            references: resourceData ? Object.keys(resourceData.resources.references) : [],
            assets: resourceData ? Object.keys(resourceData.resources.assets) : []
          }
        };

        // Re-package with final skill and metadata
        const finalPkg = await packageSkill(
          finalSkill,
          currentRequirements.skill_name,
          resourceData,
          skillMetadata
        );

        // Pre-format the prompt for clipboard (to avoid async operations during copy)
        const skillContent = `---\n${finalSkill.metadata}\n---\n\n${finalSkill.documentation}`;
        const promptForClipboard = `You are now equipped with the following skill:

---
${skillContent}
---

When the user asks questions or requests tasks related to the topics covered in this skill, use the knowledge and guidelines from this skill to assist them.`;

        // Store test results in package
        generatedSkillData = {
          package: finalPkg.content,
          filename: finalPkg.filename,
          tree: finalPkg.tree,
          validation,
          testResults: finalTestResults,
          iterationResult: iterationResult,
          metadata: skillMetadata,
          promptForClipboard: promptForClipboard
        };

        // Add to skill registry
        addToSkillRegistry(skillMetadata);

        // Update validation with test results
        validation.testPassRate = `${(finalTestResults.passRate * 100).toFixed(0)}%`;
        validation.testsPassed = `${finalTestResults.passedTests}/${finalTestResults.totalTests}`;
        validation.iterations = iterationResult.iterations || 0;

        setStep(8); // Review phase (step 8, displays as "9") - all stages complete
        showResults(validation, finalPkg.tree, finalPkg.filename);
        addLog('üéâ Skill generation complete!', 'success');

        if (finalTestResults.passRate < 0.8) {
          addLog(`‚ö†Ô∏è Note: Skill passed ${finalTestResults.passedTests}/${finalTestResults.totalTests} tests. Consider refining.`, 'warning');
        } else {
          addLog(`‚úì Quality validated: ${finalTestResults.passedTests}/${finalTestResults.totalTests} tests passed`, 'success');
        }

        if (iterationResult.iterations > 0) {
          addLog(`üîÑ Completed ${iterationResult.iterations} iteration(s) to improve quality`, 'info');
        }

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
      }
    }

    function proceedAnyway() {
      addLog('Proceeding with MEDIUM_UTILITY skill...', 'warning');
      continueToResearch();
    }

    async function conductResearch(requirements) {
      addLog('Starting research pipeline...', 'info');

      // Check adaptive research mode
      const inputsComplete = checkInputCompleteness(requirements).complete;
      const researchScope = ADAPTIVE_RESEARCH_CONFIG.getResearchScope(inputsComplete);
      const effectiveMode = ADAPTIVE_RESEARCH_CONFIG.getEffectiveMode(inputsComplete);

      addLog(`Research mode: ${effectiveMode} (scope: ${researchScope})`, 'info');

      updateProgress('Research', 10, 'Researching domain knowledge...', 'research');

      let domainKnowledge = null;
      let resourceData = null;

      // Adaptive research based on configuration
      if (researchScope === 'frameworks_only') {
        addLog('Using framework-only mode (no external research)', 'info');
        domainKnowledge = {
          frameworks: 'Built-in Claude frameworks and capabilities',
          sources: []
        };
        resourceData = {
          examples: [],
          resources: { scripts: {}, references: {}, assets: {} }
        };
      } else if (researchScope === 'patterns_only') {
        addLog('Using adaptive mode (patterns-only research)', 'info');
        // Lightweight research - just patterns, no deep dive
        domainKnowledge = await researchDomain(requirements);
        resourceData = {
          examples: [],
          resources: { scripts: {}, references: {}, assets: {} }
        };
      } else {
        // Full research mode
        addLog('Using full research mode', 'info');
        domainKnowledge = await researchDomain(requirements);

        updateProgress('Research', 30, 'Gathering resources and examples...');

        // NEW: Stage 3 - Resource Gathering (replaces knowledge enhancement)
        resourceData = await stage3_gatherResourcesAndExamples(requirements, domainKnowledge);
      }

      updateProgress('Research', 60, 'Synthesizing research...');

      // Check if we have knowledge enhancement results
      const hasEnhancement = utilityAnalysisResult && utilityAnalysisResult.knowledge_enhancement;

      // NEW: Incorporate resource gathering results
      const examplesText = resourceData.examples.map(ex =>
        `- ${ex.title}: ${ex.scenario}`
      ).join('\n');

      const resourceSummary = `
GATHERED RESOURCES:
- Examples: ${resourceData.examples.length}
- Scripts: ${Object.keys(resourceData.resources.scripts).length}
- References: ${Object.keys(resourceData.resources.references).length}
- Assets: ${Object.keys(resourceData.resources.assets).length}

REAL-WORLD EXAMPLES FOUND:
${examplesText || 'None'}
`;

      let prompt;
      if (hasEnhancement) {
        const enhancement = utilityAnalysisResult.knowledge_enhancement;
        prompt = `Research for creating an ENHANCED KNOWLEDGE Claude Code Skill:

ORIGINAL CONCEPT: ${requirements.original_skill_name || requirements.skill_name}
ENHANCED CONCEPT: ${requirements.skill_name}

KNOWLEDGE ENHANCEMENT RESULTS:
- Enhanced Concept: ${enhancement.enhancedConcept}
- Value Proposition: ${enhancement.valueProposition}
- Research Summary: ${enhancement.researchSummary}

KNOWLEDGE DOMAINS TO COVER:
${enhancement.knowledgeDomains.map(d => `- ${d}`).join('\n')}

KEY FRAMEWORKS TO INCLUDE:
${enhancement.keyFrameworks.map(f => `- ${f}`).join('\n')}

EXPERTISE AREAS TO DOCUMENT:
${enhancement.expertiseAreas.map(e => `- ${e}`).join('\n')}

${resourceSummary}

REQUIREMENTS: ${JSON.stringify(requirements, null, 2)}

Provide focused research for implementing this KNOWLEDGE skill (max 1500 tokens):
1. How to structure the knowledge domains as reusable frameworks
2. How to incorporate the gathered real-world examples
3. Specific methodologies and techniques to include
4. Best practices for documenting expert-level insights
5. How to reference the gathered resources (scripts/references/assets)

Focus on crystallizing the expertise identified in the enhancement research.`;
      } else {
        prompt = `Research for creating a Claude Code Skill:

REQUIREMENTS: ${JSON.stringify(requirements, null, 2)}

${resourceSummary}

Provide a focused research summary (max 1000 tokens):
1. How to leverage the gathered examples and resources
2. Key technical details and APIs
3. Best practices and patterns
4. Common challenges and solutions
5. Recommended implementation approach

Be specific and actionable. Reference the gathered resources where appropriate.`;
      }

      try {
        const findings = await callClaude(prompt, hasEnhancement ? 2000 : 1500, 'research');
        addLog('Research complete', 'success');
        updateProgress('Research', 100, 'Research synthesis complete');

        // Return comprehensive research package including resources
        return {
          findings: findings,
          resourceData: resourceData,
          domainKnowledge: domainKnowledge
        };
      } catch (err) {
        addLog('Research failed - using template generation', 'warning');
        return {
          findings: 'Limited research available - generating from templates',
          resourceData: resourceData,
          domainKnowledge: domainKnowledge
        };
      }
    }

    function sanitizeForYAML(text) {
      // Escape backslashes and double quotes for safe YAML inclusion
      return text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function generateSafeYAML(name, description, metadata = null) {
      const lines = [];

      // Name (validated, safe without quotes if lowercase-hyphenated)
      lines.push(`name: ${name}`);

      // Description (ALWAYS quote to handle special characters)
      const safeDesc = sanitizeForYAML(description);
      lines.push(`description: "${safeDesc}"`);

      // Metadata (if provided)
      if (metadata && Object.keys(metadata).length > 0) {
        lines.push('metadata:');
        for (const [key, value] of Object.entries(metadata)) {
          // Always quote values to prevent type coercion
          const safeValue = sanitizeForYAML(String(value));
          lines.push(`  ${key}: "${safeValue}"`);
        }
      }

      return lines.join('\n');
    }

    async function generateMetadata(requirements, research) {
      addLog('Generating skill metadata...', 'info');
      updateProgress('Generate', 20, 'Creating YAML metadata...', 'metadata');

      const prompt = `You are generating YAML frontmatter for a Claude Code Skill.

REQUIREMENTS: ${JSON.stringify(requirements)}
RESEARCH: ${research.substring(0, 500)}

CRITICAL YAML RULES:
1. ONLY these keys allowed at root: name, description, license, allowed-tools, metadata
2. Put version, author, tags INSIDE metadata (not at root)
3. Description must include BOTH what it does AND when to use it
4. Return ONLY valid JSON with these exact fields (no YAML, no markdown):

REALITY CONSTRAINTS - NEVER promise these capabilities:
- Real-time data access (prices, inventory, weather) without API key requirement
- Authenticated API calls on user's behalf
- Direct database operations
- Live integrations with external services
- Async/background processing or task queues

WHAT CLAUDE CAN DO:
- Create frameworks, templates, and decision trees
- Generate code examples and architectural patterns
- Analyze and synthesize information
- Provide recommendations based on training data
- Structure workflows and processes

{
  "name": "lowercase-hyphenated-name",
  "description": "What Claude actually does (not aspirational). When to use it (realistic triggers). Mention constraints if external tools needed.",
  "metadata": {
    "version": "1.0.0",
    "complexity": "simple",
    "author": "Skill Factory",
    "constraints": "List any limitations like 'Cannot access real-time data' or 'Requires user to provide API key'"
  }
}

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1000, 'generation');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);

        // Validate name format
        if (!/^[a-z0-9-]+$/.test(parsed.name)) {
          throw new Error('Invalid name format - must be lowercase with hyphens only');
        }
        if (parsed.name.length > 64) {
          throw new Error('Name exceeds 64 character limit');
        }
        if (parsed.description.length > 1024) {
          throw new Error('Description exceeds 1024 character limit');
        }

        // Generate safe YAML using our sanitization function
        const yaml = generateSafeYAML(parsed.name, parsed.description, parsed.metadata);

        addLog('Metadata generated and validated', 'success');
        return yaml;
      } catch (err) {
        addLog(`Metadata generation failed: ${err.message}`, 'error');
        throw new Error(`Metadata generation failed: ${err.message}`);
      }
    }

    async function generateDocumentation(requirements, research, metadata, resourceData) {
      addLog('Generating documentation...', 'info');
      updateProgress('Generate', 50, 'Writing SKILL.md...', 'generation');

      // Build resource information section if available
      let resourceInfo = '';
      if (resourceData) {
        const scripts = Object.keys(resourceData.resources.scripts);
        const references = Object.keys(resourceData.resources.references);
        const assets = Object.keys(resourceData.resources.assets);

        if (scripts.length > 0 || references.length > 0 || assets.length > 0) {
          resourceInfo = `

AVAILABLE RESOURCES (to reference in documentation):
${scripts.length > 0 ? `- Scripts: ${scripts.join(', ')}` : ''}
${references.length > 0 ? `- References: ${references.join(', ')}` : ''}
${assets.length > 0 ? `- Assets: ${assets.join(', ')}` : ''}

REAL-WORLD EXAMPLES TO INCORPORATE:
${resourceData.examples.map(ex => `- ${ex.title}: ${ex.scenario}`).join('\n')}
`;
        }
      }

      const prompt = `Write skill documentation (WITHOUT YAML frontmatter).

REQUIREMENTS: ${JSON.stringify(requirements)}
METADATA: ${metadata}
RESEARCH: ${research}${resourceInfo}

${GENERATION_GUIDELINES.toPromptFormat()}

DOCUMENTATION STRUCTURE:
# Overview
Brief description (2-3 sentences) of what this skill does

# When to Use
Realistic trigger conditions and keywords (3-5 bullet points)

# Key Features
- Feature 1 (what Claude provides)
- Feature 2 (realistic capabilities)
- Feature 3 (if applicable)

# Usage Examples
1-2 concrete examples with code (MAXIMUM 50 lines each)

# Limitations (if directly relevant to THIS skill)
Only mention constraints that matter for THIS specific skill

# Best Practices
3-5 practical tips for using this skill effectively

BE CONCISE. Focus on practical usage, not exhaustive documentation.`;

      try {
        const docs = await callClaude(prompt, 4000, 'generation');
        addLog('Documentation generated', 'success');
        updateProgress('Generate', 100, 'Generation complete');
        return docs;
      } catch (err) {
        throw new Error(`Documentation generation failed: ${err.message}`);
      }
    }

    async function validateGeneration(skillPackage) {
      addLog('Running validation...', 'info');
      updateProgress('Validate', 30, 'Validating metadata...');

      const validation = {
        yamlValid: false,
        qualityScore: 0,
        issues: [],
        warnings: []
      };

      const hasName = skillPackage.metadata.includes('name:');
      const hasDesc = skillPackage.metadata.includes('description:');

      if (hasName && hasDesc) {
        validation.yamlValid = true;
        addLog('YAML validation passed', 'success');
      } else {
        validation.issues.push('Missing required YAML fields');
        addLog('YAML validation failed', 'error');
      }

      // Length validation - check for context inflation
      updateProgress('Validate', 40, 'Checking length limits...');
      const docLines = skillPackage.documentation.split('\n');
      const lineCount = docLines.length;

      if (lineCount > GENERATION_GUIDELINES.length_limits.main_skill_md) {
        validation.warnings.push(`Documentation exceeds ${GENERATION_GUIDELINES.length_limits.main_skill_md} lines (${lineCount} lines)`);
        addLog(`‚ö†Ô∏è Documentation is ${lineCount} lines (target: ${GENERATION_GUIDELINES.length_limits.main_skill_md} lines)`, 'warning');
      } else {
        addLog(`‚úì Documentation length OK (${lineCount}/${GENERATION_GUIDELINES.length_limits.main_skill_md} lines)`, 'success');
      }

      // Check for overly verbose constraints section
      const constraintsMatch = skillPackage.documentation.match(/##?\s*Limitations[\s\S]*?(?=##|$)/);
      if (constraintsMatch) {
        const constraintsLines = constraintsMatch[0].split('\n').length;
        if (constraintsLines > GENERATION_GUIDELINES.length_limits.constraints_section) {
          validation.warnings.push(`Constraints section too verbose (${constraintsLines} lines, max ${GENERATION_GUIDELINES.length_limits.constraints_section})`);
          addLog(`‚ö†Ô∏è Constraints section is verbose (${constraintsLines} lines)`, 'warning');
        }
      }

      // Constraint validation - check for overselling
      updateProgress('Validate', 60, 'Checking constraint compliance...');
      const fullContent = skillPackage.metadata + '\n' + skillPackage.documentation;
      const redFlags = [
        { pattern: /real-?time (data|price|inventory|api|integration)/i, issue: 'Promises real-time data without mentioning constraints' },
        { pattern: /integrates? with|connects? to|fetches? from/i, issue: 'Suggests direct external integrations' },
        { pattern: /database|sql|query|mongodb|postgres/i, issue: 'Implies database access' },
        { pattern: /async|background (process|task|job)|queue/i, issue: 'Suggests async/background processing' },
        { pattern: /authenticate|login|oauth|token refresh/i, issue: 'Implies authentication handling for user' }
      ];

      for (const flag of redFlags) {
        if (flag.pattern.test(fullContent)) {
          // Check if constraints are mentioned nearby
          const constraintMentioned = /constraint|limitation|cannot|requires user|defer|hand off/i.test(fullContent);
          if (!constraintMentioned) {
            validation.warnings.push(flag.issue);
            addLog(`Warning: ${flag.issue}`, 'warning');
          }
        }
      }

      // Quality scoring
      let score = 0;
      if (validation.yamlValid) score += 30;
      if (skillPackage.documentation.length > 500) score += 20;
      if (validation.issues.length === 0) score += 20;
      if (validation.warnings.length === 0) score += 20; // Bonus for no overselling
      if (skillPackage.metadata.includes('constraints:')) score += 10; // Bonus for explicit constraints

      validation.qualityScore = score;

      if (validation.warnings.length > 0) {
        addLog(`Found ${validation.warnings.length} potential overselling warnings`, 'warning');
      }

      addLog(`Quality score: ${score}/100`, score >= 70 ? 'success' : 'warning');
      updateProgress('Validate', 100, 'Validation complete');

      return validation;
    }

    async function packageSkill(skillPackage, skillName, resourceData, skillMetadata = null) {
      addLog('Creating skill package...', 'info');
      updateProgress('Package', 30, 'Initializing ZIP...');

      const zip = new JSZip();
      const sanitized = sanitizeFileName(skillName);
      const skillFolder = zip.folder(sanitized);

      const skillMd = `---\n${skillPackage.metadata}\n---\n\n${skillPackage.documentation}`;
      skillFolder.file('SKILL.md', skillMd);
      addLog('Added SKILL.md', 'success');

      // Add metadata tracking file if provided
      if (skillMetadata) {
        const metadataJson = JSON.stringify(skillMetadata, null, 2);
        skillFolder.file('metadata.json', metadataJson);
        addLog('Added metadata.json', 'success');
      }

      // Add references from auto-extraction (if any)
      if (skillPackage.references && Object.keys(skillPackage.references).length > 0) {
        for (const [filepath, content] of Object.entries(skillPackage.references)) {
          // filepath is like "references/section-name.md"
          skillFolder.file(filepath, content);
          addLog(`Added extracted reference: ${filepath}`, 'success');
        }
      }

      // Add FULL_PROMPT_EXPORT if generated
      if (skillPackage.fullPromptExport) {
        skillFolder.file('FULL_PROMPT_EXPORT.txt', skillPackage.fullPromptExport);
        addLog('Added FULL_PROMPT_EXPORT.txt', 'success');
      }

      // Add resources if available
      if (resourceData) {
        // Add scripts
        if (resourceData.resources.scripts && Object.keys(resourceData.resources.scripts).length > 0) {
          const scriptsFolder = skillFolder.folder('scripts');
          for (const [filename, content] of Object.entries(resourceData.resources.scripts)) {
            scriptsFolder.file(filename, content);
            addLog(`Added script: ${filename}`, 'success');
          }
        }

        // Add references from research
        if (resourceData.resources.references && Object.keys(resourceData.resources.references).length > 0) {
          const referencesFolder = skillFolder.folder('references');
          for (const [filename, data] of Object.entries(resourceData.resources.references)) {
            const content = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            referencesFolder.file(filename, content);
            addLog(`Added reference: ${filename}`, 'success');
          }
        }

        // Add assets
        if (resourceData.resources.assets && Object.keys(resourceData.resources.assets).length > 0) {
          const assetsFolder = skillFolder.folder('assets');
          for (const [filename, content] of Object.entries(resourceData.resources.assets)) {
            assetsFolder.file(filename, content);
            addLog(`Added asset: ${filename}`, 'success');
          }
        }
      }

      updateProgress('Package', 60, 'Adding README...');

      const readme = `# ${skillName}

This is a Claude Code Skill package.

## Installation

1. Extract this ZIP file
2. Place the \`${sanitized}\` folder in your Claude Code skills directory:
   - Personal skills: ~/.claude/skills/
   - Project skills: .claude/skills/
3. The skill will be automatically available

## Contents

- \`SKILL.md\` - Main skill documentation (core overview, quick reference)${skillPackage.fullPromptExport ? '\n- \`FULL_PROMPT_EXPORT.txt\` - Complete documentation in single file (for mobile/web use)' : ''}${skillMetadata ? '\n- \`metadata.json\` - Generation metadata (sources, test results, iterations)' : ''}${skillPackage.references && Object.keys(skillPackage.references).length > 0 ? '\n- \`references/\` - Detailed frameworks and examples' : ''}${resourceData && Object.keys(resourceData.resources.scripts || {}).length > 0 ? '\n- \`scripts/\` - Helper scripts for deterministic operations' : ''}${resourceData && Object.keys(resourceData.resources.references || {}).length > 0 ? '\n- \`references/\` - Reference documentation and examples' : ''}${resourceData && Object.keys(resourceData.resources.assets || {}).length > 0 ? '\n- \`assets/\` - Templates and assets' : ''}

## Usage

### In Claude Code
This skill will be automatically loaded by Claude Code when relevant.

### In Web/Mobile Claude
Use \`FULL_PROMPT_EXPORT.txt\` to copy the complete skill into any Claude conversation.
`;
      skillFolder.file('README.md', readme);
      addLog('Added README.md', 'success');

      updateProgress('Package', 80, 'Compressing...');

      const content = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });

      updateProgress('Package', 100, 'Package ready!');
      addLog('Package created successfully', 'success');

      // Build tree structure including resources
      const treeChildren = [
        { name: 'SKILL.md', type: 'file', size: skillMd.length },
        { name: 'README.md', type: 'file', size: readme.length }
      ];

      // Add metadata.json to tree if present
      if (skillMetadata) {
        treeChildren.push({
          name: 'metadata.json',
          type: 'file',
          size: JSON.stringify(skillMetadata).length
        });
      }

      if (resourceData) {
        if (resourceData.resources.scripts && Object.keys(resourceData.resources.scripts).length > 0) {
          treeChildren.push({
            name: 'scripts',
            type: 'folder',
            children: Object.keys(resourceData.resources.scripts).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }

        if (resourceData.resources.references && Object.keys(resourceData.resources.references).length > 0) {
          treeChildren.push({
            name: 'references',
            type: 'folder',
            children: Object.keys(resourceData.resources.references).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }

        if (resourceData.resources.assets && Object.keys(resourceData.resources.assets).length > 0) {
          treeChildren.push({
            name: 'assets',
            type: 'folder',
            children: Object.keys(resourceData.resources.assets).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }
      }

      const tree = {
        name: sanitized,
        type: 'folder',
        children: treeChildren
      };

      return { content, filename: `${sanitized}.zip`, tree };
    }

    // ============================================
    // WEB RESEARCH UTILITIES
    // For gathering real-world knowledge
    // ============================================

    /**
     * Enhanced research with detailed task descriptions and agent coordination
     * Based on Anthropic's Multi-Agent Research Engineering best practices
     */
    async function performWebResearch(queries) {
      addLog('Performing enhanced multi-agent web research...', 'info');

      const results = {};

      // Limit to top 2 queries to avoid excessive API calls
      const topQueries = queries.slice(0, 2);

      for (const query of topQueries) {
        addLog(`Researching: ${query}`, 'info');

        try {
          // Enhanced prompt with detailed task description, output format, and boundaries
          const prompt = `Search the web and provide research for: "${query}"

**Objective**: Find 5-7 high-quality sources on this topic

**Output Format** (return ONLY valid JSON, no markdown):
{
  "sources": [
    {"url": "...", "type": "official_doc|github|stackoverflow|blog", "authority_score": 1-10, "key_info": "brief summary"},
    ...
  ],
  "findings": "3-5 sentence synthesis of key insights",
  "key_points": ["point 1", "point 2", "point 3"],
  "verified": true
}

**Sources Priority** (search in this order):
1. Official documentation (docs.*.com, official GitHub repos)
2. GitHub repositories (1000+ stars, updated 2023-2025, with working code examples)
3. Stack Overflow answers (50+ votes, posted 2023+, with accepted answers)
4. Authoritative technical blogs (engineering.*.com, official company blogs)

**Task Boundary**:
- Focus ONLY on: practical implementation details, working code patterns, official APIs
- Exclude: tutorials without code, outdated content (pre-2023), unverified sources
- Stop after: finding 5-7 quality sources OR after 5 search attempts

**Quality Criteria**:
- Official docs: Authority score 9-10
- Popular GitHub (1000+ stars): Authority score 7-9
- Verified Stack Overflow: Authority score 6-8
- Quality blogs: Authority score 5-7

**Example good sources**:
- https://docs.anthropic.com/api-reference
- https://github.com/anthropics/anthropic-sdk-python (5000+ stars)
- https://stackoverflow.com/questions/12345678 (100+ votes, accepted answer)

Focus on sources that provide actionable implementation guidance.`;

          const response = await callClaude(prompt, 800, 'research');

          try {
            const cleaned = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
            const parsed = JSON.parse(cleaned);
            results[query] = parsed;
            addLog(`‚úì Research complete: ${query}`, 'success');
          } catch (parseErr) {
            // If JSON parsing fails, create a structured response from the text
            addLog(`Research returned text format for: ${query}`, 'info');
            results[query] = {
              findings: response.substring(0, 500),
              sources: ['web-research'],
              key_points: ['See findings'],
              verified: true
            };
          }
        } catch (err) {
          addLog(`Research failed for "${query}": ${err.message}`, 'warning');
          results[query] = {
            findings: `Unable to research: ${query}`,
            sources: [],
            key_points: [],
            verified: false,
            error: err.message
          };
        }
      }

      return results;
    }

    /**
     * Extract searchable concepts from skill name and description
     * Prevents literal skill name searches like "codebase-dependency-analyzer official docs"
     * Instead extracts real-world tools, techniques, and concepts to research
     */
    async function extractSearchConcepts(skillName, skillDescription) {
      addLog('Extracting searchable concepts from skill requirements...', 'info');

      const prompt = `Analyze this skill and extract REAL-WORLD searchable concepts.

Skill Name: ${skillName}
Description: ${skillDescription}

CRITICAL: DO NOT use the skill name as a search term!
The skill name is what we're BUILDING, not an existing product.

Your task: Identify EXISTING tools, techniques, and concepts that already exist and can be researched.

Return ONLY valid JSON (no markdown):
{
  "problem_domain": "general problem this solves (e.g., 'dependency analysis', 'API caching')",
  "existing_tools": ["real tools that exist (e.g., 'pipdeptree', 'madge', 'redis')"],
  "techniques": ["technical approaches (e.g., 'AST parsing', 'static analysis')"],
  "file_types": ["relevant file formats (e.g., 'package.json', 'requirements.txt')"],
  "programming_languages": ["languages involved (e.g., 'python', 'javascript')"],
  "related_concepts": ["broader topics (e.g., 'circular dependencies', 'cache invalidation')"]
}

EXAMPLES:

Input: "codebase-dependency-analyzer", "Analyze codebase structure and identify dependencies"
Output: {
  "problem_domain": "dependency analysis",
  "existing_tools": ["dependency-cruiser", "madge", "pipdeptree", "npm ls"],
  "techniques": ["static code analysis", "AST parsing", "build system parsing"],
  "file_types": ["package.json", "requirements.txt", "pom.xml"],
  "programming_languages": ["python", "javascript", "java"],
  "related_concepts": ["circular dependencies", "dependency graphs", "build tools"]
}

Input: "api-response-cache", "Cache API responses for improved performance"
Output: {
  "problem_domain": "API response caching",
  "existing_tools": ["redis", "memcached", "varnish"],
  "techniques": ["HTTP cache headers", "cache invalidation", "TTL strategies"],
  "file_types": ["cache configuration", "API specs"],
  "programming_languages": ["python", "node.js"],
  "related_concepts": ["cache invalidation", "cache-aside pattern", "CDN caching"]
}

Focus on what EXISTS in the real world that we can learn from.`;

      try {
        const response = await callClaude(prompt, 500, 'extraction');
        const cleaned = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const concepts = JSON.parse(cleaned);

        addLog(`‚úì Extracted concepts: ${concepts.problem_domain}`, 'success');
        addLog(`  Tools to research: ${concepts.existing_tools.slice(0, 3).join(', ')}`, 'info');

        return concepts;
      } catch (err) {
        addLog(`‚ö†Ô∏è Concept extraction failed, falling back to generic search: ${err.message}`, 'warning');

        // Fallback: use generic terms
        return {
          problem_domain: skillDescription.split(' ').slice(0, 3).join(' '),
          existing_tools: [],
          techniques: ["implementation patterns", "best practices"],
          file_types: [],
          programming_languages: ["python", "javascript"],
          related_concepts: []
        };
      }
    }

    /**
     * Enhanced domain research with division of labor and progressive refinement
     * Implements specialized research agents with distinct focuses
     * NOW WITH PARALLEL EXECUTION for 3x speed improvement
     * FIXED: Uses extracted concepts instead of literal skill names
     */
    async function researchDomain(requirements) {
      addLog('Initializing specialized research agents...', 'info');

      // NEW: Extract searchable concepts before creating research queries
      const concepts = await extractSearchConcepts(requirements.skill_name, requirements.description);

      // Phase 1: Division of Labor - Create specialized research agents
      // Build queries from extracted concepts (not literal skill name!)
      // EXAMPLE: For "codebase-dependency-analyzer":
      //   - primaryTool = "dependency-cruiser"
      //   - primaryTechnique = "static code analysis"
      //   - primaryLanguage = "python"
      //   - problem_domain = "dependency analysis"
      // This generates: "dependency-cruiser dependency analysis official documentation"
      // Instead of: "codebase-dependency-analyzer official documentation" (non-existent product!)
      const primaryTool = concepts.existing_tools[0] || concepts.problem_domain;
      const primaryTechnique = concepts.techniques[0] || 'implementation';
      const primaryLanguage = concepts.programming_languages[0] || 'python';

      const researchAgents = [
        {
          name: "docs_agent",
          focus: "Official documentation only",
          query: `${primaryTool} ${concepts.problem_domain} official documentation API reference`,
          keywords: ["official", "docs", "API", "reference", "documentation"],
          must_find: ["API reference", "official documentation", "getting started guide"],
          expected_sources: 2,
          type: "official_doc"
        },
        {
          name: "examples_agent",
          focus: "Working code examples from GitHub",
          query: `${concepts.problem_domain} ${primaryLanguage} github examples implementation`,
          keywords: ["github", "example", "implementation", "code", "1000+ stars"],
          must_find: ["working code", "example repository", "implementation"],
          expected_sources: 3,
          type: "github"
        },
        {
          name: "practices_agent",
          focus: "Best practices and common patterns",
          query: `${concepts.problem_domain} ${primaryTechnique} best practices patterns`,
          keywords: ["best practices", "patterns", "common issues", "pitfalls"],
          must_find: ["best practices", "design patterns", "troubleshooting"],
          expected_sources: 2,
          type: "stackoverflow"
        }
      ];

      // Log agent initialization
      researchAgents.forEach(agent => {
        addLog(`${agent.name}: ${agent.focus}`, 'info');
      });

      // PARALLEL EXECUTION: Run all agents simultaneously (3x speed improvement!)
      addLog('‚ö° Running 3 research agents in parallel...', 'info');

      const agentPromises = researchAgents.map(async agent => {
        try {
          const agentResults = await performWebResearch([agent.query]);

          // Return result with agent context
          return {
            query: agent.query,
            result: {
              ...agentResults[agent.query],
              agent_name: agent.name,
              agent_focus: agent.focus,
              expected_types: agent.type
            }
          };
        } catch (err) {
          addLog(`‚ö†Ô∏è ${agent.name} failed: ${err.message}`, 'warning');
          // Return error result
          return {
            query: agent.query,
            result: {
              findings: `Agent ${agent.name} failed`,
              sources: [],
              key_points: [],
              verified: false,
              error: err.message,
              agent_name: agent.name,
              agent_focus: agent.focus,
              expected_types: agent.type
            }
          };
        }
      });

      // Wait for all agents to complete
      const agentResults = await Promise.all(agentPromises);

      // Build knowledge base from parallel results
      const knowledgeBase = {};
      agentResults.forEach(({ query, result }) => {
        knowledgeBase[query] = result;
      });

      addLog(`‚úì Parallel research complete: ${agentResults.length} agents finished`, 'success');

      // Phase 2: Progressive Refinement - Check for gaps and search again
      addLog('Analyzing research gaps...', 'info');

      const allSources = Object.values(knowledgeBase)
        .flatMap(result => result.sources || []);

      const hasOfficialDocs = allSources.some(s =>
        s.type === 'official_doc' || s.url?.includes('docs.')
      );
      const hasGithub = allSources.some(s =>
        s.type === 'github' || s.url?.includes('github.com')
      );
      const hasBestPractices = allSources.some(s =>
        s.type === 'stackoverflow' || s.key_info?.toLowerCase().includes('best practice')
      );

      // Fill gaps with targeted refinement searches
      const refinementQueries = [];

      if (!hasOfficialDocs) {
        refinementQueries.push(`${primaryTool} official documentation getting started guide`);
        addLog('Gap detected: Missing official documentation - refining search', 'warning');
      }
      if (!hasGithub) {
        refinementQueries.push(`${concepts.problem_domain} ${primaryLanguage} github popular examples`);
        addLog('Gap detected: Missing GitHub examples - refining search', 'warning');
      }
      if (!hasBestPractices) {
        refinementQueries.push(`${concepts.problem_domain} production best practices common pitfalls`);
        addLog('Gap detected: Missing best practices - refining search', 'warning');
      }

      // Execute refinement searches if needed
      if (refinementQueries.length > 0) {
        addLog(`Running ${refinementQueries.length} refinement searches...`, 'info');
        const refinedResults = await performWebResearch(refinementQueries);

        // Merge refined results
        Object.assign(knowledgeBase, refinedResults);
      }

      const totalSources = Object.values(knowledgeBase)
        .flatMap(r => r.sources || []).length;

      addLog(`‚úì Research complete: ${Object.keys(knowledgeBase).length} searches, ${totalSources} sources found`, 'success');

      return knowledgeBase;
    }

    // ============================================
    // STAGE 0: VIABILITY CHECK
    // Determines if this should be a skill at all
    // ============================================

    // ============================================
    // SKILL REGISTRY
    // Local storage for tracking generated skills
    // ============================================

    const SKILL_REGISTRY_KEY = 'skill_builder_registry';

    function getSkillRegistry() {
      try {
        const registry = localStorage.getItem(SKILL_REGISTRY_KEY);
        return registry ? JSON.parse(registry) : [];
      } catch (err) {
        console.error('Failed to load skill registry:', err);
        return [];
      }
    }

    function addToSkillRegistry(skillData) {
      try {
        const registry = getSkillRegistry();
        registry.push({
          name: skillData.skill_name,
          description: skillData.description,
          created: new Date().toISOString(),
          viability_score: skillData.viability_score,
          test_pass_rate: skillData.test_pass_rate
        });

        // Keep only last 50 skills
        const trimmed = registry.slice(-50);
        localStorage.setItem(SKILL_REGISTRY_KEY, JSON.stringify(trimmed));
        addLog(`Added to skill registry: ${skillData.skill_name}`, 'info');
      } catch (err) {
        console.error('Failed to save to skill registry:', err);
      }
    }

    function clearSkillRegistry() {
      try {
        localStorage.removeItem(SKILL_REGISTRY_KEY);
        addLog('Skill registry cleared', 'success');
      } catch (err) {
        console.error('Failed to clear skill registry:', err);
      }
    }

    async function searchAnthropicSkills(query) {
      addLog('Searching for similar existing skills...', 'info');

      // Get local registry
      const localSkills = getSkillRegistry();

      // Also search for common/well-known skills via Claude
      try {
        const prompt = `List 3-5 common Claude Code skills that are similar to: "${query}"

Return ONLY a JSON array of skill objects (no markdown):
[
  {
    "name": "skill-name",
    "description": "what it does",
    "similarity": 0-10
  }
]

If no similar skills exist, return an empty array: []`;

        const response = await callClaude(prompt, 500, 'research');
        const cleaned = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const commonSkills = JSON.parse(cleaned);

        // Combine local and common skills
        const allSkills = [...localSkills, ...commonSkills];
        addLog(`Found ${allSkills.length} potentially similar skills`, 'info');
        return allSkills;
      } catch (err) {
        addLog(`Skill search limited to local registry (${localSkills.length} skills)`, 'info');
        return localSkills;
      }
    }

    function findSimilarSkills(userInput, existingSkills) {
      // Simple similarity check based on keywords
      const inputLower = userInput.toLowerCase();
      const inputWords = new Set(inputLower.split(/\s+/).filter(w => w.length > 3));

      return existingSkills.filter(skill => {
        const skillWords = new Set(skill.name.toLowerCase().split(/[-\s]+/).filter(w => w.length > 3));
        const intersection = new Set([...inputWords].filter(x => skillWords.has(x)));
        const similarity = intersection.size / Math.min(inputWords.size, skillWords.size);
        return similarity > 0.4;
      });
    }

    // ============================================
    // AUTO-CORRECTION FUNCTIONS
    // ============================================

    async function autoNarrowScope(input) {
      addLog('Auto-narrowing scope to single domain...', 'info');

      // Extract primary domain
      const domainPrompt = `Identify the PRIMARY domain for this skill concept (return only the domain name):

"${input}"

Common domains: business-operations, personal-finance, software-engineering, data-analysis, writing, healthcare, education, investing

Return ONLY the domain name, nothing else.`;

      const domain = (await callClaude(domainPrompt, 100, 'extraction')).trim();
      addLog(`  ‚Üí Identified primary domain: ${domain}`, 'info');

      // Narrow concept to that domain
      const narrowPrompt = `Rewrite this skill concept to focus ONLY on the "${domain}" domain:

Original: "${input}"

Requirements:
- Single sentence
- Specific problem space within ${domain}
- Remove references to other domains
- Keep it concrete and testable

Return ONLY the narrowed concept (one sentence), no explanation.`;

      const narrowed = (await callClaude(narrowPrompt, 150, 'extraction')).trim();
      addLog(`  ‚Üí Narrowed concept: ${narrowed}`, 'success');

      return narrowed;
    }

    async function autoExtractToReferences(documentation, skillName) {
      addLog('Auto-extracting long sections to references...', 'info');

      const lines = documentation.split('\n');
      const lineCount = lines.length;

      if (lineCount <= 200) {
        return { documentation, modified: false, lineCount };
      }

      addLog(`  ‚Üí Doc has ${lineCount} lines, extracting sections...`, 'info');

      // Extract sections
      const sections = [];
      let currentSection = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(/^##\s+(.+)$/);

        if (match) {
          if (currentSection) {
            sections.push(currentSection);
          }
          currentSection = {
            name: match[1],
            startLine: i,
            content: line + '\n',
            lineCount: 1
          };
        } else if (currentSection) {
          currentSection.content += line + '\n';
          currentSection.lineCount++;
        }
      }
      if (currentSection) sections.push(currentSection);

      // Find sections to extract (> 50 lines and extractable)
      const extractableSectionNames = [
        'Implementation Details',
        'Best Practices',
        'Integration Workflow',
        'Advanced Patterns',
        'Usage Examples'
      ];

      let modified = false;
      const references = {};

      for (const section of sections) {
        if (section.lineCount > 50 && extractableSectionNames.some(name =>
          section.name.toLowerCase().includes(name.toLowerCase())
        )) {
          const filename = section.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
          references[`references/${filename}.md`] = `# ${section.name}\n\n${section.content}`;

          // Replace in documentation with link
          documentation = documentation.replace(
            section.content,
            `See [references/${filename}.md](references/${filename}.md) for detailed information.\n\n`
          );

          addLog(`  ‚Üí Moved "${section.name}" to references/${filename}.md`, 'success');
          modified = true;
        }
      }

      // Condense examples if still too long
      const newLineCount = documentation.split('\n').length;
      if (newLineCount > 200 && documentation.includes('### Example ')) {
        const exampleMatches = documentation.match(/### Example \d+/g);
        if (exampleMatches && exampleMatches.length > 2) {
          const thirdExampleIdx = documentation.indexOf('### Example 3');
          if (thirdExampleIdx !== -1) {
            const nextSectionIdx = documentation.indexOf('\n## ', thirdExampleIdx);
            const cutEnd = nextSectionIdx === -1 ? documentation.length : nextSectionIdx;

            const before = documentation.substring(0, thirdExampleIdx);
            const after = documentation.substring(cutEnd);
            documentation = before + '\n*Additional examples available in [references/examples.md](references/examples.md)*\n\n' + after;

            addLog(`  ‚Üí Condensed examples (kept 2, noted rest in references)`, 'success');
            modified = true;
          }
        }
      }

      return {
        documentation,
        references,
        modified,
        lineCount: documentation.split('\n').length
      };
    }

    async function stage0_viabilityCheck(userInput) {
      addLog('=== STAGE 0: VIABILITY CHECK ===', 'info');
      updateProgress('Viability Check', 10, 'Analyzing skill request...');

      // Search for existing similar skills
      const existingSkills = await searchAnthropicSkills(userInput);
      const similarSkills = findSimilarSkills(userInput, existingSkills);

      updateProgress('Viability Check', 50, 'Evaluating viability criteria...');

      const prompt = `You are evaluating whether a skill request should become a Claude skill or just a prompt template.

USER REQUEST: ${userInput}

SIMILAR EXISTING SKILLS: ${similarSkills.length > 0 ? similarSkills.map(s => s.name).join(', ') : 'None found'}

Evaluate using these criteria:

1. IS DISTINCT: Is this sufficiently different from existing skills?
2. HAS SCOPE: Is this complex enough to warrant a skill (vs. simple prompt)?
3. IS REUSABLE: Will this be used multiple times, not just once?
4. IS TESTABLE: Does this have clear success criteria?

DECISION RULES:
- Score each criterion 0-10
- Average score >= 7: PROCEED (good skill candidate)
- Average score 4-6: NEEDS_REFINEMENT (consider simplification or as prompt template)
- Average score < 4: ABORT (this should be a prompt template, not a skill)

Return ONLY valid JSON (no markdown):
{
  "checks": {
    "is_distinct": { "score": 0-10, "reasoning": "why" },
    "has_scope": { "score": 0-10, "reasoning": "why" },
    "is_reusable": { "score": 0-10, "reasoning": "why" },
    "is_testable": { "score": 0-10, "reasoning": "why" }
  },
  "viability_score": 0-10,
  "decision": "PROCEED|NEEDS_REFINEMENT|ABORT",
  "reason": "brief explanation of decision",
  "scope": "if PROCEED, what is the recommended scope",
  "alternative": "if ABORT, what prompt template would work instead"
}`;

      try {
        let response = await callClaude(prompt, 1500, 'stage0');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const result = JSON.parse(response);

        addLog(`Viability Score: ${result.viability_score}/10`,
          result.viability_score >= 7 ? 'success' : result.viability_score >= 4 ? 'warning' : 'error');
        addLog(`Decision: ${result.decision}`, result.decision === 'PROCEED' ? 'success' : 'warning');
        addLog(`Reason: ${result.reason}`, 'info');

        updateProgress('Viability Check', 100, `Decision: ${result.decision}`);

        return result;
      } catch (err) {
        addLog(`Viability check failed: ${err.message} - proceeding anyway`, 'warning');
        // Default to proceed if check fails
        return {
          checks: {},
          viability_score: 7,
          decision: 'PROCEED',
          reason: 'Viability check failed - defaulting to proceed',
          scope: 'Standard skill scope'
        };
      }
    }

    // ============================================
    // STAGE 3: RESOURCE GATHERING
    // Replaces knowledge enhancement with real resource acquisition
    // ============================================

    async function findConcreteExamples(domain, requirements) {
      addLog('Finding real-world examples for skill...', 'info');

      const prompt = `Find and describe 3-5 concrete, real-world examples for this domain.

DOMAIN: ${domain}
SKILL: ${requirements.skill_name}
DESCRIPTION: ${requirements.description}

For each example, provide:
1. A specific use case or scenario
2. Key components or steps involved
3. What makes it effective

Return ONLY valid JSON (no markdown):
{
  "examples": [
    {
      "title": "example title",
      "scenario": "specific use case",
      "components": ["component1", "component2"],
      "effectiveness": "what makes this work well"
    }
  ]
}`;

      try {
        let response = await callClaude(prompt, 1500, 'research');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        addLog(`‚úì Found ${parsed.examples.length} concrete examples`, 'success');
        return parsed.examples || [];
      } catch (err) {
        addLog(`Example finding failed: ${err.message}`, 'warning');
        return [];
      }
    }

    function analyzeResourceNeeds(examples, requirements) {
      addLog('Analyzing resource requirements...', 'info');

      // Determine what types of resources would be helpful
      const resourcePlan = {
        scripts: [],
        references: [],
        assets: []
      };

      // Check if skill needs executable scripts (deterministic tasks)
      // REFERENCE_CODEGEN skills should NOT generate scripts - they're just documentation
      // Scripts only make sense for EXECUTOR_INTERNAL (deterministic operations)
      const shouldGenerateScripts = requirements.skill_category !== 'REFERENCE_CODEGEN' &&
                                   requirements.skill_category !== 'KNOWLEDGE' &&
                                   requirements.skill_category !== 'METHODOLOGY' &&
                                   (requirements.needs_scripts ||
                                    requirements.description.toLowerCase().includes('automat') ||
                                    requirements.description.toLowerCase().includes('process'));

      if (shouldGenerateScripts) {
        resourcePlan.scripts.push({
          name: `${requirements.skill_name}-helper.py`,
          purpose: 'Helper script for deterministic operations',
          type: 'python'
        });
      } else if (requirements.skill_category === 'REFERENCE_CODEGEN') {
        addLog('‚ÑπÔ∏è Skipping script generation for REFERENCE_CODEGEN skill (documentation only)', 'info');
      }

      // Check if skill needs reference documentation
      if (examples.length > 0) {
        resourcePlan.references.push({
          name: 'examples.md',
          purpose: 'Real-world examples and patterns',
          content: examples
        });
      }

      // Check if skill needs templates or assets
      if (requirements.description.toLowerCase().includes('template') ||
          requirements.description.toLowerCase().includes('format')) {
        resourcePlan.assets.push({
          name: 'template.md',
          purpose: 'Template for common patterns',
          type: 'markdown'
        });
      }

      addLog(`Resource plan: ${resourcePlan.scripts.length} scripts, ${resourcePlan.references.length} references, ${resourcePlan.assets.length} assets`, 'info');
      return resourcePlan;
    }

    async function acquireResources(resourcePlan, requirements) {
      addLog('Acquiring resources...', 'info');

      const resources = {
        scripts: {},
        references: {},
        assets: {}
      };

      // Generate scripts
      for (const scriptSpec of resourcePlan.scripts) {
        addLog(`Generating script: ${scriptSpec.name}`, 'info');

        const prompt = `Generate a ${scriptSpec.type} script for: ${scriptSpec.purpose}

SKILL: ${requirements.skill_name}
DESCRIPTION: ${requirements.description}

Create a well-documented, production-ready script.

Return ONLY the script code, no markdown, no explanations.`;

        try {
          const code = await callClaude(prompt, 1500, 'generation');
          resources.scripts[scriptSpec.name] = code;
          addLog(`‚úì Generated ${scriptSpec.name}`, 'success');
        } catch (err) {
          addLog(`Failed to generate ${scriptSpec.name}: ${err.message}`, 'warning');
        }
      }

      // Create reference documents
      for (const refSpec of resourcePlan.references) {
        addLog(`Creating reference: ${refSpec.name}`, 'info');
        resources.references[refSpec.name] = {
          title: refSpec.purpose,
          content: refSpec.content
        };
      }

      // Create asset templates
      for (const assetSpec of resourcePlan.assets) {
        addLog(`Creating asset: ${assetSpec.name}`, 'info');

        const prompt = `Create a ${assetSpec.type} template for: ${assetSpec.purpose}

SKILL: ${requirements.skill_name}

Return ONLY the template content.`;

        try {
          const template = await callClaude(prompt, 1000, 'generation');
          resources.assets[assetSpec.name] = template;
          addLog(`‚úì Created ${assetSpec.name}`, 'success');
        } catch (err) {
          addLog(`Failed to create ${assetSpec.name}: ${err.message}`, 'warning');
        }
      }

      return resources;
    }

    async function stage3_gatherResourcesAndExamples(requirements, domainKnowledge) {
      addLog('=== STAGE 3: RESOURCE GATHERING ===', 'info');
      updateProgress('Resource Gathering', 10, 'Finding real-world examples...');

      // Find concrete examples
      const examples = await findConcreteExamples(requirements.domain || requirements.skill_name, requirements);

      updateProgress('Resource Gathering', 40, 'Analyzing resource needs...');

      // Analyze what resources are needed
      const resourcePlan = analyzeResourceNeeds(examples, requirements);

      updateProgress('Resource Gathering', 60, 'Acquiring resources...');

      // Acquire/create resources
      const resources = await acquireResources(resourcePlan, requirements);

      updateProgress('Resource Gathering', 100, 'Resource gathering complete');
      addLog(`‚úì Resource gathering complete: ${Object.keys(resources.scripts).length} scripts, ${Object.keys(resources.references).length} references, ${Object.keys(resources.assets).length} assets`, 'success');

      return {
        examples: examples,
        resourcePlan: resourcePlan,
        resources: resources,
        domainKnowledge: domainKnowledge
      };
    }

    // ============================================
    // STAGE 7: SKILL TESTING WITH CLAUDE
    // Tests the generated skill with real Claude API calls
    // ============================================

    async function generateTestCases(requirements, skillContent) {
      addLog('Generating test cases for skill validation...', 'info');

      const prompt = `Given this skill package, generate 3-5 test cases to validate it works correctly.

SKILL NAME: ${requirements.skill_name}
SKILL DESCRIPTION: ${requirements.description}
SKILL CONTENT (first 1000 chars): ${skillContent.substring(0, 1000)}

For each test case, provide:
1. A user query/request that should trigger this skill
2. Expected behavior or output characteristics
3. Success criteria

Return ONLY valid JSON (no markdown):
{
  "test_cases": [
    {
      "query": "user query that should trigger this skill",
      "expected_behavior": "what the skill should do or provide",
      "success_criteria": ["criterion 1", "criterion 2"]
    }
  ]
}`;

      try {
        let response = await callClaude(prompt, 1500, 'testing');
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        return parsed.test_cases || [];
      } catch (err) {
        addLog(`Test case generation failed: ${err.message}`, 'warning');
        // Fallback to basic test case
        return [{
          query: `Help me with ${requirements.skill_name}`,
          expected_behavior: `Should use the skill to provide relevant guidance`,
          success_criteria: ["Response is relevant", "Uses skill knowledge"]
        }];
      }
    }

    async function testSkillWithClaude(skillContent, testCase) {
      addLog(`Testing: "${testCase.query.substring(0, 50)}..."`, 'info');

      const testPrompt = `You have access to the following skill:

---
${skillContent}
---

User query: ${testCase.query}

Use the skill to respond to this query.`;

      try {
        const response = await callClaude(testPrompt, 2000);
        return {
          query: testCase.query,
          response: response,
          success: true
        };
      } catch (err) {
        return {
          query: testCase.query,
          response: null,
          success: false,
          error: err.message
        };
      }
    }

    function validateTestResponse(response, testCase) {
      if (!response.success || !response.response) {
        return {
          passed: false,
          reason: `Test execution failed: ${response.error || 'No response'}`
        };
      }

      const responseText = response.response.toLowerCase();
      const query = testCase.query.toLowerCase();

      // Basic validation: response should be relevant and non-empty
      if (responseText.length < 50) {
        return {
          passed: false,
          reason: 'Response too short (less than 50 characters)'
        };
      }

      // Check if response seems relevant (contains key terms from query or skill)
      const relevanceScore = testCase.success_criteria.reduce((score, criterion) => {
        const criterionWords = criterion.toLowerCase().split(/\s+/);
        const matchedWords = criterionWords.filter(word =>
          word.length > 3 && responseText.includes(word)
        );
        return score + (matchedWords.length / criterionWords.length);
      }, 0);

      const passed = relevanceScore > 0.3 || responseText.length > 200;

      return {
        passed: passed,
        reason: passed ? 'Response appears relevant and substantive' : `Low relevance score: ${relevanceScore.toFixed(2)}`,
        relevanceScore: relevanceScore
      };
    }

    async function stage7_testSkill(skillPackage, requirements) {
      addLog('=== STAGE 7: SKILL TESTING ===', 'info');
      updateProgress('Testing', 10, 'Generating test cases...');

      const skillContent = `---\n${skillPackage.metadata}\n---\n\n${skillPackage.documentation}`;

      // Generate test cases
      const testCases = await generateTestCases(requirements, skillContent);
      addLog(`Generated ${testCases.length} test cases`, 'success');

      updateProgress('Testing', 30, `Running ${testCases.length} tests...`);

      // Run tests
      const results = [];
      for (let i = 0; i < testCases.length; i++) {
        const testCase = testCases[i];
        updateProgress('Testing', 30 + (50 * (i / testCases.length)),
          `Testing case ${i + 1}/${testCases.length}...`);

        const response = await testSkillWithClaude(skillContent, testCase);
        const validation = validateTestResponse(response, testCase);

        results.push({
          test: testCase,
          response: response,
          validation: validation,
          passed: validation.passed
        });

        const status = validation.passed ? '‚úì' : '‚úó';
        addLog(`${status} Test ${i + 1}: ${validation.passed ? 'PASSED' : 'FAILED'} - ${validation.reason}`,
          validation.passed ? 'success' : 'warning');
      }

      // Calculate pass rate
      const passedTests = results.filter(r => r.passed).length;
      const passRate = passedTests / results.length;

      updateProgress('Testing', 100, `Testing complete: ${passedTests}/${results.length} passed`);
      addLog(`Test Results: ${(passRate * 100).toFixed(0)}% pass rate (${passedTests}/${results.length})`,
        passRate >= 0.8 ? 'success' : 'warning');

      return {
        passRate: passRate,
        results: results,
        totalTests: results.length,
        passedTests: passedTests,
        failedTests: results.length - passedTests,
        recommendation: passRate >= 0.8 ? 'APPROVE' : 'NEEDS_REFINEMENT'
      };
    }

    // ============================================
    // STAGE 8: ITERATION LOOP
    // Analyzes test failures and suggests improvements
    // ============================================

    function analyzeTestFailures(testResults) {
      const failures = testResults.results.filter(r => !r.passed);

      if (failures.length === 0) {
        return {
          issues: [],
          recommendations: []
        };
      }

      const issues = [];
      const recommendations = [];

      // Analyze failure patterns
      const hasResponseFailures = failures.some(f => !f.response.success);
      const hasRelevanceFailures = failures.some(f =>
        f.validation.reason && f.validation.reason.includes('relevance')
      );
      const hasLengthFailures = failures.some(f =>
        f.validation.reason && f.validation.reason.includes('too short')
      );

      if (hasResponseFailures) {
        issues.push('response_failure');
        recommendations.push('Skill may be too complex or unclear - simplify instructions');
      }

      if (hasRelevanceFailures) {
        issues.push('relevance_failure');
        recommendations.push('Skill instructions may not be specific enough - add more concrete examples');
      }

      if (hasLengthFailures) {
        issues.push('insufficient_output');
        recommendations.push('Skill may need more detailed guidance on expected output format');
      }

      return {
        issues: issues,
        recommendations: recommendations,
        failureDetails: failures.map(f => ({
          query: f.test.query,
          reason: f.validation.reason
        }))
      };
    }

    async function refineSkillBasedOnFailures(skillPackage, analysis, testResults, requirements) {
      addLog('Attempting to refine skill based on test failures...', 'info');

      // Build failure context
      const failureContext = analysis.failureDetails.map(f =>
        `Query: "${f.query}"\nIssue: ${f.reason}`
      ).join('\n\n');

      const prompt = `Improve this skill's documentation based on test failures.

CURRENT DOCUMENTATION:
${skillPackage.documentation}

TEST FAILURES (${testResults.failedTests}/${testResults.totalTests}):
${failureContext}

IDENTIFIED ISSUES:
${analysis.recommendations.join('\n')}

INSTRUCTIONS:
- Fix the issues identified above
- Make instructions more clear and specific
- Add concrete examples where needed
- Ensure proper formatting and structure
- Do NOT include YAML frontmatter (just the markdown documentation)

Return the IMPROVED documentation (markdown only, no frontmatter):`;

      try {
        const improvedDocs = await callClaude(prompt, 4000, 'refinement');
        addLog('‚úì Generated improved documentation', 'success');

        // Return refined skill package
        return {
          metadata: skillPackage.metadata,
          documentation: improvedDocs,
          requirements: skillPackage.requirements
        };
      } catch (err) {
        addLog(`Failed to refine skill: ${err.message}`, 'error');
        return skillPackage; // Return original if refinement fails
      }
    }

    async function stage8_iterateIfNeeded(skillPackage, testResults, requirements, iterationCount = 0, research = null) {
      addLog('=== STAGE 8: ITERATION ANALYSIS ===', 'info');

      // Check if iteration is needed
      if (testResults.passRate >= 0.8) {
        addLog('‚úì Quality threshold met - no iteration needed', 'success');
        return {
          status: 'COMPLETE',
          finalSkill: skillPackage,
          testResults: testResults,
          iterations: iterationCount
        };
      }

      // Check iteration limit
      if (iterationCount >= 3) {
        addLog('‚ö† Maximum iterations reached - proceeding with current version', 'warning');
        return {
          status: 'MAX_ITERATIONS_REACHED',
          finalSkill: skillPackage,
          testResults: testResults,
          iterations: iterationCount,
          recommendation: 'Manual review recommended'
        };
      }

      // Analyze failures
      const analysis = analyzeTestFailures(testResults);
      addLog(`Identified ${analysis.issues.length} issue types from ${testResults.failedTests} failures`, 'warning');

      analysis.recommendations.forEach((rec, i) => {
        addLog(`Recommendation ${i + 1}: ${rec}`, 'info');
      });

      // AUTO-REGENERATE: Refine the skill based on failures
      addLog(`üîÑ Iteration ${iterationCount + 1}/3: Attempting auto-refinement...`, 'info');

      const refinedSkill = await refineSkillBasedOnFailures(
        skillPackage,
        analysis,
        testResults,
        requirements
      );

      // Re-test the refined skill
      addLog('Re-testing refined skill...', 'info');
      const newTestResults = await stage7_testSkill(refinedSkill, requirements);

      // Check if refinement improved the skill
      if (newTestResults.passRate > testResults.passRate) {
        addLog(`‚úì Improvement: ${(testResults.passRate * 100).toFixed(0)}% ‚Üí ${(newTestResults.passRate * 100).toFixed(0)}%`, 'success');
      } else {
        addLog(`No improvement: ${(testResults.passRate * 100).toFixed(0)}% ‚Üí ${(newTestResults.passRate * 100).toFixed(0)}%`, 'warning');
      }

      // Recursively iterate if still below threshold
      if (newTestResults.passRate < 0.8 && iterationCount + 1 < 3) {
        addLog('Still below threshold - continuing iteration...', 'info');
        return await stage8_iterateIfNeeded(
          refinedSkill,
          newTestResults,
          requirements,
          iterationCount + 1,
          research
        );
      }

      // Return final result
      return {
        status: newTestResults.passRate >= 0.8 ? 'COMPLETE' : 'NEEDS_REFINEMENT',
        finalSkill: refinedSkill,
        testResults: newTestResults,
        iterations: iterationCount + 1,
        analysis: analysis,
        improvement: newTestResults.passRate - testResults.passRate
      };
    }

    async function startGeneration() {
      let input = document.getElementById('skillInput').value.trim();
      if (!input || isGenerating) return;

      try {
        isGenerating = true;
        document.getElementById('generateBtn').disabled = true;
        document.getElementById('generateBtn').innerHTML = '‚è≥ Generating... <span class="loading-spinner"></span>';
        document.getElementById('inputCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');
        document.getElementById('logContainer').innerHTML = '';

        // Initialize retry counter
        if (!window.generationRetryCount) {
          window.generationRetryCount = 0;
        }

        // Stage 0: Viability Check (NEW - determines if this should be a skill)
        setStep(0);
        let viabilityCheck = await stage0_viabilityCheck(input);

        // AUTO-CORRECTION: If viability check fails, try to auto-narrow and retry
        if (viabilityCheck.decision === 'NEEDS_REFINEMENT' && viabilityCheck.viability_score < 7.0) {
          const MAX_RETRIES = 2;

          if (window.generationRetryCount < MAX_RETRIES) {
            addLog(`‚ö†Ô∏è Viability check: ${viabilityCheck.reason}`, 'warning');
            addLog(`Auto-correcting scope (attempt ${window.generationRetryCount + 1}/${MAX_RETRIES})...`, 'info');

            try {
              const narrowedInput = await autoNarrowScope(input);

              // Replace input with narrowed version
              input = narrowedInput;
              window.generationRetryCount++;

              addLog(`‚úì Continuing with narrowed scope`, 'success');
              addLog(`Retrying viability check...`, 'info');

              // Re-run viability check with narrowed input
              viabilityCheck = await stage0_viabilityCheck(input);

              // If still fails, the loop will catch it on next iteration
              // For now, continue with whatever result we got
              if (viabilityCheck.viability_score >= 7.0 || viabilityCheck.decision === 'PROCEED') {
                addLog(`‚úì Viability improved: ${viabilityCheck.viability_score}/10`, 'success');
              }

            } catch (err) {
              addLog(`‚ùå Auto-narrowing failed: ${err.message}`, 'error');
              addLog('Proceeding with original concept...', 'warning');
            }
          } else {
            addLog(`‚ùå Failed after ${MAX_RETRIES} auto-narrowing attempts`, 'error');
            addLog(`Issue: ${viabilityCheck.reason}`, 'error');
            throw new Error(`Skill concept could not be automatically narrowed. Please manually simplify the concept to a single problem space.`);
          }
        } else if (viabilityCheck.decision === 'ABORT') {
          addLog('‚ö†Ô∏è Viability check recommendation: This should be a prompt template, not a skill', 'warning');
          addLog(`Alternative: ${viabilityCheck.alternative}`, 'info');
          // For now, we'll show a warning but continue
          addLog('Proceeding with skill generation anyway...', 'warning');
        }

        // Reset retry counter on successful viability check
        window.generationRetryCount = 0;

        // Phase 1: Extract Requirements (now using potentially narrowed input)
        setStep(1);
        const requirements = await extractRequirements(input);

        // Check if clarification is needed
        if (requirements.needs_clarification) {
          addLog('‚ö†Ô∏è Your input could mean different things', 'warning');
          await showClarificationUI(requirements);
          return; // Stop generation and wait for user to clarify
        }

        currentRequirements = requirements;

        // Store viability check results
        currentRequirements.viability_check = viabilityCheck;

        // ========== REUSABLE CONTEXT RELIABILITY v1.3 ==========
        // Soft Input Gate: Check for audience/goal/constraints completeness
        addLog('Checking input completeness (audience, goal, constraints)...', 'info');
        const completenessCheck = checkInputCompleteness(requirements);

        if (!completenessCheck.complete) {
          addLog(`‚ö†Ô∏è Input incomplete: missing ${completenessCheck.missing.join(', ')}`, 'warning');
          addLog(`Completeness score: ${(completenessCheck.completeness_score * 100).toFixed(0)}%`, 'info');

          // Attempt to infer missing fields
          addLog('Attempting to infer missing fields from context...', 'info');
          const inferenceResult = await inferMissingFields(requirements, completenessCheck.missing);

          if (inferenceResult.inferredFields.length > 0) {
            addLog(`‚úì Inferred: ${inferenceResult.inferredFields.join(', ')}`, 'success');
          } else {
            addLog('Could not infer missing fields reliably', 'info');
          }

          // Route to ASSISTED_PROMPT_PACK (no full build)
          addLog('üìä Decision: NOT VIABLE ‚Üí Route: ASSISTED_PROMPT_PACK', 'warning');
          addLog(`   (inferred=[${inferenceResult.inferredFields.map(f => `'${f}'`).join(', ')}])`, 'info');

          // Update progress to show assisted fallback route
          updateProgress('Assisted Fallback', 25, 'Creating mini prompt pack...');

          // Create and show assisted prompt pack
          const assistedPack = await createAssistedPromptPack(
            requirements,
            completenessCheck,
            inferenceResult
          );

          await showAssistedPromptPack(assistedPack);

          // Stop generation here - wait for user to provide answers
          return;
        }

        addLog(`‚úì Input completeness check passed: ${completenessCheck.present.join(', ')} present`, 'success');
        // ========== END SOFT INPUT GATE ==========

        // Phase 0: Utility Analysis (runs after extraction)
        setStep(2);
        const utilityAnalysis = await analyzeUtility(requirements);

        // NEW: Skill Categorization Gate
        // Determines if skill is a real power-up and sets max utility ceiling
        const categorization = await categorizeSkill(input, requirements);
        const categoryMaxUtility = categorization.max_utility_score;
        const originalScore = utilityAnalysis.utility_score;

        // Apply category ceiling to utility score
        if (originalScore > categoryMaxUtility) {
          addLog(`‚ö†Ô∏è Applying category ceiling: ${originalScore}/10 ‚Üí ${categoryMaxUtility}/10 (${categorization.category} max)`, 'warning');
          utilityAnalysis.utility_score = categoryMaxUtility;
          utilityAnalysis.utility_category = categorizeUtilityScore(categoryMaxUtility);
          utilityAnalysis.category_capped = true;
          utilityAnalysis.original_score = originalScore;
        }

        // NEW: Apply floor for real power-ups (prevents contradiction)
        // If categorized as real power-up, minimum score should be 4/10 (MEDIUM)
        if (categorization.is_real_power_up && utilityAnalysis.utility_score < 4) {
          const beforeFloor = utilityAnalysis.utility_score;
          utilityAnalysis.utility_score = 4;
          utilityAnalysis.utility_category = 'MEDIUM_UTILITY';
          utilityAnalysis.floor_applied = true;
          utilityAnalysis.score_before_floor = beforeFloor;
          addLog(`‚úì Applied real power-up floor: ${beforeFloor}/10 ‚Üí 4/10 (${categorization.category} is real power-up)`, 'info');
          addLog(`Reasoning: ${categorization.category} skills with structured frameworks/knowledge provide genuine value`, 'info');
        }

        // Add categorization info to analysis
        utilityAnalysis.skill_category = categorization.category;
        utilityAnalysis.category_reasoning = categorization.category_reasoning;
        utilityAnalysis.is_real_power_up = categorization.is_real_power_up;
        utilityAnalysis.category_max_utility = categoryMaxUtility;
        utilityAnalysis.indicators_found = categorization.indicators_found;

        // Also add category to requirements so it flows through pipeline
        currentRequirements.skill_category = categorization.category;

        // NEW: Factory Mode Detection - determines if KNOWLEDGE skill needs enhancement
        const factoryMode = determineFactoryMode(utilityAnalysis);
        addLog(`Factory mode: ${factoryMode.mode}`, 'info');
        addLog(`Reason: ${factoryMode.reason}`, 'info');

        // Store mode for later use
        utilityAnalysis.factory_mode = factoryMode.mode;

        // If ENHANCEMENT mode, run Knowledge Enhancement Engine
        if (factoryMode.mode === 'ENHANCEMENT') {
          const enhancement = await enhanceKnowledgeSkill(
            requirements.skill_name,
            utilityAnalysis.power_up_statement
          );

          if (enhancement.success) {
            // Store enhancement results for use in research phase
            utilityAnalysis.knowledge_enhancement = enhancement;
            // Update the skill name to use the enhanced concept
            currentRequirements.original_skill_name = requirements.skill_name;
            currentRequirements.skill_name = enhancement.enhancedConcept;
            currentRequirements.description = enhancement.valueProposition;
            addLog(`‚úì Skill enhanced: ${enhancement.enhancedConcept}`, 'success');
          } else {
            addLog('‚ö† Enhancement failed - proceeding with original concept', 'warning');
          }
        }

        // Update phase_routing based on final score, category, and factory mode
        const finalScore = utilityAnalysis.utility_score;
        if (finalScore >= 7) {
          utilityAnalysis.phase_routing = 'PROCEED';
        } else if (finalScore >= 4) {
          // MEDIUM_UTILITY: REDESIGN for TEMPLATE/EXECUTOR, PROCEED for real power-ups
          if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REDESIGN';
          } else {
            utilityAnalysis.phase_routing = 'PROCEED';
          }
        } else {
          // LOW_UTILITY: Special handling for ENHANCEMENT mode
          if (factoryMode.mode === 'ENHANCEMENT') {
            // KNOWLEDGE skills that were enhanced should proceed to generation
            utilityAnalysis.phase_routing = 'PROCEED';
          } else if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REJECT';
          } else {
            utilityAnalysis.phase_routing = 'REDESIGN';
          }
        }

        // NEW: Constraint Validation Gate
        // Validates that power-up claims don't contradict skill's own constraints
        addLog('Running constraint validation...', 'info');
        const validationResult = validateConstraints(requirements, utilityAnalysis);

        let finalAnalysis = utilityAnalysis;
        if (validationResult.hasContradictions) {
          // Log found constraints
          addLog(`‚úì Found ${validationResult.constraints.length} constraint(s):`, 'info');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });

          // Log contradictions
          addLog(`‚ö†Ô∏è Constraint contradictions detected: ${validationResult.contradictions.length} claim(s) invalidated`, 'warning');
          validationResult.contradictions.forEach(contradiction => {
            addLog(`  ‚úó Claim: "${contradiction.claim}"`, 'warning');
            addLog(`    Conflicts: "${contradiction.constraint.substring(0, 60)}${contradiction.constraint.length > 60 ? '...' : ''}"`, 'warning');
          });

          addLog(`Score recalculated: ${validationResult.originalScore}/10 ‚Üí ${validationResult.revisedScore}/10 (${validationResult.scoreChange})`, 'warning');
          finalAnalysis = validationResult.revisedAnalysis;
        } else if (validationResult.hasConstraints) {
          addLog(`‚úì Found ${validationResult.constraints.length} constraint(s) - all claims validated`, 'success');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });
          addLog(`‚úì Constraint validation passed: ${validationResult.claimsChecked || 0} claim(s) verified`, 'success');
        } else {
          addLog('‚úì No constraints found - analysis valid', 'success');
        }

        utilityAnalysisResult = finalAnalysis;

        // Hide progress card and show utility results
        document.getElementById('progressCard').classList.add('hidden');
        await showUtilityResults(finalAnalysis, validationResult);

        // For HIGH_UTILITY, we could auto-proceed or wait for user
        // Currently waiting for user to click "Start Research Phase"
        // REDESIGN and REJECT paths stop here and wait for user action

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
        document.getElementById('generateBtn').disabled = false;
        document.getElementById('generateBtn').textContent = 'Generate This Skill ‚Üí';
      }
    }

    function downloadSkill() {
      if (!generatedSkillData) return;

      const url = URL.createObjectURL(generatedSkillData.package);
      const a = document.createElement('a');
      a.href = url;
      a.download = generatedSkillData.filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`Downloaded ${generatedSkillData.filename}`, 'success');
    }

    async function copyPromptToClipboard() {
      if (!generatedSkillData || !generatedSkillData.promptForClipboard) {
        addLog('No skill available to copy', 'error');
        return;
      }

      try {
        // Use pre-cached prompt (no async operations to preserve iOS Safari gesture context)
        const prompt = generatedSkillData.promptForClipboard;

        // Try clipboard API
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(prompt);
          showCopySuccess();
          addLog('Skill prompt copied to clipboard!', 'success');
        } else {
          throw new Error('Clipboard API not available. Please use HTTPS or a modern browser.');
        }

      } catch (error) {
        addLog(`Failed to copy: ${error.message}`, 'error');
        console.error('Copy error:', error);
      }
    }

    function showCopySuccess() {
      const button = document.getElementById('copyPromptBtn');
      const originalText = button.innerHTML;
      button.innerHTML = '‚úì Copied!';
      button.disabled = true;

      setTimeout(() => {
        button.innerHTML = originalText;
        button.disabled = false;
      }, 2000);
    }


    function resetFactory() {
      location.reload();
    }

    init();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deep Research Skill Factory - Aviram OS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0b0d;
      --bg-medium: #14161a;
      --bg-light: #1e2127;
      --glass-bg: rgba(30, 33, 39, 0.4);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --text-primary: #e8eaed;
      --text-secondary: #9aa0a6;
      --accent-primary: #8ab4f8;
      --accent-secondary: #81c995;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #0a0b0d 0%, #14161a 50%, #1e2127 100%);
      background-attachment: fixed;
      min-height: 100vh;
      padding: 24px;
      position: relative;
      overflow-x: hidden;
      color: var(--text-primary);
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 30%, rgba(138, 180, 248, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(129, 201, 149, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.01) 0%, transparent 80%);
      pointer-events: none;
      animation: ambientShift 30s ease-in-out infinite;
      z-index: 0;
    }

    @keyframes ambientShift {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.1); }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    .aviram-surface {
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      background: var(--glass-bg);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      box-shadow:
        0 8px 32px var(--shadow-color),
        inset 0 1px 0 var(--glass-highlight);
      padding: 32px;
      margin-bottom: 24px;
      contain: layout style paint;
      will-change: backdrop-filter, transform;
      transform: translate3d(0, 0, 0);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .aviram-surface:hover {
      backdrop-filter: blur(24px) saturate(140%);
      -webkit-backdrop-filter: blur(24px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.12);
      transform: translate3d(0, -2px, 0);
      box-shadow:
        0 12px 48px var(--shadow-color),
        inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .aviram-surface::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg,
        transparent 0%,
        var(--accent-primary) 50%,
        transparent 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .aviram-surface:hover::before {
      opacity: 0.5;
    }

    .header-surface {
      backdrop-filter: blur(30px) saturate(140%);
      -webkit-backdrop-filter: blur(30px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-radius: 24px;
      padding: 48px 40px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
      font-size: 48px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      letter-spacing: -1px;
      line-height: 1.1;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .stepper {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 32px 0;
      padding: 12px 0;
      position: relative;
    }

    .step {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      position: relative;
      z-index: 2;
    }

    .step-circle {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(30, 33, 39, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--text-secondary);
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .step-circle::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 50%;
      background: conic-gradient(
        var(--accent-primary) 0deg,
        transparent 90deg
      );
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .step-circle.active {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      transform: scale(1.15);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .step-circle.active::before {
      opacity: 0.3;
      animation: rotate 3s linear infinite;
    }

    @keyframes rotate {
      to { transform: rotate(360deg); }
    }

    .step-circle.complete {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow: 0 0 24px rgba(129, 201, 149, 0.3);
    }

    .step-label {
      margin-top: 14px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .step-label.active {
      color: var(--accent-primary);
    }

    .step-line {
      position: absolute;
      top: 32px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: rgba(255, 255, 255, 0.05);
      z-index: 1;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .step-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 12px currentColor;
    }

    .step-line.complete::after {
      width: 100%;
    }

    .step:last-child .step-line {
      display: none;
    }

    textarea {
      width: 100%;
      height: 240px;
      padding: 20px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(20, 22, 26, 0.5);
      border: 1.5px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
      resize: vertical;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    textarea:focus {
      outline: none;
      background: rgba(20, 22, 26, 0.7);
      border-color: var(--accent-primary);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.3),
        0 0 24px rgba(138, 180, 248, 0.2);
    }

    .btn {
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(138, 180, 248, 0.15);
      border: 1.5px solid var(--accent-primary);
      color: var(--accent-primary);
      padding: 18px 36px;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 20px;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(138, 180, 248, 0.2);
      text-shadow: 0 0 20px rgba(138, 180, 248, 0.5);
      transform: translate3d(0, 0, 0);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg,
        rgba(138, 180, 248, 0.2),
        rgba(129, 201, 149, 0.2));
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .btn:hover:not(:disabled)::before {
      opacity: 1;
    }

    .btn:hover:not(:disabled) {
      background: rgba(138, 180, 248, 0.25);
      border-color: rgba(138, 180, 248, 0.8);
      transform: translate3d(0, -3px, 0) scale(1.02);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .btn:active:not(:disabled) {
      transform: translate3d(0, 0, 0) scale(0.98);
    }

    .btn:disabled {
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      cursor: not-allowed;
      opacity: 0.5;
      text-shadow: none;
    }

    .btn.success {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 20px rgba(129, 201, 149, 0.2),
        0 0 30px rgba(129, 201, 149, 0.15);
    }

    .btn.success:hover {
      background: rgba(129, 201, 149, 0.25);
      box-shadow:
        0 8px 32px rgba(129, 201, 149, 0.3),
        0 0 40px rgba(129, 201, 149, 0.2);
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    .button-group .btn {
      flex: 1;
      min-width: 200px;
      margin-top: 0;
    }

    .btn-secondary {
      background: rgba(100, 100, 120, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
      color: var(--text-primary);
      box-shadow: 0 4px 20px rgba(100, 100, 120, 0.2);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(100, 100, 120, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow:
        0 8px 32px rgba(100, 100, 120, 0.3),
        0 0 40px rgba(100, 100, 120, 0.2);
    }

    @media (max-width: 768px) {
      .button-group {
        flex-direction: column;
      }

      .button-group .btn {
        width: 100%;
        min-width: 0;
      }
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(20, 22, 26, 0.6);
      border-radius: 8px;
      overflow: hidden;
      margin: 24px 0;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.05);
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg,
        var(--accent-primary),
        var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 20px currentColor;
      border-radius: 8px;
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .log-container {
      max-height: 520px;
      overflow-y: auto;
      padding: 20px;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(10, 11, 13, 0.6);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 2px 12px rgba(0, 0, 0, 0.5);
    }

    .log-container::-webkit-scrollbar {
      width: 6px;
    }

    .log-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
    }

    .log-container::-webkit-scrollbar-thumb {
      background: rgba(138, 180, 248, 0.3);
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    .log-container::-webkit-scrollbar-thumb:hover {
      background: rgba(138, 180, 248, 0.5);
    }

    .log-entry {
      padding: 14px 18px;
      margin-bottom: 10px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.7;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      transform: translate3d(0, 0, 0);
      animation: logEntryAppear 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes logEntryAppear {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .log-entry.info {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: #aec7fa;
    }

    .log-entry.success {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.2);
      color: #a8dab5;
    }

    .log-entry.warning {
      background: rgba(251, 188, 5, 0.08);
      border-color: rgba(251, 188, 5, 0.2);
      color: #fdd663;
    }

    .log-entry.error {
      background: rgba(242, 139, 130, 0.08);
      border-color: rgba(242, 139, 130, 0.2);
      color: #f8b4ae;
    }

    .log-time {
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      opacity: 0.6;
      margin-right: 12px;
      letter-spacing: 0.5px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    @media (max-width: 1024px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .aviram-surface {
        backdrop-filter: blur(12px) saturate(110%);
        -webkit-backdrop-filter: blur(12px) saturate(110%);
      }

      textarea {
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }
    }

    @media (prefers-contrast: high) {
      .aviram-surface {
        background: rgba(30, 33, 39, 0.95);
        backdrop-filter: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      textarea {
        background: rgba(10, 11, 13, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    .examples {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .example-btn {
      display: block;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 12px 18px;
      text-align: left;
      font-size: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 10px;
      margin-bottom: 8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      width: 100%;
      border: 1px solid transparent;
    }

    .example-btn:hover {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: var(--accent-primary);
      padding-left: 24px;
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.1);
    }

    .status-badge {
      display: inline-block;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 600;
      margin: 16px 0;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.3px;
    }

    .status-badge.success {
      background: rgba(129, 201, 149, 0.12);
      border-color: rgba(129, 201, 149, 0.4);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 16px rgba(129, 201, 149, 0.2),
        0 0 24px rgba(129, 201, 149, 0.1);
    }

    .status-badge.error {
      background: rgba(242, 139, 130, 0.12);
      border-color: rgba(242, 139, 130, 0.4);
      color: #f8b4ae;
      box-shadow:
        0 4px 16px rgba(242, 139, 130, 0.2),
        0 0 24px rgba(242, 139, 130, 0.1);
    }

    .file-tree {
      margin-top: 24px;
      font-family: 'SF Mono', 'Courier New', monospace;
      font-size: 13px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(10, 11, 13, 0.4);
      padding: 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      line-height: 1.8;
    }

    .file-item {
      padding: 4px 0;
      padding-left: 20px;
      color: var(--text-secondary);
      transition: color 0.2s ease;
    }

    .file-item:hover {
      color: var(--accent-primary);
    }

    .file-item.folder {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .hidden {
      display: none;
    }

    .loading-spinner {
      border: 3px solid rgba(138, 180, 248, 0.2);
      border-top: 3px solid var(--accent-primary);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      display: inline-block;
      margin-left: 12px;
      vertical-align: middle;
      box-shadow: 0 0 20px rgba(138, 180, 248, 0.3);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .reset-link {
      color: var(--text-secondary);
      cursor: pointer;
      text-decoration: none;
      font-size: 13px;
      float: right;
      font-weight: 600;
      padding: 10px 18px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(138, 180, 248, 0.08);
      border: 1px solid rgba(138, 180, 248, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .reset-link:hover {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.2);
    }

    h2 {
      color: var(--text-primary);
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 20px;
      letter-spacing: -0.3px;
    }

    h3 {
      color: var(--text-primary);
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      opacity: 0.9;
    }

    p {
      color: var(--text-secondary);
      line-height: 1.7;
    }

    .system-status {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-secondary);
      box-shadow:
        0 0 20px var(--accent-secondary),
        0 0 40px rgba(129, 201, 149, 0.3);
      animation: pulse 3s ease-in-out infinite;
      z-index: 1000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    .api-config {
      margin-bottom: 24px;
      padding: 20px;
      background: rgba(251, 188, 5, 0.08);
      border: 1px solid rgba(251, 188, 5, 0.2);
      border-radius: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config.collapsed {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.3);
      padding: 16px 20px;
    }

    .api-config-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .api-config-status {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    .api-config-status .check-icon {
      color: var(--accent-secondary);
      font-size: 18px;
      font-weight: bold;
    }

    .api-config-status .status-text {
      color: var(--accent-secondary);
      font-weight: 600;
      font-size: 14px;
    }

    .api-config-actions {
      display: flex;
      gap: 8px;
    }

    .api-config-btn {
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 8px;
      border: 1px solid;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .api-config-btn.edit {
      color: var(--accent-primary);
      border-color: rgba(138, 180, 248, 0.3);
    }

    .api-config-btn.edit:hover {
      background: rgba(138, 180, 248, 0.1);
      border-color: var(--accent-primary);
    }

    .api-config-btn.clear {
      color: #f8b4ae;
      border-color: rgba(242, 139, 130, 0.3);
    }

    .api-config-btn.clear:hover {
      background: rgba(242, 139, 130, 0.1);
      border-color: rgba(242, 139, 130, 0.5);
    }

    .api-config-form {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config-form.hidden {
      display: none;
    }

    .api-config input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(10, 11, 13, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: 'SF Mono', monospace;
      font-size: 13px;
      margin-top: 8px;
    }

    .api-config input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="aviram-surface header-surface">
      <h1>üè≠ Deep Research Skill Factory</h1>
      <p class="subtitle">SKILL FACTORY ‚Ä¢ TURN WORKFLOWS INTO CLAUDE SUPERPOWERS</p>
    </div>

    <div class="aviram-surface">
      <div class="stepper" id="stepper"></div>
    </div>

    <div class="grid">
      <div>
        <div class="aviram-surface" id="inputCard">
          <div class="api-config" id="apiConfig">
            <!-- Collapsed State (shown when API key is saved) -->
            <div class="api-config-header hidden" id="apiConfigCollapsed">
              <div class="api-config-status">
                <span class="check-icon">‚úì</span>
                <span class="status-text">API Key Configured</span>
              </div>
              <div class="api-config-actions">
                <button class="api-config-btn edit" onclick="expandApiConfig()">Edit</button>
                <button class="api-config-btn clear" onclick="clearApiKey()">Clear</button>
              </div>
            </div>

            <!-- Expanded State (shown on first visit or when editing) -->
            <div class="api-config-form" id="apiConfigForm">
              <h3>‚öôÔ∏è API Configuration</h3>
              <p style="font-size: 13px; margin-bottom: 8px;">Enter your Anthropic API key to enable skill generation:</p>
              <input
                type="password"
                id="apiKey"
                placeholder="sk-ant-..."
                autocomplete="off"
                onchange="saveApiKey()"
                onkeypress="if(event.key === 'Enter') saveApiKey()"
              />
              <p style="font-size: 11px; margin-top: 8px; opacity: 0.7;">Your key is stored locally in your browser only. Get one at console.anthropic.com</p>
            </div>
          </div>

          <h2>What do you want Claude to know how to do?</h2>
          <p style="color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
            Think of a workflow you repeat. A technical thing you explain constantly. A pattern you wish Claude just *knew*. Write it here. The system researches, architects, and packages it into a skill Claude can use forever.
          </p>
          <textarea
            id="skillInput"
            placeholder="Real examples that work:

‚Ä¢ Parse PDF tables into clean JSON, handle malformed data gracefully
‚Ä¢ Build type-safe React forms with accessible error states
‚Ä¢ Wrap REST APIs with auth refresh, retry logic, request deduplication

The more texture you give, the sharper the output. But even 'email automation' is enough to start."
          ></textarea>
          <button class="btn" id="generateBtn" onclick="startGeneration()">
            Generate This Skill ‚Üí
          </button>

          <div class="examples">
            <h3>Skills People Actually Use</h3>
            <button class="example-btn" onclick="setExample('Parse PDF tables and forms into structured JSON. Handle malformed PDFs, extract nested tables, preserve formatting context.')">‚Üí PDF parsing with error handling</button>
            <button class="example-btn" onclick="setExample('Build accessible React forms with real-time validation, error recovery, and keyboard navigation. Include ARIA labels and focus management.')">‚Üí Production-grade React forms</button>
            <button class="example-btn" onclick="setExample('Create REST API clients with token refresh, exponential backoff, request deduplication, and typed responses.')">‚Üí Industrial-strength API wrappers</button>
          </div>
        </div>

        <div class="aviram-surface hidden" id="utilityCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Utility Analysis</h2>
            <a class="reset-link" onclick="resetFactory()">‚Üê New</a>
          </div>

          <div id="utilityResults">
            <!-- Category Badge Section -->
            <div id="categoryBadgeSection" style="margin-bottom: 24px;">
              <!-- Category badge will be injected here -->
            </div>

            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 20px;">
              <div style="flex: 1;">
                <h3>Utility Score</h3>
                <div style="font-size: 48px; font-weight: 700; color: var(--accent-primary);" id="utilityScoreDisplay">-/10</div>
                <div id="utilityCategoryDisplay" style="font-size: 14px; font-weight: 600; margin-top: 8px;"></div>
              </div>
              <div style="flex: 2;">
                <h3>Power-Up Statement</h3>
                <p id="powerUpStatement" style="font-size: 15px; line-height: 1.6; color: var(--text-primary);"></p>
              </div>
            </div>

            <div style="margin: 24px 0;">
              <h3>Reasoning</h3>
              <p id="utilityReasoning" style="color: var(--text-secondary); line-height: 1.7;"></p>
            </div>

            <!-- Category Explanation Section -->
            <div id="categoryExplanationSection" class="hidden" style="margin: 24px 0;">
              <!-- Category explanation will be injected here -->
            </div>

            <!-- Constraint Validation Report -->
            <div id="constraintValidationReport" class="hidden"></div>

            <div id="utilityProceedSection" class="hidden">
              <div class="status-badge success">
                ‚úì HIGH UTILITY - Proceeding to Research
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                <strong>Research Direction:</strong> <span id="researchDirection"></span>
              </p>
              <button class="btn success" onclick="continueToResearch()">
                Continue to Research Phase ‚Üí
              </button>
            </div>

            <div id="utilityRedesignSection" class="hidden">
              <div class="status-badge" style="background: rgba(251, 188, 5, 0.12); border-color: rgba(251, 188, 5, 0.4); color: #fdd663;">
                ‚ö† MEDIUM UTILITY - Redesign Recommended
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                This skill has value but could be more focused. Choose a redesign suggestion or proceed anyway:
              </p>
              <div id="redesignOptions" style="margin: 20px 0;"></div>
              <div class="button-group">
                <button class="btn btn-secondary" onclick="proceedAnyway()">
                  Proceed Anyway
                </button>
                <button class="btn" onclick="resetFactory()">
                  Start Over
                </button>
              </div>
            </div>

            <div id="utilityRejectSection" class="hidden">
              <div class="status-badge error">
                ‚úó LOW UTILITY - Rejected
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                <strong>Rejection Reason:</strong> <span id="rejectionReason"></span>
              </p>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                Consider these high-utility alternatives instead:
              </p>
              <div id="rejectAlternatives" style="margin: 20px 0;"></div>
              <button class="btn" onclick="resetFactory()">
                Try New Skill Request
              </button>
            </div>
          </div>
        </div>

        <div class="aviram-surface hidden" id="progressCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Progress</h2>
            <a class="reset-link" onclick="resetFactory()">‚Üê New</a>
          </div>

          <div id="progressSection">
            <div class="progress-text">
              <span id="progressStage">Initializing...</span>
              <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressMessage" style="margin-top: 14px; font-size: 14px;"></p>
          </div>

          <div id="resultsSection" class="hidden">
            <div class="status-badge success">
              ‚úì Generation Complete
            </div>
            <p id="qualityScore" style="margin: 12px 0;"></p>

            <div class="button-group">
              <button class="btn success" id="downloadBtn" onclick="downloadSkill()">
                ‚¨áÔ∏è Download Skill Package
              </button>
              <button class="btn btn-secondary" id="copyPromptBtn" onclick="copyPromptToClipboard()">
                üìã Copy Prompt
              </button>
            </div>

            <div id="fileTree" class="file-tree"></div>
          </div>

          <div id="errorSection" class="hidden">
            <div class="status-badge error">
              ‚úó Generation Failed
            </div>
            <p id="errorMessage" style="margin: 12px 0;"></p>
            <button class="btn" onclick="resetFactory()">Try Again</button>
          </div>
        </div>
      </div>

      <div class="aviram-surface">
        <h2>Generation Log</h2>
        <div class="log-container" id="logContainer">
          <p style="color: var(--text-secondary); opacity: 0.6;">Logs will appear here during generation...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="system-status" title="System Ready"></div>

  <script>
    function initAviramContext() {
      const supportsBackdropFilter = CSS.supports('backdrop-filter', 'blur(1px)') ||
                                     CSS.supports('-webkit-backdrop-filter', 'blur(1px)');

      if (!supportsBackdropFilter) {
        console.warn('Backdrop filter not supported - using fallback');
        document.querySelectorAll('.aviram-surface').forEach(el => {
          el.style.background = 'rgba(30, 33, 39, 0.95)';
        });
      }

      document.querySelectorAll('.aviram-surface').forEach(surface => {
        surface.addEventListener('mouseenter', function() {
          this.style.willChange = 'backdrop-filter, transform';
        });

        surface.addEventListener('mouseleave', function() {
          this.style.willChange = 'auto';
        });
      });
    }

    let currentStep = 0;
    let generatedSkillData = null;
    let isGenerating = false;

    const steps = ['Viability', 'Input', 'Utility', 'Research', 'Generate', 'Validate', 'Package', 'Testing', 'Review'];
    const API_KEY_STORAGE_KEY = 'anthropic_api_key';

    // ============================================
    // CLAUDE CAPABILITIES CONTEXT (October 2025)
    // Single source of truth for what Claude can/cannot do
    // Updated: 2025-10-26
    // ============================================
    const CLAUDE_CAPABILITIES = {
      can_do: {
        web_search_real_time: "Claude HAS web search capability (launched March 2025)",
        bash_execution: "Claude Code CAN execute bash commands locally",
        file_operations: "Claude Code CAN read/write files locally",
        code_execution: "Claude Code CAN run scripts and commands",
        algorithm_application: "Claude CAN apply algorithms and reasoning frameworks",
        api_integration: "Claude CAN help build and execute API calls"
      },

      cannot_do: {
        production_deployment: "Claude CANNOT autonomously deploy to production systems",
        indefinite_operation: "Claude CANNOT run indefinitely without user supervision",
        protected_system_access: "Claude CANNOT access protected systems without user permission",
        permanent_state: "Claude CANNOT maintain state across independent sessions"
      },

      // Convert to prompt format for injection into LLM prompts
      toPromptFormat: function() {
        return `CRITICAL CAPABILITY FACTS (October 2025):
‚úì ${this.can_do.web_search_real_time}
‚úì ${this.can_do.bash_execution}
‚úì ${this.can_do.file_operations}
‚úì ${this.can_do.code_execution}

CLAUDE LIMITATIONS:
‚úó ${this.cannot_do.production_deployment}
‚úó ${this.cannot_do.indefinite_operation}
‚úó ${this.cannot_do.protected_system_access}`;
      }
    };

    const KNOWLEDGE_ENHANCEMENT_PROMPT = `You are a domain research specialist helping create the BEST POSSIBLE knowledge skill for Claude.

Your mission: Transform a generic skill concept into a deeply specialized expertise package.

UNDERSTANDING KNOWLEDGE SKILLS:
- KNOWLEDGE skills provide domain expertise, frameworks, and specialized know-how
- They are NOT automation tools, processors, or executors
- They enhance Claude's reasoning and output quality through structured expertise
- Value comes from crystallizing expert knowledge into reusable frameworks

RESEARCH PROCESS:

1. DOMAIN DEEP DIVE
   Investigate the domain thoroughly:
   - What are the specialized sub-domains and focus areas?
   - What frameworks and methodologies do experts use?
   - What techniques differentiate experts from novices?
   - What mental models and decision-making processes exist?
   - What common mistakes do practitioners make?
   - What knowledge is typically learned through years of experience?

2. EXPERTISE SYNTHESIS
   Identify what would elevate Claude's capabilities:
   - Core knowledge domains (the "what")
   - Proven frameworks and methodologies (the "how")
   - Guiding principles and best practices (the "why")
   - Domain-specific terminology and concepts
   - Advanced techniques and expert heuristics
   - Context that transforms output from good to exceptional

3. ENHANCEMENT STRATEGY
   Crystallize findings into a focused skill:
   - What specific expertise areas should this cover?
   - What frameworks can be systematically applied?
   - What knowledge gaps would this fill?
   - What value does this add over Claude's base knowledge?
   - How does this make Claude's output demonstrably better?

CRITICAL RULES:
- Stay within the SAME domain (don't pivot to different skill types)
- Focus on KNOWLEDGE and EXPERTISE (not tools or automation)
- Be SPECIFIC and SPECIALIZED (not generic templates)
- Identify FRAMEWORKS that can be systematically applied
- Crystallize EXPERT-LEVEL insights (not beginner content)

OUTPUT FORMAT (valid JSON only):
{
  "enhanced_concept": "specific, focused skill name",
  "knowledge_domains": [
    "domain 1 with brief description",
    "domain 2 with brief description",
    "domain 3 with brief description"
  ],
  "key_frameworks": [
    "framework 1: what it does",
    "framework 2: what it does",
    "framework 3: what it does"
  ],
  "expertise_areas": [
    "advanced technique/concept 1",
    "advanced technique/concept 2",
    "advanced technique/concept 3"
  ],
  "value_proposition": "Clear statement of how this expertise elevates Claude's capabilities in this domain",
  "research_summary": "2-3 sentence summary of what you discovered about this domain and why this enhancement matters"
}

EXAMPLES OF GOOD ENHANCEMENTS:

Generic: "marketing-expert"
Enhanced: "conversion-psychology-strategist"
Why: Specific focus on psychological triggers, decision-making heuristics, and behavioral economics in marketing

Generic: "senior-copywriter"
Enhanced: "strategic-messaging-architect"
Why: Focus on message hierarchy, audience psychology, brand voice systems, and cross-channel messaging frameworks

Generic: "data-analyst"
Enhanced: "analytical-storytelling-framework"
Why: Bridges quantitative analysis with narrative structure, visualization psychology, and insight communication

YOUR TASK:
Research the provided skill concept deeply, synthesize expert-level knowledge, and output enhanced skill specifications in valid JSON format.`;

    // API Key localStorage Management
    function loadApiKey() {
      const savedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
      if (savedKey) {
        document.getElementById('apiKey').value = savedKey;
        collapseApiConfig();
      }
    }

    function saveApiKey() {
      const apiKey = document.getElementById('apiKey').value.trim();
      if (apiKey) {
        localStorage.setItem(API_KEY_STORAGE_KEY, apiKey);
        collapseApiConfig();
        addLog('API key saved locally', 'success');
      }
    }

    function collapseApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.add('collapsed');
      collapsedView.classList.remove('hidden');
      formView.classList.add('hidden');
    }

    function expandApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.remove('collapsed');
      collapsedView.classList.add('hidden');
      formView.classList.remove('hidden');

      // Focus the input field
      document.getElementById('apiKey').focus();
    }

    function clearApiKey() {
      if (confirm('Are you sure you want to clear your saved API key?')) {
        localStorage.removeItem(API_KEY_STORAGE_KEY);
        document.getElementById('apiKey').value = '';
        expandApiConfig();
        addLog('API key cleared', 'info');
      }
    }

    function init() {
      initAviramContext();
      renderStepper();
      loadApiKey();
    }

    function renderStepper() {
      const stepper = document.getElementById('stepper');
      stepper.innerHTML = '';

      steps.forEach((stepName, index) => {
        const step = document.createElement('div');
        step.className = 'step';

        const circle = document.createElement('div');
        circle.className = 'step-circle';
        if (index === currentStep) circle.classList.add('active');
        if (index < currentStep) circle.classList.add('complete');
        circle.textContent = index < currentStep ? '‚úì' : index + 1;

        const label = document.createElement('div');
        label.className = 'step-label';
        if (index === currentStep) label.classList.add('active');
        label.textContent = stepName;

        const line = document.createElement('div');
        line.className = 'step-line';
        if (index < currentStep) line.classList.add('complete');

        step.appendChild(circle);
        step.appendChild(label);
        step.appendChild(line);
        stepper.appendChild(step);
      });
    }

    function setStep(step) {
      currentStep = step;
      renderStepper();
    }

    function setExample(text) {
      document.getElementById('skillInput').value = text;
    }

    function addLog(message, type = 'info') {
      const container = document.getElementById('logContainer');

      if (container.querySelector('p')) {
        container.innerHTML = '';
      }

      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;

      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `<span class="log-time">${time}</span>${message}`;

      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }

    function updateProgress(stage, percent, message) {
      document.getElementById('progressStage').textContent = stage;
      document.getElementById('progressPercent').textContent = `${percent}%`;
      document.getElementById('progressFill').style.width = `${percent}%`;
      document.getElementById('progressMessage').textContent = message;
    }

    function showError(message) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('errorSection').classList.remove('hidden');
      document.getElementById('errorMessage').textContent = message;
    }

    function showResults(validation, tree, filename) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('resultsSection').classList.remove('hidden');
      document.getElementById('qualityScore').textContent = `Quality Score: ${validation.qualityScore}/100`;

      const treeHtml = renderFileTree(tree);
      document.getElementById('fileTree').innerHTML = `<strong style="color: var(--accent-primary);">üì¶ Package Contents</strong>${treeHtml}`;
    }

    function renderFileTree(node, depth = 0) {
      let html = '';
      const indent = '  '.repeat(depth);

      if (node.type === 'folder') {
        html += `<div class="file-item folder">${indent}üìÅ ${node.name}/</div>`;
        if (node.children) {
          node.children.forEach(child => {
            html += renderFileTree(child, depth + 1);
          });
        }
      } else {
        const size = node.size ? ` (${(node.size / 1024).toFixed(1)} KB)` : '';
        html += `<div class="file-item file">${indent}üìÑ ${node.name}${size}</div>`;
      }

      return html;
    }

    function sanitizeFileName(name) {
      return name
        .toLowerCase()
        .replace(/[<>:"/\\|?*\x00-\x1F]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 255);
    }

    /**
     * Retry a function with exponential backoff
     * @param {Function} fn - Async function to retry
     * @param {number} maxRetries - Maximum number of retry attempts (default: 4)
     * @param {number} initialDelay - Initial delay in milliseconds (default: 2000)
     * @returns {Promise} - Result of the function
     */
    async function retryWithExponentialBackoff(fn, maxRetries = 4, initialDelay = 2000) {
      let lastError;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn();
        } catch (err) {
          lastError = err;

          // Don't retry on certain errors (API key issues, validation errors, etc.)
          if (err.message.includes('API key') ||
              err.message.includes('400') ||
              err.message.includes('401') ||
              err.message.includes('403')) {
            throw err;
          }

          // If this was the last attempt, throw the error
          if (attempt === maxRetries) {
            throw err;
          }

          // Calculate delay with exponential backoff: 2s, 4s, 8s, 16s
          const delay = initialDelay * Math.pow(2, attempt);
          addLog(`Network error on attempt ${attempt + 1}/${maxRetries + 1}. Retrying in ${delay/1000}s...`, 'warning');

          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      throw lastError;
    }

    async function callClaude(prompt, maxTokens = 2000) {
      const apiKey = document.getElementById('apiKey').value.trim();

      if (!apiKey) {
        throw new Error('Please enter your Anthropic API key');
      }

      // Wrap the fetch call with retry logic
      return await retryWithExponentialBackoff(async () => {
        try {
          const response = await fetch("/api/claude", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              apiKey,
              prompt,
              maxTokens
            })
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error || `API request failed with status ${response.status}`);
          }

          const data = await response.json();
          return data.text;
        } catch (err) {
          if (err.message.includes('API request failed')) {
            throw err;
          }
          throw new Error(`Network error: ${err.message}. Check your API key and internet connection.`);
        }
      });
    }

    async function extractRequirements(input) {
      addLog('Analyzing input and extracting requirements...', 'info');
      updateProgress('Input Processing', 10, 'Parsing requirements...');

      const prompt = `Extract skill requirements from this input as JSON:

INPUT: ${input}

Return ONLY valid JSON (no markdown):
{
  "skill_name": "lowercase-hyphenated-name",
  "description": "what it does and when to use it",
  "programming_language": "python|javascript|bash",
  "complexity": "simple|moderate|complex",
  "required_apis": ["api1", "api2"],
  "key_features": ["feature1", "feature2"],
  "needs_scripts": true|false,
  "needs_references": false
}`;

      try {
        let response = await callClaude(prompt);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const extracted = JSON.parse(response);

        addLog(`Extracted skill: ${extracted.skill_name}`, 'success');
        updateProgress('Input Processing', 100, 'Requirements extracted');
        return extracted;
      } catch (err) {
        throw new Error(`Failed to extract requirements: ${err.message}`);
      }
    }

    async function analyzeUtility(requirements) {
      addLog('Analyzing skill utility...', 'info');
      updateProgress('Utility Analysis', 10, 'Evaluating utility value...');

      const prompt = `You are the Universal Utility Analyzer. Your job is to determine whether
a skill request will genuinely power up Claude or if it's just organized
documentation that Claude can already produce.

Your north star: Skills should make Claude measurably better at something,
not just give it well-organized information it already has.

${CLAUDE_CAPABILITIES.toPromptFormat()}

Evaluate this skill request using the three universal questions:

1. Can Claude already do this well from training data?
   (Use the capability facts above to inform your answer)
2. What specific value does this skill provide that Claude doesn't have?
   - Executable code solving hard problems?
   - Embedded domain data or algorithms?
   - Non-obvious patterns/edge cases?
   - 2x+ performance improvement?
3. Can you complete: "This skill powers up Claude by: [SPECIFIC CAPABILITY]"?

Apply scoring: executable code (HIGH), embedded data (HIGH), domain patterns (HIGH),
generic documentation (LOW), templates Claude can generate (LOW), vague capability (LOW).

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

Output your analysis as JSON with these exact fields:
{
  "utility_score": 0-10,
  "utility_category": "HIGH_UTILITY|MEDIUM_UTILITY|LOW_UTILITY",
  "power_up_statement": "This skill powers up Claude by: [specific and testable capability]",
  "reasoning": "Why this scores as high/medium/low",
  "research_direction": "What to research to make THIS skill excellent (focus on the requested skill, not alternatives)",
  "rejection_reason": "Why rejected (only if LOW_UTILITY)",
  "recommended_redesigns": ["Alternative 1", "Alternative 2", "Alternative 3"],
  "domain": "detected domain",
  "phase_routing": "PROCEED|REDESIGN|REJECT"
}

IMPORTANT: research_direction should guide research for the REQUESTED skill.
- If KNOWLEDGE skill: "Find the best [domain] knowledge, principles, patterns to include"
- If PROCESSOR skill: "Research [domain] processing logic and algorithms"
- If METHODOLOGY skill: "Find the most effective [domain] methodologies and frameworks"
- DO NOT use research_direction to suggest pivoting to different skills - that's Problem Identifier's job

recommended_redesigns can suggest alternatives, but research_direction must stay focused on the actual request.

ROUTING RULES:
- Score 7-10: "PROCEED" (HIGH_UTILITY)
- Score 4-6: "REDESIGN" (MEDIUM_UTILITY) - suggest 2-3 alternatives
- Score 0-3: "REJECT" (LOW_UTILITY) - suggest 2-3 alternatives

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const analysis = JSON.parse(response);

        // Validate response structure
        if (!analysis.utility_score || !analysis.utility_category || !analysis.phase_routing) {
          throw new Error('Invalid analysis structure received');
        }

        addLog(`Utility score: ${analysis.utility_score}/10 (${analysis.utility_category})`,
               analysis.utility_score >= 7 ? 'success' : analysis.utility_score >= 4 ? 'warning' : 'error');
        addLog(`Power-up: ${analysis.power_up_statement}`, 'info');
        updateProgress('Utility Analysis', 100, `Analysis complete: ${analysis.phase_routing}`);

        return analysis;
      } catch (err) {
        throw new Error(`Utility analysis failed: ${err.message}`);
      }
    }

    async function categorizeSkill(skillInput, requirements) {
      /**
       * PHASE 0 CATEGORIZATION GATE
       *
       * Categorize skill request to determine if it's a real power-up.
       * This gate prevents template/executor skills from scoring HIGH_UTILITY.
       *
       * Categories:
       * - TEMPLATE: Code generation (NOT power-up, max 3/10)
       * - METHODOLOGY: Reasoning frameworks (REAL power-up, max 9/10)
       * - KNOWLEDGE: Domain knowledge (REAL power-up, max 9/10)
       * - PROCESSOR: Processing/analysis logic (REAL power-up, max 9/10)
       * - REFERENCE_CODEGEN: Documentation/API reference for external tools (REAL power-up, max 9/10)
       * - EXECUTOR (v2.1 UPDATE):
       *   - AGENTIC subtype: Runs in Claude's sandbox (REAL power-up, max 6/10)
       *   - EXTERNAL subtype: Requires external systems (NOT power-up, max 2/10)
       */
      addLog('Categorizing skill type...', 'info');

      const prompt = `Categorize this skill request. The category determines the maximum
utility score and whether it's a real power-up for Claude.

Skill request: ${skillInput}
Skill name: ${requirements.skill_name}
Description: ${requirements.description}

Return ONLY valid JSON (no markdown, no extra text):
{
  "category": "TEMPLATE|METHODOLOGY|KNOWLEDGE|PROCESSOR|REFERENCE_CODEGEN|EXECUTOR",
  "category_reasoning": "why this category",
  "is_real_power_up": boolean,
  "max_utility_score": integer (0-10),
  "power_up_description": "if true, what new capability Claude gains",
  "indicators_found": ["list of words/phrases that indicated category"],
  "executor_subtype": "agentic|external|null (only for EXECUTOR category)"
}

DEFINITION GUIDE:

TEMPLATE: Code templates/examples for humans to implement
- Claude does: Recommend code patterns
- Claude gains: Nothing (already knows these patterns from training)
- Examples: "boilerplate generator", "scaffolding templates", "starter code", "code snippet library"
- Max utility: 3/10
- Indicators: "templates", "examples", "boilerplate", "scaffolding", "starter", "snippet"
- Key test: Can Claude USE this itself? If NO (just static code examples) ‚Üí TEMPLATE

METHODOLOGY: Reasoning frameworks Claude applies directly
- Claude does: Use reasoning process
- Claude gains: New way of thinking about problems
- Examples: "contradiction detector", "research methodology", "verification framework"
- Max utility: 9/10
- Indicators: "methodology", "framework for thinking", "systematic approach", "process"

KNOWLEDGE: Domain knowledge Claude uses in reasoning
- Claude does: Apply knowledge in analysis
- Claude gains: New domain expertise
- Examples: "constraint patterns", "best practices", "optimization algorithms"
- Max utility: 9/10
- Indicators: "patterns", "rules", "algorithms", "best practices", "knowledge base"

PROCESSOR: Processing/analysis logic Claude executes
- Claude does: Execute processing/analysis
- Claude gains: New capability to analyze/process
- Examples: "query analyzer", "contradiction detector", "web researcher", "fact checker", "data analyzer"
- Max utility: 9/10
- Indicators: "analyzer", "detector", "researcher", "checker", "processor", "generator"
- IMPORTANT: Web research, fact-checking, data analysis ARE PROCESSOR skills
  (Claude has web search capability and can execute these tasks)

REFERENCE_CODEGEN: Documentation/API reference for external tools
- Claude does: Generate code for external execution
- Claude gains: Knowledge to produce correct code for external systems/tools
- Examples: "Hammerspoon API docs", "Docker patterns", "Terraform templates", "Arduino reference", "GitHub Actions workflows"
- Max utility: 9/10
- Indicators: "API reference", "documentation", "patterns", "automation framework", "scripting guide"
- Key distinction: Claude CANNOT execute these tools, but CAN generate correct code/configs for them
- Use case: User asks Claude to generate code ‚Üí User executes in external environment
- IMPORTANT: This is NOT about execution - it's about code generation quality improvement

EXECUTOR: Automation that involves code execution
- IMPORTANT: EXECUTOR skills now have TWO subtypes with different utility ceilings:

EXECUTOR (AGENTIC subtype): Claude can execute safely in sandbox
- Claude does: Execute code/tools in sandbox environment
- Claude gains: New executable capability (can run FFmpeg, Python, file operations, etc.)
- Examples: "FFmpeg video processor", "Python data pipeline", "image processing with ImageMagick", "file format converter"
- Max utility: 6/10
- Indicators: "bash commands", "python script", "file operations", "data processing", "ffmpeg", "imagemagick", "tool orchestration", "sandbox"
- Key tests:
  * Can run entirely in Claude's sandbox? YES
  * Requires no external systems/services? YES
  * No privileged operations (sudo, system daemons)? YES
  * If all YES ‚Üí EXECUTOR (agentic subtype, 6/10)

EXECUTOR (EXTERNAL subtype): Requires systems Claude cannot control
- Claude does: Recommend automation scripts for external execution
- Claude gains: Nothing (requires live external systems with security/safety concerns)
- Examples: "Live CI/CD pipeline runner", "Hammerspoon automation", "production cloud deployer", "system daemon controller"
- Max utility: 2/10
- Indicators: "system daemon", "hardware control", "live database", "production deployment", "external service", "privileged access", "hammerspoon", "autohotkey", "systemd", "cron"
- Key test: Requires external systems, privileged access, or live services? If YES ‚Üí EXECUTOR (external subtype, 2/10)

${CLAUDE_CAPABILITIES.toPromptFormat()}

CRITICAL: Be strict about categorization based on ACTUAL capabilities.
- If unsure between TEMPLATE and METHODOLOGY, ask: "Can Claude apply
  this in reasoning?" If NO ‚Üí TEMPLATE. If YES ‚Üí METHODOLOGY.
- If unsure between PROCESSOR and EXECUTOR, ask: "Can Claude Code execute
  this locally?" If YES ‚Üí PROCESSOR. If NO (needs external infrastructure) ‚Üí check next rule.
- If unsure between REFERENCE_CODEGEN and EXECUTOR, ask: "Is this documentation/reference
  for code generation OR does it require runtime integration?"
  Documentation/API reference ‚Üí REFERENCE_CODEGEN. Live system integration ‚Üí EXECUTOR.
- For EXECUTOR skills, determine subtype:
  * Can run in Claude's sandbox with no external dependencies? ‚Üí AGENTIC (6/10 max)
  * Requires external systems, privileged access, or live services? ‚Üí EXTERNAL (2/10 max)
  * Examples:
    - "FFmpeg video processor" ‚Üí EXECUTOR (agentic, 6/10)
    - "Python data pipeline" ‚Üí EXECUTOR (agentic, 6/10)
    - "Hammerspoon automation" ‚Üí EXECUTOR (external, 2/10)
    - "Live database migrator" ‚Üí EXECUTOR (external, 2/10)
- Web research/fact-checking skills are PROCESSOR, not TEMPLATE
  (Claude has web search capability)
- If skill name contains "generator" or "framework" BUT generates content/logic
  (not just code templates), classify as PROCESSOR not TEMPLATE.
  Example: "physics motion generator" ‚Üí PROCESSOR (Claude generates motion)
  Example: "API client framework" ‚Üí TEMPLATE (just code templates)
  Example: "web researcher" ‚Üí PROCESSOR (Claude has web search)
  Example: "Hammerspoon automation docs" ‚Üí REFERENCE_CODEGEN (generates code for external execution)
  Example: "Docker container patterns" ‚Üí REFERENCE_CODEGEN (generates Docker configs)
  Example: "live deploy runner" ‚Üí EXECUTOR (external subtype, requires runtime integration with live systems)
  Example: "FFmpeg batch processor" ‚Üí EXECUTOR (agentic subtype, runs in Claude sandbox)`;

      try {
        let response = await callClaude(prompt, 500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const categorization = JSON.parse(response);

        addLog(`‚úì Category: ${categorization.category}`, 'info');
        if (categorization.category === 'EXECUTOR' && categorization.executor_subtype) {
          addLog(`‚úì Executor subtype: ${categorization.executor_subtype.toUpperCase()}`, 'info');
          // Update is_real_power_up based on subtype
          if (categorization.executor_subtype === 'agentic') {
            categorization.is_real_power_up = true;
          } else {
            categorization.is_real_power_up = false;
          }
        }
        addLog(`‚úì Real power-up: ${categorization.is_real_power_up}`, 'info');
        addLog(`‚úì Max utility for ${categorization.category}: ${categorization.max_utility_score}/10`, 'info');

        return categorization;
      } catch (err) {
        throw new Error(`Categorization failed: ${err.message}`);
      }
    }

    // ========== FACTORY MODE DETECTION ==========
    // Determines routing: ENHANCEMENT (knowledge depth), REDESIGN (alternatives), or GENERATE (proceed)

    function determineFactoryMode(skillAnalysis) {
      const { skill_category, utility_score, is_real_power_up } = skillAnalysis;

      // KNOWLEDGE skills with low utility need enhancement, not alternatives
      if (skill_category === 'KNOWLEDGE' && utility_score <= 4 && is_real_power_up) {
        return {
          mode: 'ENHANCEMENT',
          reason: 'Generic knowledge concept - needs domain research and depth'
        };
      }

      // High utility skills proceed normally
      if (utility_score >= 7) {
        return {
          mode: 'GENERATE',
          reason: 'Specific skill with clear utility - proceed to generation'
        };
      }

      // Low utility non-knowledge skills get alternatives
      return {
        mode: 'REDESIGN',
        reason: 'Low utility - suggest alternative approaches'
      };
    }

    // ========== DOMAIN EXTRACTION & VALIDATION ==========
    // Prevents domain pivoting bug by extracting practitioners and validating suggestions

    async function extractDomainContext(requirements, detectedDomain) {
      /**
       * Extract comprehensive domain context including practitioners and exclusions
       * Returns domain metadata to constrain Problem Identifier Agent
       */
      const prompt = `Extract domain context from this skill request to prevent domain pivoting.

Skill Request: ${requirements.skill_name}
Description: ${requirements.description || 'N/A'}
Detected Domain: ${detectedDomain}

Return JSON with:
{
  "primary_domain": "exact domain name (e.g., 'web research', 'motion design', 'backend coding')",
  "domain_category": "CREATIVE|CODING|RESEARCH|AUTOMATION|FINANCE|DESIGN|WORKFLOW|DATA|COMMUNICATION",
  "domain_practitioners": ["list of 2-4 specific practitioner types who work in this domain"],
  "domain_context": "brief 1-sentence explanation of what this domain involves",
  "excluded_domains": ["list of 3-5 related but DIFFERENT domains to NOT pivot to"]
}

Examples:

Input: "web research analyst skill"
Output: {
  "primary_domain": "web research",
  "domain_category": "RESEARCH",
  "domain_practitioners": ["journalists", "researchers", "competitive analysts", "fact-checkers"],
  "domain_context": "Research and verification of information from web sources",
  "excluded_domains": ["investment research", "financial analysis", "M&A due diligence", "market research", "academic research"]
}

Input: "motion design skill"
Output: {
  "primary_domain": "motion design",
  "domain_category": "CREATIVE",
  "domain_practitioners": ["animators", "motion designers", "VFX artists", "animation directors"],
  "domain_context": "Creating animated motion graphics and visual effects",
  "excluded_domains": ["product design", "UX design", "frontend development", "game development", "video editing"]
}

Input: "database schema generator"
Output: {
  "primary_domain": "backend coding",
  "domain_category": "CODING",
  "domain_practitioners": ["backend engineers", "database engineers", "API developers", "systems architects"],
  "domain_context": "Server-side development and database management",
  "excluded_domains": ["frontend development", "DevOps", "data science", "data analytics", "cloud architecture"]
}

Return ONLY the JSON object.`;

      try {
        let response = await callClaude(prompt, 500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        return JSON.parse(response);
      } catch (err) {
        // Fallback to basic domain context
        return {
          primary_domain: detectedDomain,
          domain_category: "GENERAL",
          domain_practitioners: ["practitioners", "users", "professionals"],
          domain_context: `Work in the ${detectedDomain} domain`,
          excluded_domains: ["other domains", "unrelated industries"]
        };
      }
    }

    async function validateDomainRelevance(userDomain, problemAnalysis, practitioners) {
      /**
       * Validate that ALL suggestions stay within the user's specified domain
       * Returns validation results with scores and issues
       */
      const suggestions = problemAnalysis.redesign_suggestions || [];
      const validationResults = [];
      const scores = [];

      for (let i = 0; i < suggestions.length; i++) {
        const suggestion = suggestions[i];

        // Check if domain_relevance_score is present and sufficient
        const score = suggestion.domain_relevance_score || 0;
        scores.push(score);

        if (score < 7) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Low domain relevance score: ${score}/10 (minimum 7 required)`,
            score: score,
            recommendation: 'REJECT'
          });
        }

        // Validate that suggestion mentions user domain practitioners or domain
        const suggestionText = JSON.stringify(suggestion).toLowerCase();
        const domainLower = userDomain.toLowerCase();
        const practitionersFound = practitioners.some(p =>
          suggestionText.includes(p.toLowerCase())
        );
        const domainMentioned = suggestionText.includes(domainLower);

        if (!practitionersFound && !domainMentioned) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Does not mention ${userDomain} domain or its practitioners`,
            score: score,
            recommendation: 'REJECT'
          });
        }
      }

      return {
        domain: userDomain,
        total_suggestions: suggestions.length,
        validation_issues: validationResults,
        all_relevant: validationResults.length === 0,
        scores: scores,
        issues: validationResults,
        recommendation: validationResults.length === 0 ? 'PROCEED' : 'REVISE'
      };
    }

    // ========== PROBLEM IDENTIFIER AGENT ==========

    async function analyzeProblem(requirements, utilityAnalysis) {
      addLog('Identifying real practitioner problems...', 'info');
      updateProgress('Problem Analysis', 30, 'Researching domain pain points...');

      // Step 1: Enhanced domain extraction with practitioners
      addLog(`Extracting domain context for: ${utilityAnalysis.domain}`, 'info');
      const domainContext = await extractDomainContext(requirements, utilityAnalysis.domain);
      addLog(`‚úì Domain identified: ${domainContext.primary_domain}`, 'success');
      addLog(`‚úì Domain practitioners: ${domainContext.domain_practitioners.join(', ')}`, 'info');

      const prompt = `You are the Problem Identifier Agent for the ${domainContext.primary_domain} domain.

‚ö†Ô∏è CRITICAL CONSTRAINT - DOMAIN LOCK ‚ö†Ô∏è
ALL problem identification and redesign suggestions must be grounded EXCLUSIVELY
in the ${domainContext.primary_domain} domain and for practitioners who work in
this domain. Do NOT pivot to other industries or domains.

Domain: ${domainContext.primary_domain}
Practitioners: ${domainContext.domain_practitioners.join(', ')}
Domain Context: ${domainContext.domain_context}

üö´ DO NOT PIVOT TO THESE UNRELATED DOMAINS:
${domainContext.excluded_domains.map(d => `- ${d}`).join('\n')}

Your job is to research what practitioners in the ${domainContext.primary_domain}
domain actually struggle with, then suggest skill redesigns grounded in those
real problems.

${CLAUDE_CAPABILITIES.toPromptFormat()}

Given a skill request, answer:

1. PRACTITIONER PAIN POINTS (MUST BE IN ${domainContext.primary_domain.toUpperCase()})
   - What do ${domainContext.domain_practitioners.join(' or ')} struggle with? (Be specific, not generic)
   - What's their current workaround? (How do they solve it today?)
   - What does this problem cost them? (Time, money, errors)
   - How often do they face this? (Daily, per project, rare?)
   - Example: Not "budgeting is hard" but "predicting multi-location
     shoot costs with labor conflicts takes 8+ hours per production"

   ‚ö†Ô∏è VERIFY: Does this problem apply to ${domainContext.domain_practitioners.join(' or ')}
   in ${domainContext.primary_domain}? If NO, find a different problem.

2. CLAUDE CAPABILITY GAP (SPECIFIC TO ${domainContext.primary_domain.toUpperCase()})
   - What specifically can't Claude do well for ${domainContext.primary_domain}? (Not "general advice")
   - What would Claude need to do this? (Be concrete)
   - Consider the capabilities listed above - don't suggest gaps for capabilities Claude already has
   - Example: "Claude can discuss budgeting but cannot model
     constraint satisfaction with location-specific dependencies"

3. VALUE UNLOCK (MEASURABLE FOR ${domainContext.primary_domain.toUpperCase()} PRACTITIONERS)
   - What would solving this unlock for ${domainContext.domain_practitioners.join(' or ')}? (Measurable outcome)
   - How much time/money would it save? (Be specific)
   - What becomes possible? (New capability)
   - Example: "Generating accurate cost predictions in minutes vs.
     8+ hours, preventing 5-15% budget overruns"

Then suggest 2-3 redesigns where each:
- Targets ONE specific practitioner pain point IN ${domainContext.primary_domain.toUpperCase()}
- States what Claude can't do that's needed FOR ${domainContext.primary_domain.toUpperCase()}
- Shows why it would be HIGH_UTILITY
- Includes measurable outcome FOR ${domainContext.domain_practitioners.join(' or ')}
- Describes specific implementation (what data in ‚Üí what out)

Focus on PROBLEMS in ${domainContext.primary_domain}, not generic technical additions.

‚ùå EXAMPLE OF BAD DOMAIN PIVOTING (DO NOT DO THIS):
  User domain: "web research"
  Bad suggestion: "Investment analyst due diligence problems" ‚Üê WRONG! Different domain!

‚úÖ EXAMPLE OF GOOD DOMAIN-CONSTRAINED APPROACH:
  User domain: "web research"
  Good suggestion: "Cross-reference contradiction detector for journalists" ‚Üê CORRECT! Same domain!

If you cannot find domain-relevant problems that would be solved by a higher-utility
skill in ${domainContext.primary_domain}, explicitly state:
"No high-utility redesign opportunities identified in ${domainContext.primary_domain}.
The original skill concept may not have sufficient problem-solving potential in this domain."

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

CURRENT UTILITY ANALYSIS:
Score: ${utilityAnalysis.utility_score}/10
Category: ${utilityAnalysis.utility_category}
Domain: ${utilityAnalysis.domain}
Power-up: ${utilityAnalysis.power_up_statement}

Return JSON with this exact structure:
{
  "domain_analysis": {
    "user_specified_domain": "${domainContext.primary_domain}",
    "domain_verified": true,
    "domain_constraints_applied": true,
    "practitioners_analyzed": ${JSON.stringify(domainContext.domain_practitioners)}
  },
  "domain_research": {
    "practitioner_pain_points": [
      {
        "problem": "Specific problem practitioners face IN ${domainContext.primary_domain.toUpperCase()}",
        "why_hard": "What makes this challenging",
        "current_workaround": "How they solve it now",
        "cost_of_problem": "Time/money/errors cost",
        "frequency": "How often this occurs",
        "domain_relevance_score": 8-10
      }
    ],
    "claude_capability_gap": "What Claude specifically cannot do well for ${domainContext.primary_domain}",
    "value_unlock": "What would be unlocked by solving this FOR ${domainContext.domain_practitioners.join(' or ')}"
  },
  "redesign_suggestions": [
    {
      "original_skill": "${requirements.skill_name}",
      "redesigned_skill": "new-skill-name with specific capability",
      "problem_it_solves": "Specific practitioner pain point addressed IN ${domainContext.primary_domain.toUpperCase()}",
      "claude_power_up": "Specific capability this adds to Claude FOR ${domainContext.primary_domain.toUpperCase()}",
      "estimated_utility_score": 7-9,
      "why_higher_utility": "Why this scores higher than original",
      "measurable_outcome": "Concrete, measurable result FOR ${domainContext.domain_practitioners.join(' or ')}",
      "specific_implementation": "What data goes in ‚Üí what comes out",
      "domain_relevance_score": 8-10,
      "domain_fit_explanation": "Why this is relevant to ${domainContext.primary_domain}"
    }
  ]
}

‚ö†Ô∏è FINAL VALIDATION BEFORE RETURNING:
Review ALL suggestions and verify EVERY problem/redesign is exclusively relevant
to ${domainContext.primary_domain} and its practitioners. If ANY suggestion
mentions or targets a different domain, REJECT it and replace with an in-domain
alternative.

Return ONLY the JSON object, no markdown, no other text.`;

      try {
        let response = await callClaude(prompt, 2500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const problemAnalysis = JSON.parse(response);

        // Step 2: Validate domain relevance of all suggestions
        addLog('Validating problem domain relevance...', 'info');
        const validation = await validateDomainRelevance(
          domainContext.primary_domain,
          problemAnalysis,
          domainContext.domain_practitioners
        );

        if (validation.all_relevant) {
          addLog(`‚úì All ${validation.total_suggestions} suggestions verified in-domain`, 'success');
          addLog(`‚úì Domain relevance scores: ${validation.scores.join(', ')}`, 'info');
        } else {
          addLog(`‚ö† ${validation.issues.length} domain pivoting issues detected`, 'warning');
          validation.issues.forEach(issue => {
            addLog(`  - ${issue.suggestion}: ${issue.issue}`, 'warning');
          });
          throw new Error('Domain pivoting detected - suggestions cross into unrelated domains');
        }

        addLog('Problem analysis complete', 'success');
        updateProgress('Problem Analysis', 100, 'Problem-grounded redesigns identified');

        return problemAnalysis;
      } catch (err) {
        addLog('Problem analysis failed - using fallback', 'warning');
        addLog(`Error details: ${err.message}`, 'error');
        console.error('Problem analysis error:', err);
        // Return a basic structure if analysis fails
        return {
          domain_research: {
            practitioner_pain_points: [{
              problem: "Generic workflow inefficiency",
              why_hard: "Manual process",
              current_workaround: "Manual work",
              cost_of_problem: "Time consuming",
              frequency: "Regular"
            }],
            claude_capability_gap: "Needs more specific capabilities",
            value_unlock: "Improved efficiency"
          },
          redesign_suggestions: utilityAnalysis.recommended_redesigns.map(r => ({
            original_skill: requirements.skill_name,
            redesigned_skill: r,
            problem_it_solves: "Addresses domain-specific challenges",
            claude_power_up: "Enhanced capabilities for this domain",
            estimated_utility_score: 7,
            why_higher_utility: "More focused on solving specific problems",
            measurable_outcome: "Improved workflow efficiency",
            specific_implementation: "Framework-based approach"
          }))
        };
      }
    }

    // ========== KNOWLEDGE ENHANCEMENT ENGINE ==========
    // Transforms generic KNOWLEDGE skills into specialized expertise

    async function enhanceKnowledgeSkill(skillConcept, domainContext) {
      console.log('=== ENHANCEMENT API CALL DEBUG ===');
      console.log('Skill Concept:', skillConcept);
      console.log('Domain Context:', domainContext);
      console.log('Timestamp:', new Date().toISOString());

      // Get API key from localStorage
      const apiKey = document.getElementById('apiKey').value.trim();
      console.log('API key present:', apiKey ? 'Yes (length: ' + apiKey.length + ')' : 'No');

      if (!apiKey) {
        console.error('API key missing!');
        return {
          success: false,
          error: 'Please enter your Anthropic API key',
          diagnostics: {
            errorType: 'MissingAPIKey',
            errorMessage: 'No API key found in input field'
          }
        };
      }

      const prompt = `${KNOWLEDGE_ENHANCEMENT_PROMPT}

SKILL CONCEPT: ${skillConcept}
DOMAIN CONTEXT: ${domainContext || 'Not specified - infer from skill name'}

Begin your research and synthesis.`;

      console.log('Prompt length:', prompt.length, 'characters');

      // Use backend proxy structure (matches callClaude function)
      const requestBody = {
        apiKey: apiKey,
        prompt: prompt,
        maxTokens: 4000
      };

      console.log('Request body prepared for /api/claude backend');
      console.log('Backend proxy will use model: claude-haiku-4-5');

      try {
        console.log('Calling backend proxy at /api/claude...');
        const startTime = Date.now();

        const response = await fetch('/api/claude', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        const fetchDuration = Date.now() - startTime;
        console.log(`Backend fetch completed in ${fetchDuration}ms`);
        console.log('Response status:', response.status);
        console.log('Response ok:', response.ok);
        console.log('Response headers:', JSON.stringify([...response.headers.entries()]));

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          const errorText = errorData.error || `API request failed with status ${response.status}`;
          console.error('Backend returned non-OK status:', response.status);
          console.error('Error response:', errorData);
          return {
            success: false,
            error: `API error ${response.status}: ${errorText}`,
            diagnostics: {
              status: response.status,
              duration: fetchDuration,
              errorBody: errorData
            }
          };
        }

        console.log('Parsing JSON response from backend...');
        const data = await response.json();
        console.log('Backend response structure:', Object.keys(data));

        if (!data.text) {
          console.error('Unexpected backend response structure');
          console.error('Expected: data.text');
          console.error('Got:', JSON.stringify(data, null, 2));
          return {
            success: false,
            error: 'Unexpected backend response structure',
            diagnostics: {
              receivedStructure: Object.keys(data),
              fullResponse: data
            }
          };
        }

        const responseText = data.text;
        console.log('Response text length:', responseText.length, 'characters');
        console.log('Response text preview (first 500 chars):', responseText.substring(0, 500));

        // Clean up response (remove markdown code blocks if present)
        console.log('Cleaning response text...');
        let cleanedResponse = responseText.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        console.log('Cleaned response length:', cleanedResponse.length, 'characters');

        console.log('Attempting to parse response as JSON...');
        let enhancement;
        try {
          enhancement = JSON.parse(cleanedResponse);
          console.log('JSON parse successful!');
          console.log('Enhancement structure:', Object.keys(enhancement));
        } catch (parseError) {
          console.error('JSON parse failed!');
          console.error('Parse error:', parseError.message);
          console.error('Cleaned response that failed to parse:', cleanedResponse);
          console.error('Original response:', responseText);
          return {
            success: false,
            error: `JSON parse error: ${parseError.message}`,
            diagnostics: {
              parseError: parseError.message,
              cleanedResponse: cleanedResponse,
              originalResponse: responseText,
              responseLength: responseText.length
            }
          };
        }

        const requiredFields = ['enhanced_concept', 'knowledge_domains', 'key_frameworks', 'expertise_areas', 'value_proposition'];
        const missingFields = requiredFields.filter(field => !enhancement[field]);

        if (missingFields.length > 0) {
          console.error('Enhancement missing required fields:', missingFields);
          console.error('Present fields:', Object.keys(enhancement));
          console.error('Enhancement object:', enhancement);
          return {
            success: false,
            error: `Enhancement missing fields: ${missingFields.join(', ')}`,
            diagnostics: {
              missingFields,
              receivedFields: Object.keys(enhancement),
              enhancement
            }
          };
        }

        console.log('=== ENHANCEMENT SUCCESS ===');
        console.log('Enhanced concept:', enhancement.enhanced_concept);
        console.log('Knowledge domains count:', enhancement.knowledge_domains?.length);
        console.log('Key frameworks count:', enhancement.key_frameworks?.length);
        console.log('Expertise areas count:', enhancement.expertise_areas?.length);
        console.log('Value proposition:', enhancement.value_proposition);

        return {
          success: true,
          enhancedConcept: enhancement.enhanced_concept,
          knowledgeDomains: enhancement.knowledge_domains,
          keyFrameworks: enhancement.key_frameworks,
          expertiseAreas: enhancement.expertise_areas,
          valueProposition: enhancement.value_proposition,
          researchSummary: enhancement.research_summary || 'No summary provided',
          diagnostics: {
            duration: fetchDuration,
            status: response.status
          }
        };

      } catch (error) {
        console.error('=== ENHANCEMENT CATCH BLOCK ===');
        console.error('Error type:', error.constructor.name);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);

        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          console.error('DIAGNOSIS: Network/fetch error - Backend proxy unreachable');
          console.error('Check that /api/claude endpoint is available');
        } else if (error.name === 'SyntaxError') {
          console.error('DIAGNOSIS: JSON parsing error - response is not valid JSON');
        } else if (error.message.includes('timeout')) {
          console.error('DIAGNOSIS: Request timeout - Backend took too long to respond');
        } else if (error.message.includes('API key')) {
          console.error('DIAGNOSIS: API key error - Check that API key is valid');
        } else {
          console.error('DIAGNOSIS: Unknown error type');
        }

        return {
          success: false,
          error: error.message,
          diagnostics: {
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack
          }
        };
      }
    }

    // ========== CONSTRAINT VALIDATION GATE ==========
    // Prevents false power-up claims that contradict skill's own constraints

    function extractYAMLConstraints(text) {
      /**
       * Extract constraints from YAML frontmatter (primary source)
       * Looks for metadata.constraints field in YAML section
       */
      const constraints = [];

      try {
        // Find YAML frontmatter (between --- delimiters)
        const yamlMatch = text.match(/^---\s*\n([\s\S]*?)\n---/);
        if (!yamlMatch) {
          return constraints; // No YAML frontmatter found
        }

        const yamlText = yamlMatch[1];

        // Simple YAML parsing for constraints field
        // Look for "constraints:" or "  constraints:" (nested in metadata)
        const constraintsMatch = yamlText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
        if (constraintsMatch) {
          // Found top-level constraints
          const constraintStr = constraintsMatch[1].trim();
          // Split by period or newline
          const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
          constraints.push(...splitConstraints.map(c => c.trim()));
        }

        // Also check for nested metadata.constraints
        const metadataSection = yamlText.match(/metadata:\s*\n([\s\S]*?)(?=\n\S|\n---|\n$)/);
        if (metadataSection) {
          const metadataText = metadataSection[1];
          const metadataConstraintsMatch = metadataText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
          if (metadataConstraintsMatch) {
            const constraintStr = metadataConstraintsMatch[1].trim();
            const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
            constraints.push(...splitConstraints.map(c => c.trim()));
          }
        }
      } catch (err) {
        // If YAML parsing fails, return empty and fall back to text extraction
        console.warn('YAML constraint extraction failed:', err);
      }

      return constraints;
    }

    function extractTextConstraints(description) {
      /**
       * Extract constraint statements from text (secondary source)
       * Looks for constraint keywords in description body
       */
      const constraintKeywords = [
        'Cannot',
        'cannot',
        'Cannot access',
        'Cannot perform',
        'No access to',
        'Does not',
        'Cannot provide',
        'Limited to',
        'Restricted',
        'No real-time',
        'Users must',
        'User must',
        'Requires user to',
        'Not available',
        'Unable to',
        'No live',
        'Not capable'
      ];

      const constraints = [];
      const lines = description.split(/[.!?\n]/);

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Skip YAML frontmatter lines
        if (trimmed === '---') continue;
        if (trimmed.includes(':') && trimmed.split(':')[0].match(/^\s*[a-z_]+$/)) {
          // Likely a YAML field, skip
          continue;
        }

        for (const keyword of constraintKeywords) {
          if (trimmed.includes(keyword)) {
            // Clean up markdown formatting
            let cleaned = trimmed.replace(/^[*\-]\s*/, '').replace(/^\*\*/, '').replace(/\*\*$/, '');
            cleaned = cleaned.trim();
            if (cleaned && cleaned.length > 10) { // Avoid single words
              constraints.push(cleaned);
              break; // Don't add same line multiple times
            }
          }
        }
      }

      return constraints;
    }

    function extractConstraints(description) {
      /**
       * Extract ALL constraints from YAML metadata + description text
       * Returns array of constraint strings
       */
      const constraints = [];

      // Priority 1: YAML metadata constraints (most reliable)
      const yamlConstraints = extractYAMLConstraints(description);
      constraints.push(...yamlConstraints);

      // Priority 2: Text-based constraints (supplementary)
      const textConstraints = extractTextConstraints(description);

      // Deduplicate - avoid repeating similar constraints
      for (const textConstraint of textConstraints) {
        const textLower = textConstraint.toLowerCase();
        const isDuplicate = constraints.some(existing => {
          const existingLower = existing.toLowerCase();
          // Check for substantial overlap
          return existingLower.includes(textLower) || textLower.includes(existingLower);
        });

        if (!isDuplicate) {
          constraints.push(textConstraint);
        }
      }

      return constraints;
    }

    function extractPowerUpClaims(powerUpStatement) {
      /**
       * Extract specific capability claims from power-up statement
       * Returns array of claimed capabilities
       */
      const claims = [];
      const statement = powerUpStatement.toLowerCase();

      // Common claim markers
      const markers = [
        'providing',
        'enables',
        'powers up',
        'generates',
        'creates',
        'executes',
        'performs',
        'offers',
        'delivers',
        'gives',
        'adds'
      ];

      // Extract phrases after markers
      for (const marker of markers) {
        const regex = new RegExp(marker + '\\s+([^,;.]+)', 'gi');
        const matches = statement.matchAll(regex);

        for (const match of matches) {
          if (match[1]) {
            claims.push(match[1].trim());
          }
        }
      }

      // Also look for capability keywords directly
      const capabilityKeywords = [
        'web scraping',
        'data extraction',
        'real-time',
        'live data',
        'api calls',
        'database access',
        'authentication',
        'automated',
        'executable',
        'integration'
      ];

      for (const keyword of capabilityKeywords) {
        if (statement.includes(keyword)) {
          claims.push(keyword);
        }
      }

      return [...new Set(claims)]; // Remove duplicates
    }

    function validateConstraints(requirements, utilityAnalysis) {
      /**
       * Main constraint validation function
       * Checks if power-up claims contradict skill's own constraints
       * Returns validation report with revised score if needed
       */
      const description = requirements.description;
      const powerUpStatement = utilityAnalysis.power_up_statement;

      // Step 1: Extract constraints
      const constraints = extractConstraints(description);

      if (constraints.length === 0) {
        // No constraints found, analysis is valid as-is
        return {
          hasConstraints: false,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 2: Extract power-up claims
      const claims = extractPowerUpClaims(powerUpStatement);

      if (claims.length === 0) {
        // No specific claims found, analysis is valid as-is
        return {
          hasConstraints: true,
          constraints: constraints,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 3: Check for contradictions
      const contradictions = [];
      const validClaims = [];

      for (const claim of claims) {
        let isContradicted = false;
        let conflictingConstraint = null;

        for (const constraint of constraints) {
          if (detectContradiction(claim, constraint)) {
            isContradicted = true;
            conflictingConstraint = constraint;
            contradictions.push({
              claim: claim,
              constraint: conflictingConstraint,
              reason: 'Claim contradicts explicit constraint'
            });
            break;
          }
        }

        if (!isContradicted) {
          validClaims.push(claim);
        }
      }

      // Step 4: If no contradictions, return original analysis
      if (contradictions.length === 0) {
        return {
          hasConstraints: true,
          constraints: constraints,
          claimsChecked: claims.length,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 5: Contradictions found - recalculate score
      const validClaimsRatio = validClaims.length / claims.length;
      const originalScore = utilityAnalysis.utility_score;
      const newScore = recalculateUtilityScore(
        originalScore,
        contradictions.length,
        validClaimsRatio
      );

      // Step 6: Rebuild power-up statement
      const revisedPowerUp = validClaims.length > 0
        ? `This skill powers up Claude by: ${validClaims.join(', ')}`
        : '‚ö†Ô∏è No valid power-up statement (claims contradicted by constraints)';

      // Step 7: Update category based on new score
      const revisedCategory = categorizeUtilityScore(newScore);

      // Step 8: Update phase routing based on new score
      const revisedRouting = newScore >= 7 ? 'PROCEED'
        : newScore >= 4 ? 'REDESIGN'
        : 'REJECT';

      // Step 9: Build revised analysis
      const revisedAnalysis = {
        ...utilityAnalysis,
        utility_score: newScore,
        utility_category: revisedCategory,
        power_up_statement: revisedPowerUp,
        phase_routing: revisedRouting,
        reasoning: utilityAnalysis.reasoning +
          `\n\n‚ö†Ô∏è CONSTRAINT VALIDATION ADJUSTMENT: Original score ${originalScore}/10 reduced to ${newScore}/10. ` +
          `${contradictions.length} power-up claim(s) contradicted by skill's own constraints.`
      };

      return {
        hasConstraints: true,
        constraints: constraints,
        claimsChecked: claims.length,
        hasContradictions: true,
        contradictions: contradictions,
        validClaims: validClaims,
        originalScore: originalScore,
        revisedScore: newScore,
        scoreChange: newScore - originalScore,
        validClaimsRatio: validClaimsRatio,
        originalAnalysis: utilityAnalysis,
        revisedAnalysis: revisedAnalysis
      };
    }

    function detectContradiction(claim, constraint) {
      /**
       * Check if a claim contradicts a constraint
       * Returns true if contradiction detected
       *
       * IMPORTANT: Only explicit prohibitions (cannot, no access, etc.) are contradictions.
       * Requirements like "users must provide API key" are NOT contradictions - they indicate
       * the capability exists but needs user input.
       */
      const claimLower = claim.toLowerCase();
      const constraintLower = constraint.toLowerCase();

      // Contradiction patterns - ONLY explicit prohibitions
      const contradictionMap = {
        'web scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'data extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'real-time': ['cannot real-time', 'no real-time', 'cannot access live', 'not real-time', 'no access to'],
        'live data': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'live': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'api calls': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'api': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'authentication': ['cannot authenticate', 'no auth', 'cannot access', 'no access to'],
        'database': ['cannot access', 'no database', 'no access to'],
        'automated': ['cannot automate', 'no automation'],
        'executable': ['cannot execute', 'no execution'],
        'integration': ['cannot integrate', 'no integration', 'no access to']
      };

      // Check if claim matches any contradiction pattern
      for (const [keyword, blockPatterns] of Object.entries(contradictionMap)) {
        if (claimLower.includes(keyword)) {
          for (const pattern of blockPatterns) {
            if (constraintLower.includes(pattern)) {
              return true;
            }
          }
        }
      }

      // Additional word-overlap check - ONLY for explicit prohibitions
      const claimWords = new Set(claimLower.split(/\s+/).filter(w => w.length > 3));
      const constraintWords = constraintLower.split(/\s+/).filter(w => w.length > 3);

      // If constraint says "cannot X" or "no access to X" and claim includes "X", it's a contradiction
      if (constraintLower.includes('cannot') || constraintLower.includes('no access')) {
        for (const word of claimWords) {
          if (constraintWords.includes(word)) {
            return true;
          }
        }
      }

      return false;
    }

    function recalculateUtilityScore(originalScore, contradictionCount, validClaimsRatio) {
      /**
       * Recalculate utility score based on constraint contradictions
       * Each contradiction = -2 points
       * If <50% of claims are valid = -4 additional points
       */
      let penalty = contradictionCount * 2;

      if (validClaimsRatio < 0.5) {
        penalty += 4;
      }

      const newScore = Math.max(0, originalScore - penalty);
      return newScore;
    }

    function categorizeUtilityScore(score) {
      /**
       * Convert numeric score to category
       */
      if (score >= 7) return 'HIGH_UTILITY';
      if (score >= 4) return 'MEDIUM_UTILITY';
      return 'LOW_UTILITY';
    }

    let utilityAnalysisResult = null;
    let currentRequirements = null;
    let problemAnalysisResult = null;

    async function showUtilityResults(analysis, validationResult = null) {
      document.getElementById('utilityCard').classList.remove('hidden');

      // Display category badge and explanation
      const categoryBadgeSection = document.getElementById('categoryBadgeSection');
      const categoryExplanationSection = document.getElementById('categoryExplanationSection');

      if (analysis.skill_category) {
        // Category color and icon mapping
        const categoryConfig = {
          'TEMPLATE': {
            color: '#f8b4ae',
            icon: 'üìÑ',
            label: 'TEMPLATE',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'Code templates'
          },
          'METHODOLOGY': {
            color: '#8ab4f8',
            icon: 'üß†',
            label: 'METHODOLOGY',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Reasoning framework'
          },
          'KNOWLEDGE': {
            color: '#81c995',
            icon: 'üìö',
            label: 'KNOWLEDGE',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Domain expertise'
          },
          'PROCESSOR': {
            color: '#fdd663',
            icon: '‚öôÔ∏è',
            label: 'PROCESSOR',
            powerUp: true,
            capabilityGain: 'high',
            description: 'Analysis logic'
          },
          'REFERENCE_CODEGEN': {
            color: '#c58af9',
            icon: 'üìñ',
            label: 'REFERENCE_CODEGEN',
            powerUp: true,
            capabilityGain: 'high',
            description: 'API reference'
          },
          'EXECUTOR': {
            color: '#f8b4ae',
            icon: 'ü§ñ',
            label: 'EXECUTOR',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'External automation'
          },
          'EXECUTOR_AGENTIC': {
            color: '#81c995',
            icon: 'üü¢',
            label: 'Agentic Skill',
            powerUp: true,
            capabilityGain: 'strong',
            description: 'Runs safely here'
          },
          'EXECUTOR_EXTERNAL': {
            color: '#f8b4ae',
            icon: 'üü†',
            label: 'External Skill',
            powerUp: false,
            capabilityGain: 'limited',
            description: 'Runs elsewhere'
          }
        };

        // Handle executor subtypes
        let categoryKey = analysis.skill_category;
        if (analysis.skill_category === 'EXECUTOR' && analysis.executor_subtype) {
          categoryKey = `EXECUTOR_${analysis.executor_subtype.toUpperCase()}`;
        }

        const config = categoryConfig[categoryKey] || {
          color: '#9aa0a6',
          icon: '‚ùì',
          label: analysis.skill_category,
          powerUp: false,
          capabilityGain: 'unknown',
          description: 'Unknown type'
        };

        // Display category badge with capability gain
        const capabilityGainLabels = {
          'high': { text: 'High Capability Gain', color: '#81c995' },
          'strong': { text: 'Strong Capability Gain', color: '#81c995' },
          'limited': { text: 'Limited Capability Gain', color: '#f8b4ae' },
          'unknown': { text: 'Unknown', color: '#9aa0a6' }
        };
        const gainLabel = capabilityGainLabels[config.capabilityGain] || capabilityGainLabels['unknown'];

        categoryBadgeSection.innerHTML = `
          <div style="background: rgba(${config.powerUp ? '138, 180, 248' : '248, 180, 174'}, 0.1); border: 1px solid ${config.color}; border-radius: 12px; padding: 16px; display: flex; align-items: center; gap: 12px;">
            <div style="font-size: 32px;">${config.icon}</div>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 4px; flex-wrap: wrap;">
                <span style="background: ${config.color}; color: #0a0b0d; border-radius: 6px; padding: 4px 12px; font-size: 12px; font-weight: 700; letter-spacing: 0.5px;">
                  ${config.label}
                </span>
                <span style="color: ${gainLabel.color}; font-weight: 600; font-size: 13px;">
                  ${config.powerUp ? '‚úì' : '‚óã'} ${gainLabel.text}
                </span>
                ${analysis.category_capped ?
                  `<span style="color: #fdd663; font-size: 13px; font-weight: 600;">‚ö†Ô∏è Capped: ${analysis.original_score} ‚Üí ${analysis.utility_score}</span>` : ''}
              </div>
              <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
                ${config.description} ‚Äî ${analysis.category_reasoning}
              </div>
            </div>
          </div>
        `;

        // Display category explanation (human-readable)
        const categoryExplanations = {
          'TEMPLATE': 'Code templates and examples. Claude already knows how to generate these patterns from its training data.',
          'METHODOLOGY': 'Reasoning framework that Claude can apply directly. Expands how Claude thinks about problems.',
          'KNOWLEDGE': 'Domain expertise that Claude can use in its analysis. Adds specialized knowledge Claude needs.',
          'PROCESSOR': 'Analysis logic Claude can execute. Gives Claude new ways to process and understand information.',
          'REFERENCE_CODEGEN': 'API documentation that helps Claude write better code for external tools. Improves code generation quality.',
          'EXECUTOR': 'Automation that runs outside Claude. Helpful for you, but not a new Claude capability.',
          'EXECUTOR_AGENTIC': 'Runs safely inside Claude\'s environment. Adds real executable capability ‚Äî Claude can now process data, run scripts, and transform files directly.',
          'EXECUTOR_EXTERNAL': 'Runs on your system, not in Claude. Still useful (generates code you can run), but doesn\'t expand what Claude itself can do.'
        };

        // Show explanation for non-power-ups OR agentic executors (to explain capability gain)
        if (!analysis.is_real_power_up || (analysis.skill_category === 'EXECUTOR' && analysis.executor_subtype === 'agentic')) {
          categoryExplanationSection.classList.remove('hidden');
          const explanationStyle = analysis.is_real_power_up ?
            'background: rgba(129, 201, 149, 0.08); border-left: 4px solid #81c995;' :
            'background: rgba(248, 180, 174, 0.08); border-left: 4px solid #f8b4ae;';
          const explanationTitle = analysis.is_real_power_up ?
            `<strong style="color: #81c995;">‚úì What This Adds:</strong>` :
            `<strong style="color: #f8b4ae;">‚óã Capability Limitation:</strong>`;

          categoryExplanationSection.innerHTML = `
            <div style="${explanationStyle} border-radius: 8px; padding: 16px;">
              ${explanationTitle}
              <p style="margin: 8px 0 0 0; color: var(--text-secondary); line-height: 1.6;">
                ${categoryExplanations[categoryKey]}
              </p>
            </div>
          `;
        } else {
          categoryExplanationSection.classList.add('hidden');
        }

        // Add contextual "What is Capability Gain?" info card (v2.1)
        if (analysis.skill_category === 'EXECUTOR') {
          const capabilityGainInfo = document.createElement('div');
          capabilityGainInfo.style.cssText = 'background: rgba(138, 180, 248, 0.08); border: 1px solid rgba(138, 180, 248, 0.3); border-radius: 8px; padding: 14px; margin-top: 12px; font-size: 12px; line-height: 1.5;';
          capabilityGainInfo.innerHTML = `
            <strong style="color: #8ab4f8;">üí° What is Capability Gain?</strong>
            <p style="margin: 6px 0 0 0; color: var(--text-secondary);">
              Capability Gain measures what <em>Claude itself</em> can now do, not how helpful the idea is to you.
              Skills that run inside Claude's environment add real execution capability.
              Skills that run on your system are still useful (they help Claude write better code for you),
              but they don't expand Claude's own abilities.
            </p>
          `;
          categoryExplanationSection.parentElement.insertBefore(capabilityGainInfo, categoryExplanationSection.nextSibling);
        }
      }

      // Display constraint validation report if there were contradictions
      const validationContainer = document.getElementById('constraintValidationReport');
      if (validationResult && validationResult.hasContradictions) {
        let validationHTML = `
          <div style="background: rgba(248, 180, 174, 0.08); border: 1px solid rgba(248, 180, 174, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #f8b4ae; margin-bottom: 16px;">üõë CONSTRAINT CONTRADICTIONS DETECTED</h3>

            <div style="margin-bottom: 16px;">
              <div style="display: flex; gap: 20px; margin-bottom: 12px;">
                <div>
                  <strong style="color: var(--text-secondary);">Original Score:</strong>
                  <span style="color: var(--text-primary); font-size: 18px; margin-left: 8px;">${validationResult.originalScore}/10</span>
                </div>
                <div>
                  <strong style="color: var(--text-secondary);">Revised Score:</strong>
                  <span style="color: #f8b4ae; font-size: 18px; margin-left: 8px;">${validationResult.revisedScore}/10</span>
                  <span style="color: #f8b4ae; margin-left: 4px;">‚¨áÔ∏è ${validationResult.scoreChange}</span>
                </div>
              </div>
            </div>

            <div style="margin-bottom: 16px;">
              <strong style="color: var(--text-primary);">Contradicted Claims:</strong>
              <div style="margin-top: 8px;">`;

        validationResult.contradictions.forEach(c => {
          validationHTML += `
                <div style="background: rgba(0, 0, 0, 0.2); border-left: 3px solid #f8b4ae; padding: 12px; margin-bottom: 8px; border-radius: 4px;">
                  <div style="color: var(--text-primary); margin-bottom: 4px;">
                    <span style="color: #f8b4ae;">‚úó</span> "${c.claim}"
                  </div>
                  <div style="color: var(--text-secondary); font-size: 13px; margin-left: 20px;">
                    Conflicts with: "${c.constraint}"
                  </div>
                </div>`;
        });

        validationHTML += `
              </div>
            </div>`;

        if (validationResult.validClaims && validationResult.validClaims.length > 0) {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <strong style="color: var(--text-primary);">Valid Claims Remaining:</strong>
              <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                ${validationResult.validClaims.join(', ')}
              </div>
            </div>`;
        } else {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: #f8b4ae;">
              ‚ö†Ô∏è No valid power-up claims remain after constraint validation
            </div>`;
        }

        validationHTML += `
            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
              <strong>Routing:</strong> ${validationResult.scoreChange <= -3 ? 'Score dropped significantly - REDESIGN RECOMMENDED' : 'Proceeding with revised score'}
            </div>
          </div>
        `;

        if (validationContainer) {
          validationContainer.innerHTML = validationHTML;
          validationContainer.classList.remove('hidden');
        }
      } else if (validationContainer) {
        validationContainer.classList.add('hidden');
      }

      document.getElementById('utilityScoreDisplay').textContent = `${analysis.utility_score}/10`;
      document.getElementById('utilityCategoryDisplay').textContent = analysis.utility_category.replace('_', ' ');
      document.getElementById('powerUpStatement').textContent = analysis.power_up_statement;
      document.getElementById('utilityReasoning').textContent = analysis.reasoning;

      // Hide all routing sections first
      document.getElementById('utilityProceedSection').classList.add('hidden');
      document.getElementById('utilityRedesignSection').classList.add('hidden');
      document.getElementById('utilityRejectSection').classList.add('hidden');

      // Show appropriate section based on routing
      if (analysis.phase_routing === 'PROCEED') {
        document.getElementById('utilityProceedSection').classList.remove('hidden');
        document.getElementById('researchDirection').textContent = analysis.research_direction;
      } else if (analysis.phase_routing === 'REDESIGN' || analysis.phase_routing === 'REJECT') {
        // For MEDIUM and LOW utility, run Problem Identifier Agent
        addLog('Deploying Problem Identifier Agent...', 'info');

        // Show loading state
        const targetSection = analysis.phase_routing === 'REDESIGN' ?
                             'utilityRedesignSection' : 'utilityRejectSection';
        document.getElementById(targetSection).classList.remove('hidden');
        const containerDiv = analysis.phase_routing === 'REDESIGN' ?
                            document.getElementById('redesignOptions') :
                            document.getElementById('rejectAlternatives');
        containerDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Analyzing real problems in this domain...<span class="loading-spinner"></span></p>';

        try {
          // Run problem analysis
          const problemAnalysis = await analyzeProblem(currentRequirements, analysis);
          problemAnalysisResult = problemAnalysis;

          // Display problem-grounded results
          displayProblemAnalysis(problemAnalysis, analysis);
        } catch (err) {
          addLog('Problem analysis encountered an error, showing basic redesigns', 'warning');
          // Fallback to basic redesigns
          displayBasicRedesigns(analysis);
        }
      }

      // Color code the score display
      const scoreDisplay = document.getElementById('utilityScoreDisplay');
      if (analysis.utility_score >= 7) {
        scoreDisplay.style.color = 'var(--accent-secondary)';
      } else if (analysis.utility_score >= 4) {
        scoreDisplay.style.color = '#fdd663';
      } else {
        scoreDisplay.style.color = '#f8b4ae';
      }
    }

    function displayProblemAnalysis(problemAnalysis, utilityAnalysis) {
      const isRedesign = utilityAnalysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      const research = problemAnalysis.domain_research;
      const domainAnalysis = problemAnalysis.domain_analysis || {};

      let html = `
        <div style="background: rgba(138, 180, 248, 0.08); border: 1px solid rgba(138, 180, 248, 0.2); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <h3 style="color: var(--accent-primary); margin: 0;">‚ö†Ô∏è Real Problem Identified</h3>
            ${domainAnalysis.user_specified_domain ? `
              <span style="background: rgba(138, 180, 248, 0.15); border: 1px solid rgba(138, 180, 248, 0.4); border-radius: 6px; padding: 4px 10px; font-size: 11px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase; letter-spacing: 0.5px;">
                ${domainAnalysis.user_specified_domain}
              </span>
            ` : ''}
          </div>
      `;

      // Display pain points
      if (research.practitioner_pain_points && research.practitioner_pain_points.length > 0) {
        const painPoint = research.practitioner_pain_points[0];
        html += `
          <div style="margin-bottom: 16px;">
            <strong style="color: var(--text-primary);">Problem:</strong>
            <p style="margin: 8px 0; line-height: 1.6;">${painPoint.problem}</p>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; font-size: 13px;">
            <div>
              <strong style="color: var(--text-secondary);">Current Workaround:</strong>
              <p style="margin: 4px 0;">${painPoint.current_workaround}</p>
            </div>
            <div>
              <strong style="color: var(--text-secondary);">Cost:</strong>
              <p style="margin: 4px 0;">${painPoint.cost_of_problem}</p>
            </div>
          </div>
        `;
      }

      html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <strong style="color: var(--text-primary);">Claude Capability Gap:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--text-secondary);">${research.claude_capability_gap}</p>
          </div>
          <div style="margin-top: 12px;">
            <strong style="color: var(--text-primary);">Value Unlock:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--accent-secondary);">${research.value_unlock}</p>
          </div>
        </div>
      `;

      // Display redesign suggestions
      html += '<h3 style="margin: 24px 0 16px 0;">Problem-Grounded Redesigns</h3>';

      if (problemAnalysis.redesign_suggestions && problemAnalysis.redesign_suggestions.length > 0) {
        problemAnalysis.redesign_suggestions.forEach((suggestion, index) => {
          const scoreColor = suggestion.estimated_utility_score >= 8 ? 'var(--accent-secondary)' : '#fdd663';
          const domainRelevanceScore = suggestion.domain_relevance_score || 'N/A';
          const domainRelevanceColor = domainRelevanceScore >= 8 ? 'var(--accent-secondary)' : domainRelevanceScore >= 7 ? '#fdd663' : '#f8b4ae';

          html += `
            <div style="background: rgba(30, 33, 39, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 16px; cursor: pointer; transition: all 0.3s ease;"
                 onmouseover="this.style.borderColor='var(--accent-primary)'; this.style.background='rgba(138, 180, 248, 0.08)';"
                 onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.background='rgba(30, 33, 39, 0.6)';"
                 onclick='selectRedesign("${suggestion.redesigned_skill.replace(/"/g, '&quot;')}")'>
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px; gap: 8px;">
                <div style="flex: 1;">
                  <h4 style="color: var(--accent-primary); margin: 0 0 8px 0; font-size: 16px;">${suggestion.redesigned_skill}</h4>
                  ${domainAnalysis.user_specified_domain ? `
                    <div style="display: inline-flex; align-items: center; gap: 6px;">
                      <span style="background: rgba(138, 180, 248, 0.12); border: 1px solid rgba(138, 180, 248, 0.3); border-radius: 4px; padding: 2px 8px; font-size: 10px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase;">
                        ${domainAnalysis.user_specified_domain}
                      </span>
                      <span style="color: ${domainRelevanceColor}; font-size: 10px; font-weight: 600;">
                        Domain Fit: ${domainRelevanceScore}/10
                      </span>
                    </div>
                  ` : ''}
                </div>
                <div style="background: ${scoreColor}20; border: 1px solid ${scoreColor}; border-radius: 8px; padding: 4px 12px; font-size: 12px; font-weight: 600; color: ${scoreColor}; white-space: nowrap;">
                  ${suggestion.estimated_utility_score}/10 ‚¨ÜÔ∏è
                </div>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Solves:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.problem_it_solves}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Power-up:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6; color: var(--accent-primary);">${suggestion.claude_power_up}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Outcome:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.measurable_outcome}</p>
              </div>
              ${suggestion.domain_fit_explanation ? `
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Domain Fit:</strong>
                <p style="margin: 4px 0; font-size: 13px; line-height: 1.5; color: var(--accent-primary);">${suggestion.domain_fit_explanation}</p>
              </div>
              ` : ''}
              <div style="background: rgba(10, 11, 13, 0.4); border-radius: 8px; padding: 12px; margin-top: 12px;">
                <strong style="color: var(--text-secondary); font-size: 12px;">Implementation:</strong>
                <p style="margin: 4px 0; font-size: 13px; font-family: 'SF Mono', monospace; line-height: 1.5;">${suggestion.specific_implementation}</p>
              </div>
            </div>
          `;
        });
      }

      containerDiv.innerHTML = html;
    }

    function displayBasicRedesigns(analysis) {
      const isRedesign = analysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      containerDiv.innerHTML = '';

      if (analysis.recommended_redesigns && analysis.recommended_redesigns.length > 0) {
        analysis.recommended_redesigns.forEach((redesign, index) => {
          const btn = document.createElement('button');
          btn.className = 'example-btn';
          btn.textContent = `‚Üí ${redesign}`;
          btn.style.marginBottom = '12px';
          btn.onclick = () => selectRedesign(redesign);
          containerDiv.appendChild(btn);
        });
      }
    }

    function selectRedesign(redesign) {
      // Populate input field with suggested skill
      document.getElementById('skillInput').value = redesign;

      // Trigger new factory analysis instead of resetting
      addLog(`Running analysis for suggested skill: ${redesign}`, 'info');
      startGeneration();
    }

    // ============================================================
    // AUTO-VALIDATION & SELF-REDESIGN LOOP
    // ============================================================

    // Helper: Parse YAML metadata string into flat object for validation
    function parseMetadataYAML(yamlString) {
      const obj = {};
      const lines = yamlString.split('\n');
      let inMetadataSection = false;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) continue;

        if (trimmed === 'metadata:') {
          inMetadataSection = true;
          continue;
        }

        // Parse root-level fields (name, description)
        if (!inMetadataSection) {
          const match = trimmed.match(/^([a-z-]+):\s*"?(.+?)"?$/);
          if (match) {
            const key = match[1];
            let value = match[2];
            // Remove quotes if present
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            obj[key] = value;
          }
        } else {
          // Parse nested metadata fields (version, complexity, etc.)
          const match = trimmed.match(/^([a-z-]+):\s*"?(.+?)"?$/);
          if (match) {
            const key = match[1];
            let value = match[2];
            // Remove quotes if present
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            obj[key] = value;
          }
        }
      }

      return obj;
    }

    // Helper: Convert flat metadata object back to YAML string
    function metadataObjectToYAML(obj) {
      // Separate root-level and metadata fields
      const rootFields = ['name', 'description', 'license', 'allowed-tools'];
      const metadataFields = ['version', 'complexity', 'author', 'constraints', 'tags'];

      const lines = [];

      // Add root-level fields
      if (obj.name) {
        lines.push(`name: ${obj.name}`);
      }
      if (obj.description) {
        const safeDesc = sanitizeForYAML(obj.description);
        lines.push(`description: "${safeDesc}"`);
      }
      if (obj.license) {
        lines.push(`license: ${obj.license}`);
      }
      if (obj['allowed-tools']) {
        lines.push(`allowed-tools: ${obj['allowed-tools']}`);
      }

      // Add metadata section
      const metadataEntries = {};
      for (const field of metadataFields) {
        if (obj[field]) {
          metadataEntries[field] = obj[field];
        }
      }

      if (Object.keys(metadataEntries).length > 0) {
        lines.push('metadata:');
        for (const [key, value] of Object.entries(metadataEntries)) {
          const safeValue = sanitizeForYAML(String(value));
          lines.push(`  ${key}: "${safeValue}"`);
        }
      }

      return lines.join('\n');
    }

    const SKILL_VALIDATION_RULES = {
      power_up_honest: {
        name: 'Power-up Honesty',
        description: 'Power-up claim matches actual capability gap',
        check: checkPowerUpHonesty,
        fixable: true,
        auto_fix: fixPowerUpHonesty
      },

      focused_scope: {
        name: 'Focused Scope',
        description: 'Skill scope is 1-2 topics, not 5+',
        check: checkFocusedScope,
        fixable: true,
        auto_fix: fixFocusedScope
      },

      progressive_disclosure: {
        name: 'Progressive Disclosure',
        description: 'Main SKILL.md under 200 lines, secondary content separated',
        check: checkProgressiveDisclosure,
        fixable: true,
        auto_fix: fixProgressiveDisclosure
      },

      constraint_clarity: {
        name: 'Constraint Clarity',
        description: 'Constraints reframed as responsibility boundaries',
        check: checkConstraintClarity,
        fixable: true,
        auto_fix: fixConstraintClarity
      },

      dependencies_documented: {
        name: 'Dependencies Documented',
        description: 'All version requirements and prerequisites listed',
        check: checkDependenciesDocumented,
        fixable: true,
        auto_fix: fixDependenciesDocumented
      },

      metadata_complete: {
        name: 'Metadata Complete',
        description: 'All metadata fields present and valid',
        check: checkMetadataComplete,
        fixable: true,
        auto_fix: fixMetadataComplete
      }
    };

    // ============================================================
    // CHECK FUNCTIONS
    // ============================================================

    function checkPowerUpHonesty(skillPackage) {
      const { metadata, documentation } = skillPackage;

      // Extract power-up claims from description
      const description = metadata.description || '';
      const lowerDesc = description.toLowerCase();

      // Check for overpromising keywords
      const overPromisePatterns = [
        'executable validation tools',
        'automated testing',
        'real-time',
        'live testing',
        'device testing',
        'interactive testing'
      ];

      // Check for contradictions with limitations
      const hasLimitations = documentation.toLowerCase().includes('limitations') ||
                            documentation.toLowerCase().includes('cannot') ||
                            documentation.toLowerCase().includes('does not');

      const hasOverPromise = overPromisePatterns.some(pattern => lowerDesc.includes(pattern));

      if (hasOverPromise && hasLimitations) {
        return {
          pass: false,
          issue: `Power-up statement may overpromise capabilities. Found claims like "executable validation" but documentation lists limitations.`,
          severity: 'high'
        };
      }

      return { pass: true };
    }

    function checkFocusedScope(skillPackage) {
      const { documentation } = skillPackage;

      // Count distinct major topics by looking for ## headings
      const headings = documentation.match(/^##\s+(.+)$/gm) || [];
      const topics = headings.map(h => h.replace(/^##\s+/, '').trim());

      // Common topic categories to detect
      const topicCategories = {
        colors: ['color', 'palette', 'theme'],
        components: ['component', 'widget', 'control'],
        testing: ['test', 'validation', 'verify'],
        migration: ['migrat', 'upgrad', 'transition'],
        accessibility: ['accessibility', 'a11y', 'voiceover'],
        architecture: ['architect', 'structure', 'pattern'],
        performance: ['performance', 'optimiz', 'efficiency']
      };

      // Identify which categories are present
      const categoriesFound = new Set();
      topics.forEach(topic => {
        const lowerTopic = topic.toLowerCase();
        Object.entries(topicCategories).forEach(([category, keywords]) => {
          if (keywords.some(kw => lowerTopic.includes(kw))) {
            categoriesFound.add(category);
          }
        });
      });

      if (categoriesFound.size > 3) {
        return {
          pass: false,
          issue: `Skill covers too many topics (${categoriesFound.size}): ${Array.from(categoriesFound).join(', ')}. Should focus on 1-2 core topics.`,
          severity: 'high',
          metadata: { topics: Array.from(categoriesFound) }
        };
      }

      return { pass: true };
    }

    function checkProgressiveDisclosure(skillPackage) {
      const { documentation } = skillPackage;

      // Count lines in documentation
      const lines = documentation.split('\n').length;

      if (lines > 200) {
        return {
          pass: false,
          issue: `Documentation is ${lines} lines, exceeds 200 line target. Consider splitting into multiple files.`,
          severity: 'medium',
          metadata: { lineCount: lines }
        };
      }

      return { pass: true };
    }

    function checkConstraintClarity(skillPackage) {
      const { documentation } = skillPackage;

      const lowerDoc = documentation.toLowerCase();

      // Check for negative constraint framing (bad)
      const negativePatterns = [
        'cannot test on actual',
        'cannot access real',
        'unable to',
        'does not support',
        'not possible'
      ];

      // Check for responsibility boundary framing (good)
      const boundaryPatterns = [
        'claude responsibility',
        'user responsibility',
        'you implement',
        'you test',
        'claude generates',
        'claude provides'
      ];

      const hasNegativeFraming = negativePatterns.some(p => lowerDoc.includes(p));
      const hasBoundaryFraming = boundaryPatterns.some(p => lowerDoc.includes(p));

      if (hasNegativeFraming && !hasBoundaryFraming) {
        return {
          pass: false,
          issue: `Constraints use negative framing ("cannot", "unable") instead of clear responsibility boundaries.`,
          severity: 'medium'
        };
      }

      return { pass: true };
    }

    function checkDependenciesDocumented(skillPackage) {
      const { documentation, requirements } = skillPackage;

      const lowerDoc = documentation.toLowerCase();

      // Check if skill mentions versions/requirements
      const hasVersionRequirements = lowerDoc.includes('requires') ||
                                     lowerDoc.includes('prerequisite') ||
                                     lowerDoc.includes('## requirements') ||
                                     lowerDoc.includes('## dependencies');

      // If language-specific, should document version requirements
      const language = requirements.programming_language;
      if (language && language.toLowerCase() !== 'general') {
        if (!hasVersionRequirements) {
          return {
            pass: false,
            issue: `Language-specific skill (${language}) should document version requirements and prerequisites.`,
            severity: 'low'
          };
        }
      }

      return { pass: true };
    }

    function checkMetadataComplete(skillPackage) {
      const { metadata } = skillPackage;

      const requiredFields = ['name', 'description', 'version', 'complexity'];
      const missingFields = requiredFields.filter(field => !metadata[field]);

      if (missingFields.length > 0) {
        return {
          pass: false,
          issue: `Missing required metadata fields: ${missingFields.join(', ')}`,
          severity: 'high',
          metadata: { missingFields }
        };
      }

      // Check if constraints are documented in metadata
      if (!metadata.constraints) {
        return {
          pass: false,
          issue: `Metadata should include 'constraints' field documenting limitations.`,
          severity: 'medium'
        };
      }

      return { pass: true };
    }

    // ============================================================
    // AUTO-FIX FUNCTIONS
    // ============================================================

    async function fixPowerUpHonesty(skillPackage) {
      addLog('Auto-fixing: Rewriting power-up statement to match actual capabilities...', 'info');

      const { metadata, documentation, requirements } = skillPackage;

      // Use Claude to rewrite the description to be more honest
      const prompt = `You are fixing a skill's power-up statement to be honest about capabilities.

CURRENT DESCRIPTION: "${metadata.description}"

SKILL DOCUMENTATION EXCERPT:
${documentation.substring(0, 500)}

CONSTRAINTS FROM VALIDATION:
- Claude cannot execute validation tools or test on actual devices
- Claude CAN provide: templates, patterns, frameworks, analysis, recommendations
- Claude CANNOT provide: real-time testing, device testing, executable validation

Rewrite the description to accurately reflect what Claude provides (knowledge, patterns, templates) without promising execution capabilities.

Return ONLY the rewritten description (max 200 chars), nothing else.`;

      try {
        const newDescription = await callClaude(prompt, 300);
        metadata.description = newDescription.trim().replace(/^["']|["']$/g, '');
        addLog(`‚úì Power-up rewritten: "${metadata.description}"`, 'success');
      } catch (err) {
        addLog(`‚ö†Ô∏è Auto-fix failed, using fallback`, 'warning');
        // Fallback: Generic safe description
        metadata.description = `${requirements.skill_name} implementation patterns and best practices for ${requirements.programming_language || 'development'}`;
      }

      return skillPackage;
    }

    async function fixFocusedScope(skillPackage) {
      addLog('Auto-fixing: Skill scope too broad, adding focus note...', 'warning');

      // Note: Auto-splitting into separate skills is complex and requires user decision
      // For now, we'll add a note to the documentation to help users navigate

      // Add a note about scope
      const note = `> **Scope Note:** This skill covers multiple topics. Focus on the sections most relevant to your current task.\n\n`;
      skillPackage.documentation = note + skillPackage.documentation;

      addLog('‚úì Added scope navigation note to documentation', 'success');
      return skillPackage;
    }

    async function fixProgressiveDisclosure(skillPackage) {
      addLog('Auto-fixing: Documentation too long, adding structure note...', 'info');

      // Check if progressive disclosure note already exists
      if (skillPackage.documentation.includes('**Progressive Disclosure:**')) {
        addLog('‚úì Navigation note already exists, skipping', 'success');
        return skillPackage;
      }

      // Add a progressive disclosure note
      const note = `> **Progressive Disclosure:** This documentation is comprehensive. Use Ctrl+F to find specific sections.\n\n`;
      skillPackage.documentation = note + skillPackage.documentation;

      addLog('‚úì Added navigation note for long documentation', 'success');
      return skillPackage;
    }

    async function fixConstraintClarity(skillPackage) {
      addLog('Auto-fixing: Reframing constraints as responsibility boundaries...', 'info');

      const { documentation } = skillPackage;

      // Use Claude to reframe constraints
      const prompt = `You are reframing constraints in a skill's documentation to be clearer about responsibility boundaries.

CURRENT DOCUMENTATION (first 800 chars):
${documentation.substring(0, 800)}

Find any negative constraint language like "cannot", "unable to", "does not support" and reframe them as:

**Responsibility Boundaries:**
- **Claude provides:** [what Claude does - patterns, templates, analysis]
- **You implement:** [what user does - testing, deployment, integration]
- **Claude is halted by:** [technical limitations stated positively]

Return ONLY the "Responsibility Boundaries" section (markdown format), nothing else.`;

      try {
        const boundariesSection = await callClaude(prompt, 400);

        // Find limitations section and replace or add boundaries section
        if (documentation.includes('## Limitations')) {
          skillPackage.documentation = documentation.replace(
            /## Limitations[\s\S]*?(?=##|$)/,
            `## Limitations\n\n${boundariesSection}\n\n`
          );
        } else {
          // Add before examples section or at end
          const insertPoint = documentation.indexOf('## Examples');
          if (insertPoint > -1) {
            skillPackage.documentation = documentation.substring(0, insertPoint) +
              `## Limitations\n\n${boundariesSection}\n\n` +
              documentation.substring(insertPoint);
          } else {
            skillPackage.documentation = documentation + `\n\n## Limitations\n\n${boundariesSection}\n`;
          }
        }

        addLog('‚úì Constraints reframed as responsibility boundaries', 'success');
      } catch (err) {
        addLog('‚ö†Ô∏è Auto-fix failed, using fallback', 'warning');
        // Fallback: Add generic boundaries
        const fallback = `\n\n## Responsibility Boundaries\n\n**Claude provides:** Implementation patterns, code templates, and best practices guidance.\n\n**You implement:** Integration with your project, testing, and deployment.\n`;
        skillPackage.documentation += fallback;
      }

      return skillPackage;
    }

    async function fixDependenciesDocumented(skillPackage) {
      addLog('Auto-fixing: Adding dependencies section...', 'info');

      const { requirements } = skillPackage;

      // Create a requirements section
      const reqSection = `\n\n## Requirements\n\n`;

      if (requirements.programming_language && requirements.programming_language !== 'general') {
        const lang = requirements.programming_language;
        skillPackage.documentation = reqSection +
          `- **Language:** ${lang}\n` +
          `- **Version:** Latest stable release recommended\n` +
          (requirements.required_apis ? `- **APIs/Libraries:** ${requirements.required_apis.join(', ')}\n` : '') +
          `\n` +
          skillPackage.documentation;
      } else {
        skillPackage.documentation = reqSection +
          `- **Environment:** General development environment\n` +
          (requirements.required_apis ? `- **Tools:** ${requirements.required_apis.join(', ')}\n` : '') +
          `\n` +
          skillPackage.documentation;
      }

      addLog('‚úì Dependencies section added', 'success');
      return skillPackage;
    }

    async function fixMetadataComplete(skillPackage) {
      addLog('Auto-fixing: Completing metadata fields...', 'info');

      const { metadata } = skillPackage;

      // Fill in missing required fields
      if (!metadata.version) {
        metadata.version = '1.0.0';
      }

      if (!metadata.complexity) {
        // Infer from documentation length
        const docLength = skillPackage.documentation.length;
        metadata.complexity = docLength > 3000 ? 'complex' : docLength > 1500 ? 'moderate' : 'simple';
      }

      if (!metadata.author) {
        metadata.author = 'Skill Factory';
      }

      if (!metadata.constraints) {
        // Extract from documentation or use default
        const docLower = skillPackage.documentation.toLowerCase();
        if (docLower.includes('limitations') || docLower.includes('cannot')) {
          metadata.constraints = 'See Limitations section in documentation';
        } else {
          metadata.constraints = 'Claude provides patterns and templates. User implements and tests.';
        }
      }

      addLog('‚úì Metadata completed', 'success');
      return skillPackage;
    }

    // ============================================================
    // SAFETY ASSESSMENT (v2.1)
    // ============================================================

    function assessSkillSafety(skillPackage) {
      /**
       * Assesses safety of executor skills for agentic execution
       * Returns safety level and any warnings/adjustments needed
       */
      const assessment = {
        level: 'safe',
        utilityAdjustment: 0,
        warnings: []
      };

      // Only assess EXECUTOR skills with agentic subtype
      if (skillPackage.category !== 'EXECUTOR' || skillPackage.executor_subtype !== 'agentic') {
        return assessment;
      }

      const codeContent = JSON.stringify(skillPackage.scripts || skillPackage.content || '');

      // Check for unsafe patterns
      const unsafePatterns = [
        { pattern: /rm\s+-rf\s+\/(?!tmp|var\/tmp)/gi, desc: 'Dangerous file deletion outside safe directories' },
        { pattern: /sudo\s+/gi, desc: 'Privileged operations not allowed in sandbox' },
        { pattern: /eval\s*\(/gi, desc: 'Code injection risk with eval()' },
        { pattern: /exec\s*\(/gi, desc: 'Arbitrary code execution risk' },
        { pattern: /connect.*production/gi, desc: 'Production system access not allowed' },
        { pattern: /--force|--no-verify/gi, desc: 'Bypass safety checks' }
      ];

      for (const { pattern, desc } of unsafePatterns) {
        if (pattern.test(codeContent)) {
          assessment.level = 'unsafe';
          assessment.utilityAdjustment = -10; // Force rejection
          assessment.warnings.push(`‚ö†Ô∏è UNSAFE: ${desc}`);
        }
      }

      // Check for semi-safe patterns (need extra caution)
      if (assessment.level === 'safe') {
        const semiSafePatterns = [
          { pattern: /api[_\s]*key/gi, desc: 'API key handling - ensure proper secrets management' },
          { pattern: /password|credential/gi, desc: 'Credential management - ensure secure handling' },
          { pattern: /DELETE\s+FROM|DROP\s+TABLE/gi, desc: 'Data deletion operations' },
          { pattern: /\$\(.*\)/g, desc: 'Shell command substitution - verify input sanitization' }
        ];

        for (const { pattern, desc } of semiSafePatterns) {
          if (pattern.test(codeContent)) {
            assessment.level = 'semi-safe';
            assessment.warnings.push(`‚ö†Ô∏è CAUTION: ${desc}`);
          }
        }
      }

      // Bonus for verified safe sandbox operations
      if (assessment.level === 'safe') {
        const safeIndicators = [
          /ffmpeg\s+-i/gi,
          /python3?\s+/gi,
          /imagemagick|convert\s+/gi,
          /jq\s+/gi,
          /awk|sed/gi
        ];

        const hasSafeOps = safeIndicators.some(pattern => pattern.test(codeContent));
        if (hasSafeOps) {
          assessment.utilityAdjustment = 1; // Small bonus for verified safe operations
        }
      }

      return assessment;
    }

    // ============================================================
    // VALIDATION LOOP ORCHESTRATION
    // ============================================================

    async function validateSkillPackage(skillPackage) {
      const results = {
        allPass: true,
        failures: [],
        passes: [],
        safetyAssessment: null
      };

      // Run safety assessment for executor skills (v2.1)
      if (skillPackage.category === 'EXECUTOR') {
        const safety = assessSkillSafety(skillPackage);
        results.safetyAssessment = safety;

        if (safety.level === 'unsafe') {
          results.allPass = false;
          results.failures.push({
            rule: 'safety_assessment',
            name: 'Safety Assessment',
            issue: `Unsafe patterns detected: ${safety.warnings.join(', ')}`,
            severity: 'high',
            fixable: false
          });
        } else if (safety.level === 'semi-safe') {
          addLog(`‚ö†Ô∏è Safety warnings: ${safety.warnings.join(', ')}`, 'warning');
        }
      }

      for (const [ruleKey, rule] of Object.entries(SKILL_VALIDATION_RULES)) {
        const result = rule.check(skillPackage);

        if (result.pass) {
          results.passes.push({
            rule: ruleKey,
            name: rule.name
          });
        } else {
          results.allPass = false;
          results.failures.push({
            rule: ruleKey,
            name: rule.name,
            issue: result.issue,
            severity: result.severity,
            fixable: rule.fixable,
            auto_fix: rule.auto_fix,
            metadata: result.metadata
          });
        }
      }

      return results;
    }

    async function generateWithAutoValidation(requirements, research) {
      addLog('Starting generation with auto-validation loop...', 'info');

      // Extract research components (research now includes findings and resources)
      const researchFindings = typeof research === 'string' ? research : research.findings;
      const resourceData = research.resourceData || null;

      // Initial generation (returns YAML string)
      let metadataYAML = await generateMetadata(requirements, researchFindings);
      let documentation = await generateDocumentation(requirements, researchFindings, metadataYAML, resourceData);

      // Parse YAML metadata into object for validation
      let metadataObj = parseMetadataYAML(metadataYAML);
      let skillPackage = { metadata: metadataObj, documentation, requirements };

      // Validation loop
      const maxAttempts = 3;
      let attempt = 0;

      while (attempt < maxAttempts) {
        attempt++;
        addLog(`Validation attempt ${attempt}/${maxAttempts}...`, 'info');

        const validation = await validateSkillPackage(skillPackage);

        // Log passed checks
        if (validation.passes.length > 0) {
          addLog(`‚úì Passed: ${validation.passes.map(p => p.name).join(', ')}`, 'success');
        }

        if (validation.allPass) {
          addLog('üéâ All validation checks passed! Skill is production-ready.', 'success');

          // Convert metadata object back to YAML string for packaging
          skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

          return {
            status: 'production_ready',
            skillPackage,
            attempt
          };
        }

        // Log failures
        addLog(`Found ${validation.failures.length} issue(s) to fix:`, 'warning');
        validation.failures.forEach(failure => {
          addLog(`  ‚úó ${failure.name}: ${failure.issue}`, 'warning');
        });

        // Try to auto-fix
        let fixedAny = false;
        for (const failure of validation.failures) {
          if (failure.fixable && failure.auto_fix) {
            try {
              skillPackage = await failure.auto_fix(skillPackage);
              fixedAny = true;
            } catch (err) {
              addLog(`‚ö†Ô∏è Auto-fix failed for ${failure.name}: ${err.message}`, 'error');
            }
          } else {
            addLog(`‚ö†Ô∏è Cannot auto-fix: ${failure.name}`, 'warning');
          }
        }

        if (!fixedAny) {
          addLog('No fixes could be applied. Proceeding with current version.', 'warning');

          // Convert metadata object back to YAML string for packaging
          skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

          return {
            status: 'partially_validated',
            skillPackage,
            attempt,
            remainingIssues: validation.failures
          };
        }
      }

      // Max attempts reached
      addLog(`‚ö†Ô∏è Reached maximum validation attempts (${maxAttempts}). Proceeding with best version.`, 'warning');

      // Convert metadata object back to YAML string for packaging
      skillPackage.metadata = metadataObjectToYAML(skillPackage.metadata);

      return {
        status: 'max_attempts_reached',
        skillPackage,
        attempt: maxAttempts
      };
    }

    // ============================================================
    // END AUTO-VALIDATION & SELF-REDESIGN LOOP
    // ============================================================

    async function continueToResearch() {
      if (!currentRequirements || !utilityAnalysisResult) {
        addLog('Missing requirements or utility analysis', 'error');
        return;
      }

      if (isGenerating) {
        addLog('Generation already in progress', 'warning');
        return;
      }

      try {
        isGenerating = true;
        document.getElementById('utilityCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');

        setStep(3); // Research phase (now step 3 instead of 2)
        const research = await conductResearch(currentRequirements);

        setStep(4); // Generate phase with auto-validation loop (now step 4 instead of 3)
        const result = await generateWithAutoValidation(currentRequirements, research);

        // Log auto-validation result
        if (result.status === 'production_ready') {
          addLog(`‚úì Auto-validation succeeded in ${result.attempt} attempt(s)`, 'success');
        } else if (result.status === 'partially_validated') {
          addLog(`‚ö†Ô∏è Partial validation after ${result.attempt} attempt(s). ${result.remainingIssues.length} issue(s) remain.`, 'warning');
        } else {
          addLog(`‚ö†Ô∏è Max validation attempts reached. Proceeding with best version.`, 'warning');
        }

        const skillPackage = result.skillPackage;

        setStep(5); // Final validation phase (now step 5 instead of 4)
        const validation = await validateGeneration(skillPackage);

        if (validation.issues.length > 0) {
          throw new Error(`Validation failed: ${validation.issues.join(', ')}`);
        }

        setStep(6); // Package phase (now step 6 instead of 5)
        const resourceData = research.resourceData || null;
        const pkg = await packageSkill(skillPackage, currentRequirements.skill_name, resourceData);

        // NEW: Stage 7 - Test the skill with Claude
        addLog('Starting skill testing phase...', 'info');
        const testResults = await stage7_testSkill(skillPackage, currentRequirements);

        // NEW: Stage 8 - Iterate if needed based on test results
        const iterationResult = await stage8_iterateIfNeeded(
          skillPackage,
          testResults,
          currentRequirements,
          0
        );

        // Use the final skill from iteration result (may be refined)
        const finalSkill = iterationResult.finalSkill || skillPackage;
        const finalTestResults = iterationResult.testResults || testResults;

        // Build comprehensive metadata
        const skillMetadata = {
          skill_name: currentRequirements.skill_name,
          description: currentRequirements.description,
          created: new Date().toISOString(),
          viability_score: currentRequirements.viability_check?.viability_score || 0,
          test_pass_rate: finalTestResults.passRate,
          tests_passed: finalTestResults.passedTests,
          tests_total: finalTestResults.totalTests,
          iterations: iterationResult.iterations || 0,
          status: iterationResult.status,
          research_sources: research.domainKnowledge ?
            Object.values(research.domainKnowledge)
              .flatMap(r => r.sources || [])
              .filter(s => s && s !== 'web-research') : [],
          resources: {
            scripts: resourceData ? Object.keys(resourceData.resources.scripts) : [],
            references: resourceData ? Object.keys(resourceData.resources.references) : [],
            assets: resourceData ? Object.keys(resourceData.resources.assets) : []
          }
        };

        // Re-package with final skill and metadata
        const finalPkg = await packageSkill(
          finalSkill,
          currentRequirements.skill_name,
          resourceData,
          skillMetadata
        );

        // Pre-format the prompt for clipboard (to avoid async operations during copy)
        const skillContent = `---\n${finalSkill.metadata}\n---\n\n${finalSkill.documentation}`;
        const promptForClipboard = `You are now equipped with the following skill:

---
${skillContent}
---

When the user asks questions or requests tasks related to the topics covered in this skill, use the knowledge and guidelines from this skill to assist them.`;

        // Store test results in package
        generatedSkillData = {
          package: finalPkg.content,
          filename: finalPkg.filename,
          tree: finalPkg.tree,
          validation,
          testResults: finalTestResults,
          iterationResult: iterationResult,
          metadata: skillMetadata,
          promptForClipboard: promptForClipboard
        };

        // Add to skill registry
        addToSkillRegistry(skillMetadata);

        // Update validation with test results
        validation.testPassRate = `${(finalTestResults.passRate * 100).toFixed(0)}%`;
        validation.testsPassed = `${finalTestResults.passedTests}/${finalTestResults.totalTests}`;
        validation.iterations = iterationResult.iterations || 0;

        showResults(validation, finalPkg.tree, finalPkg.filename);
        addLog('üéâ Skill generation complete!', 'success');

        if (finalTestResults.passRate < 0.8) {
          addLog(`‚ö†Ô∏è Note: Skill passed ${finalTestResults.passedTests}/${finalTestResults.totalTests} tests. Consider refining.`, 'warning');
        } else {
          addLog(`‚úì Quality validated: ${finalTestResults.passedTests}/${finalTestResults.totalTests} tests passed`, 'success');
        }

        if (iterationResult.iterations > 0) {
          addLog(`üîÑ Completed ${iterationResult.iterations} iteration(s) to improve quality`, 'info');
        }

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
      }
    }

    function proceedAnyway() {
      addLog('Proceeding with MEDIUM_UTILITY skill...', 'warning');
      continueToResearch();
    }

    async function conductResearch(requirements) {
      addLog('Starting research pipeline...', 'info');
      updateProgress('Research', 10, 'Researching domain knowledge...');

      // NEW: Stage 1 Enhancement - Web Research
      const domainKnowledge = await researchDomain(requirements.skill_name);

      updateProgress('Research', 30, 'Gathering resources and examples...');

      // NEW: Stage 3 - Resource Gathering (replaces knowledge enhancement)
      const resourceData = await stage3_gatherResourcesAndExamples(requirements, domainKnowledge);

      updateProgress('Research', 60, 'Synthesizing research...');

      // Check if we have knowledge enhancement results
      const hasEnhancement = utilityAnalysisResult && utilityAnalysisResult.knowledge_enhancement;

      // NEW: Incorporate resource gathering results
      const examplesText = resourceData.examples.map(ex =>
        `- ${ex.title}: ${ex.scenario}`
      ).join('\n');

      const resourceSummary = `
GATHERED RESOURCES:
- Examples: ${resourceData.examples.length}
- Scripts: ${Object.keys(resourceData.resources.scripts).length}
- References: ${Object.keys(resourceData.resources.references).length}
- Assets: ${Object.keys(resourceData.resources.assets).length}

REAL-WORLD EXAMPLES FOUND:
${examplesText || 'None'}
`;

      let prompt;
      if (hasEnhancement) {
        const enhancement = utilityAnalysisResult.knowledge_enhancement;
        prompt = `Research for creating an ENHANCED KNOWLEDGE Claude Code Skill:

ORIGINAL CONCEPT: ${requirements.original_skill_name || requirements.skill_name}
ENHANCED CONCEPT: ${requirements.skill_name}

KNOWLEDGE ENHANCEMENT RESULTS:
- Enhanced Concept: ${enhancement.enhancedConcept}
- Value Proposition: ${enhancement.valueProposition}
- Research Summary: ${enhancement.researchSummary}

KNOWLEDGE DOMAINS TO COVER:
${enhancement.knowledgeDomains.map(d => `- ${d}`).join('\n')}

KEY FRAMEWORKS TO INCLUDE:
${enhancement.keyFrameworks.map(f => `- ${f}`).join('\n')}

EXPERTISE AREAS TO DOCUMENT:
${enhancement.expertiseAreas.map(e => `- ${e}`).join('\n')}

${resourceSummary}

REQUIREMENTS: ${JSON.stringify(requirements, null, 2)}

Provide focused research for implementing this KNOWLEDGE skill (max 1500 tokens):
1. How to structure the knowledge domains as reusable frameworks
2. How to incorporate the gathered real-world examples
3. Specific methodologies and techniques to include
4. Best practices for documenting expert-level insights
5. How to reference the gathered resources (scripts/references/assets)

Focus on crystallizing the expertise identified in the enhancement research.`;
      } else {
        prompt = `Research for creating a Claude Code Skill:

REQUIREMENTS: ${JSON.stringify(requirements, null, 2)}

${resourceSummary}

Provide a focused research summary (max 1000 tokens):
1. How to leverage the gathered examples and resources
2. Key technical details and APIs
3. Best practices and patterns
4. Common challenges and solutions
5. Recommended implementation approach

Be specific and actionable. Reference the gathered resources where appropriate.`;
      }

      try {
        const findings = await callClaude(prompt, hasEnhancement ? 2000 : 1500);
        addLog('Research complete', 'success');
        updateProgress('Research', 100, 'Research synthesis complete');

        // Return comprehensive research package including resources
        return {
          findings: findings,
          resourceData: resourceData,
          domainKnowledge: domainKnowledge
        };
      } catch (err) {
        addLog('Research failed - using template generation', 'warning');
        return {
          findings: 'Limited research available - generating from templates',
          resourceData: resourceData,
          domainKnowledge: domainKnowledge
        };
      }
    }

    function sanitizeForYAML(text) {
      // Escape backslashes and double quotes for safe YAML inclusion
      return text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function generateSafeYAML(name, description, metadata = null) {
      const lines = [];

      // Name (validated, safe without quotes if lowercase-hyphenated)
      lines.push(`name: ${name}`);

      // Description (ALWAYS quote to handle special characters)
      const safeDesc = sanitizeForYAML(description);
      lines.push(`description: "${safeDesc}"`);

      // Metadata (if provided)
      if (metadata && Object.keys(metadata).length > 0) {
        lines.push('metadata:');
        for (const [key, value] of Object.entries(metadata)) {
          // Always quote values to prevent type coercion
          const safeValue = sanitizeForYAML(String(value));
          lines.push(`  ${key}: "${safeValue}"`);
        }
      }

      return lines.join('\n');
    }

    async function generateMetadata(requirements, research) {
      addLog('Generating skill metadata...', 'info');
      updateProgress('Generate', 20, 'Creating YAML metadata...');

      const prompt = `You are generating YAML frontmatter for a Claude Code Skill.

REQUIREMENTS: ${JSON.stringify(requirements)}
RESEARCH: ${research.substring(0, 500)}

CRITICAL YAML RULES:
1. ONLY these keys allowed at root: name, description, license, allowed-tools, metadata
2. Put version, author, tags INSIDE metadata (not at root)
3. Description must include BOTH what it does AND when to use it
4. Return ONLY valid JSON with these exact fields (no YAML, no markdown):

REALITY CONSTRAINTS - NEVER promise these capabilities:
- Real-time data access (prices, inventory, weather) without API key requirement
- Authenticated API calls on user's behalf
- Direct database operations
- Live integrations with external services
- Async/background processing or task queues

WHAT CLAUDE CAN DO:
- Create frameworks, templates, and decision trees
- Generate code examples and architectural patterns
- Analyze and synthesize information
- Provide recommendations based on training data
- Structure workflows and processes

{
  "name": "lowercase-hyphenated-name",
  "description": "What Claude actually does (not aspirational). When to use it (realistic triggers). Mention constraints if external tools needed.",
  "metadata": {
    "version": "1.0.0",
    "complexity": "simple",
    "author": "Skill Factory",
    "constraints": "List any limitations like 'Cannot access real-time data' or 'Requires user to provide API key'"
  }
}

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1000);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);

        // Validate name format
        if (!/^[a-z0-9-]+$/.test(parsed.name)) {
          throw new Error('Invalid name format - must be lowercase with hyphens only');
        }
        if (parsed.name.length > 64) {
          throw new Error('Name exceeds 64 character limit');
        }
        if (parsed.description.length > 1024) {
          throw new Error('Description exceeds 1024 character limit');
        }

        // Generate safe YAML using our sanitization function
        const yaml = generateSafeYAML(parsed.name, parsed.description, parsed.metadata);

        addLog('Metadata generated and validated', 'success');
        return yaml;
      } catch (err) {
        addLog(`Metadata generation failed: ${err.message}`, 'error');
        throw new Error(`Metadata generation failed: ${err.message}`);
      }
    }

    async function generateDocumentation(requirements, research, metadata, resourceData) {
      addLog('Generating documentation...', 'info');
      updateProgress('Generate', 50, 'Writing SKILL.md...');

      // Build resource information section if available
      let resourceInfo = '';
      if (resourceData) {
        const scripts = Object.keys(resourceData.resources.scripts);
        const references = Object.keys(resourceData.resources.references);
        const assets = Object.keys(resourceData.resources.assets);

        if (scripts.length > 0 || references.length > 0 || assets.length > 0) {
          resourceInfo = `

AVAILABLE RESOURCES (to reference in documentation):
${scripts.length > 0 ? `- Scripts: ${scripts.join(', ')}` : ''}
${references.length > 0 ? `- References: ${references.join(', ')}` : ''}
${assets.length > 0 ? `- Assets: ${assets.join(', ')}` : ''}

REAL-WORLD EXAMPLES TO INCORPORATE:
${resourceData.examples.map(ex => `- ${ex.title}: ${ex.scenario}`).join('\n')}
`;
        }
      }

      const prompt = `Write skill documentation (WITHOUT YAML frontmatter).

REQUIREMENTS: ${JSON.stringify(requirements)}
METADATA: ${metadata}
RESEARCH: ${research}${resourceInfo}

CRITICAL - REALITY-BASED DOCUMENTATION:
- Focus on what Claude can ACTUALLY do (frameworks, analysis, code examples)
- If external tools/APIs needed, explicitly state where user must defer
- Never promise real-time data, live integrations, or authenticated API calls
- Include a "Limitations" section if the skill has constraints
- Be honest about what requires user action vs Claude's capabilities

Structure:
# Overview
Brief description of what this skill actually does (not aspirational)

# When to Use
Realistic trigger conditions and keywords

# Key Features
- Feature 1 (what Claude provides)
- Feature 2 (realistic capabilities)

# Limitations (if any)
- What this skill cannot do
- When to use external tools instead
- Required user actions for complete workflows

# Usage Examples
Concrete examples with code showing realistic scenarios

# Implementation Details
Technical approach within Claude's capabilities

# Best Practices
Recommendations and tips for using this skill effectively

Keep under 500 lines. Be specific, practical, and honest about constraints.`;

      try {
        const docs = await callClaude(prompt, 4000);
        addLog('Documentation generated', 'success');
        updateProgress('Generate', 100, 'Generation complete');
        return docs;
      } catch (err) {
        throw new Error(`Documentation generation failed: ${err.message}`);
      }
    }

    async function validateGeneration(skillPackage) {
      addLog('Running validation...', 'info');
      updateProgress('Validate', 30, 'Validating metadata...');

      const validation = {
        yamlValid: false,
        qualityScore: 0,
        issues: [],
        warnings: []
      };

      const hasName = skillPackage.metadata.includes('name:');
      const hasDesc = skillPackage.metadata.includes('description:');

      if (hasName && hasDesc) {
        validation.yamlValid = true;
        addLog('YAML validation passed', 'success');
      } else {
        validation.issues.push('Missing required YAML fields');
        addLog('YAML validation failed', 'error');
      }

      // Constraint validation - check for overselling
      updateProgress('Validate', 60, 'Checking constraint compliance...');
      const fullContent = skillPackage.metadata + '\n' + skillPackage.documentation;
      const redFlags = [
        { pattern: /real-?time (data|price|inventory|api|integration)/i, issue: 'Promises real-time data without mentioning constraints' },
        { pattern: /integrates? with|connects? to|fetches? from/i, issue: 'Suggests direct external integrations' },
        { pattern: /database|sql|query|mongodb|postgres/i, issue: 'Implies database access' },
        { pattern: /async|background (process|task|job)|queue/i, issue: 'Suggests async/background processing' },
        { pattern: /authenticate|login|oauth|token refresh/i, issue: 'Implies authentication handling for user' }
      ];

      for (const flag of redFlags) {
        if (flag.pattern.test(fullContent)) {
          // Check if constraints are mentioned nearby
          const constraintMentioned = /constraint|limitation|cannot|requires user|defer|hand off/i.test(fullContent);
          if (!constraintMentioned) {
            validation.warnings.push(flag.issue);
            addLog(`Warning: ${flag.issue}`, 'warning');
          }
        }
      }

      // Quality scoring
      let score = 0;
      if (validation.yamlValid) score += 30;
      if (skillPackage.documentation.length > 500) score += 20;
      if (validation.issues.length === 0) score += 20;
      if (validation.warnings.length === 0) score += 20; // Bonus for no overselling
      if (skillPackage.metadata.includes('constraints:')) score += 10; // Bonus for explicit constraints

      validation.qualityScore = score;

      if (validation.warnings.length > 0) {
        addLog(`Found ${validation.warnings.length} potential overselling warnings`, 'warning');
      }

      addLog(`Quality score: ${score}/100`, score >= 70 ? 'success' : 'warning');
      updateProgress('Validate', 100, 'Validation complete');

      return validation;
    }

    async function packageSkill(skillPackage, skillName, resourceData, skillMetadata = null) {
      addLog('Creating skill package...', 'info');
      updateProgress('Package', 30, 'Initializing ZIP...');

      const zip = new JSZip();
      const sanitized = sanitizeFileName(skillName);
      const skillFolder = zip.folder(sanitized);

      const skillMd = `---\n${skillPackage.metadata}\n---\n\n${skillPackage.documentation}`;
      skillFolder.file('SKILL.md', skillMd);
      addLog('Added SKILL.md', 'success');

      // Add metadata tracking file if provided
      if (skillMetadata) {
        const metadataJson = JSON.stringify(skillMetadata, null, 2);
        skillFolder.file('metadata.json', metadataJson);
        addLog('Added metadata.json', 'success');
      }

      // Add resources if available
      if (resourceData) {
        // Add scripts
        if (resourceData.resources.scripts && Object.keys(resourceData.resources.scripts).length > 0) {
          const scriptsFolder = skillFolder.folder('scripts');
          for (const [filename, content] of Object.entries(resourceData.resources.scripts)) {
            scriptsFolder.file(filename, content);
            addLog(`Added script: ${filename}`, 'success');
          }
        }

        // Add references
        if (resourceData.resources.references && Object.keys(resourceData.resources.references).length > 0) {
          const referencesFolder = skillFolder.folder('references');
          for (const [filename, data] of Object.entries(resourceData.resources.references)) {
            const content = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            referencesFolder.file(filename, content);
            addLog(`Added reference: ${filename}`, 'success');
          }
        }

        // Add assets
        if (resourceData.resources.assets && Object.keys(resourceData.resources.assets).length > 0) {
          const assetsFolder = skillFolder.folder('assets');
          for (const [filename, content] of Object.entries(resourceData.resources.assets)) {
            assetsFolder.file(filename, content);
            addLog(`Added asset: ${filename}`, 'success');
          }
        }
      }

      updateProgress('Package', 60, 'Adding README...');

      const readme = `# ${skillName}

This is a Claude Code Skill package.

## Installation

1. Extract this ZIP file
2. Place the \`${sanitized}\` folder in your Claude Code skills directory:
   - Personal skills: ~/.claude/skills/
   - Project skills: .claude/skills/
3. The skill will be automatically available

## Contents

- \`SKILL.md\` - Main skill documentation${skillMetadata ? '\n- \`metadata.json\` - Generation metadata (sources, test results, iterations)' : ''}${resourceData && Object.keys(resourceData.resources.scripts).length > 0 ? '\n- \`scripts/\` - Helper scripts for deterministic operations' : ''}${resourceData && Object.keys(resourceData.resources.references).length > 0 ? '\n- \`references/\` - Reference documentation and examples' : ''}${resourceData && Object.keys(resourceData.resources.assets).length > 0 ? '\n- \`assets/\` - Templates and assets' : ''}

## Usage

This skill will be automatically loaded by Claude Code when relevant.
`;
      skillFolder.file('README.md', readme);
      addLog('Added README.md', 'success');

      updateProgress('Package', 80, 'Compressing...');

      const content = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });

      updateProgress('Package', 100, 'Package ready!');
      addLog('Package created successfully', 'success');

      // Build tree structure including resources
      const treeChildren = [
        { name: 'SKILL.md', type: 'file', size: skillMd.length },
        { name: 'README.md', type: 'file', size: readme.length }
      ];

      // Add metadata.json to tree if present
      if (skillMetadata) {
        treeChildren.push({
          name: 'metadata.json',
          type: 'file',
          size: JSON.stringify(skillMetadata).length
        });
      }

      if (resourceData) {
        if (resourceData.resources.scripts && Object.keys(resourceData.resources.scripts).length > 0) {
          treeChildren.push({
            name: 'scripts',
            type: 'folder',
            children: Object.keys(resourceData.resources.scripts).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }

        if (resourceData.resources.references && Object.keys(resourceData.resources.references).length > 0) {
          treeChildren.push({
            name: 'references',
            type: 'folder',
            children: Object.keys(resourceData.resources.references).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }

        if (resourceData.resources.assets && Object.keys(resourceData.resources.assets).length > 0) {
          treeChildren.push({
            name: 'assets',
            type: 'folder',
            children: Object.keys(resourceData.resources.assets).map(name => ({
              name: name,
              type: 'file'
            }))
          });
        }
      }

      const tree = {
        name: sanitized,
        type: 'folder',
        children: treeChildren
      };

      return { content, filename: `${sanitized}.zip`, tree };
    }

    // ============================================
    // WEB RESEARCH UTILITIES
    // For gathering real-world knowledge
    // ============================================

    async function performWebResearch(queries) {
      addLog('Performing web research with Claude...', 'info');

      const results = {};

      // Limit to top 2 queries to avoid excessive API calls
      const topQueries = queries.slice(0, 2);

      for (const query of topQueries) {
        addLog(`Researching: ${query}`, 'info');

        try {
          const prompt = `Search the web and provide a concise research summary for: "${query}"

Return your findings in this JSON format (no markdown, just JSON):
{
  "findings": "2-3 sentence summary of key information found",
  "sources": ["source1.com", "source2.com"],
  "key_points": ["point 1", "point 2", "point 3"],
  "verified": true
}

Focus on authoritative sources and practical information.`;

          const response = await callClaude(prompt, 800);

          try {
            const cleaned = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
            const parsed = JSON.parse(cleaned);
            results[query] = parsed;
            addLog(`‚úì Research complete: ${query}`, 'success');
          } catch (parseErr) {
            // If JSON parsing fails, create a structured response from the text
            addLog(`Research returned text format for: ${query}`, 'info');
            results[query] = {
              findings: response.substring(0, 500),
              sources: ['web-research'],
              key_points: ['See findings'],
              verified: true
            };
          }
        } catch (err) {
          addLog(`Research failed for "${query}": ${err.message}`, 'warning');
          results[query] = {
            findings: `Unable to research: ${query}`,
            sources: [],
            key_points: [],
            verified: false,
            error: err.message
          };
        }
      }

      return results;
    }

    async function researchDomain(skillConcept) {
      addLog('Researching domain knowledge from web sources...', 'info');

      const queries = [
        `${skillConcept} best practices`,
        `${skillConcept} API documentation`,
        `${skillConcept} workflow patterns`,
        `${skillConcept} common tools`
      ];

      // In production, this would actually search the web
      const knowledgeBase = await performWebResearch(queries);

      addLog(`‚úì Researched ${Object.keys(knowledgeBase).length} knowledge areas`, 'success');
      return knowledgeBase;
    }

    // ============================================
    // STAGE 0: VIABILITY CHECK
    // Determines if this should be a skill at all
    // ============================================

    // ============================================
    // SKILL REGISTRY
    // Local storage for tracking generated skills
    // ============================================

    const SKILL_REGISTRY_KEY = 'skill_builder_registry';

    function getSkillRegistry() {
      try {
        const registry = localStorage.getItem(SKILL_REGISTRY_KEY);
        return registry ? JSON.parse(registry) : [];
      } catch (err) {
        console.error('Failed to load skill registry:', err);
        return [];
      }
    }

    function addToSkillRegistry(skillData) {
      try {
        const registry = getSkillRegistry();
        registry.push({
          name: skillData.skill_name,
          description: skillData.description,
          created: new Date().toISOString(),
          viability_score: skillData.viability_score,
          test_pass_rate: skillData.test_pass_rate
        });

        // Keep only last 50 skills
        const trimmed = registry.slice(-50);
        localStorage.setItem(SKILL_REGISTRY_KEY, JSON.stringify(trimmed));
        addLog(`Added to skill registry: ${skillData.skill_name}`, 'info');
      } catch (err) {
        console.error('Failed to save to skill registry:', err);
      }
    }

    function clearSkillRegistry() {
      try {
        localStorage.removeItem(SKILL_REGISTRY_KEY);
        addLog('Skill registry cleared', 'success');
      } catch (err) {
        console.error('Failed to clear skill registry:', err);
      }
    }

    async function searchAnthropicSkills(query) {
      addLog('Searching for similar existing skills...', 'info');

      // Get local registry
      const localSkills = getSkillRegistry();

      // Also search for common/well-known skills via Claude
      try {
        const prompt = `List 3-5 common Claude Code skills that are similar to: "${query}"

Return ONLY a JSON array of skill objects (no markdown):
[
  {
    "name": "skill-name",
    "description": "what it does",
    "similarity": 0-10
  }
]

If no similar skills exist, return an empty array: []`;

        const response = await callClaude(prompt, 500);
        const cleaned = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const commonSkills = JSON.parse(cleaned);

        // Combine local and common skills
        const allSkills = [...localSkills, ...commonSkills];
        addLog(`Found ${allSkills.length} potentially similar skills`, 'info');
        return allSkills;
      } catch (err) {
        addLog(`Skill search limited to local registry (${localSkills.length} skills)`, 'info');
        return localSkills;
      }
    }

    function findSimilarSkills(userInput, existingSkills) {
      // Simple similarity check based on keywords
      const inputLower = userInput.toLowerCase();
      const inputWords = new Set(inputLower.split(/\s+/).filter(w => w.length > 3));

      return existingSkills.filter(skill => {
        const skillWords = new Set(skill.name.toLowerCase().split(/[-\s]+/).filter(w => w.length > 3));
        const intersection = new Set([...inputWords].filter(x => skillWords.has(x)));
        const similarity = intersection.size / Math.min(inputWords.size, skillWords.size);
        return similarity > 0.4;
      });
    }

    async function stage0_viabilityCheck(userInput) {
      addLog('=== STAGE 0: VIABILITY CHECK ===', 'info');
      updateProgress('Viability Check', 10, 'Analyzing skill request...');

      // Search for existing similar skills
      const existingSkills = await searchAnthropicSkills(userInput);
      const similarSkills = findSimilarSkills(userInput, existingSkills);

      updateProgress('Viability Check', 50, 'Evaluating viability criteria...');

      const prompt = `You are evaluating whether a skill request should become a Claude skill or just a prompt template.

USER REQUEST: ${userInput}

SIMILAR EXISTING SKILLS: ${similarSkills.length > 0 ? similarSkills.map(s => s.name).join(', ') : 'None found'}

Evaluate using these criteria:

1. IS DISTINCT: Is this sufficiently different from existing skills?
2. HAS SCOPE: Is this complex enough to warrant a skill (vs. simple prompt)?
3. IS REUSABLE: Will this be used multiple times, not just once?
4. IS TESTABLE: Does this have clear success criteria?

DECISION RULES:
- Score each criterion 0-10
- Average score >= 7: PROCEED (good skill candidate)
- Average score 4-6: NEEDS_REFINEMENT (consider simplification or as prompt template)
- Average score < 4: ABORT (this should be a prompt template, not a skill)

Return ONLY valid JSON (no markdown):
{
  "checks": {
    "is_distinct": { "score": 0-10, "reasoning": "why" },
    "has_scope": { "score": 0-10, "reasoning": "why" },
    "is_reusable": { "score": 0-10, "reasoning": "why" },
    "is_testable": { "score": 0-10, "reasoning": "why" }
  },
  "viability_score": 0-10,
  "decision": "PROCEED|NEEDS_REFINEMENT|ABORT",
  "reason": "brief explanation of decision",
  "scope": "if PROCEED, what is the recommended scope",
  "alternative": "if ABORT, what prompt template would work instead"
}`;

      try {
        let response = await callClaude(prompt, 1500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const result = JSON.parse(response);

        addLog(`Viability Score: ${result.viability_score}/10`,
          result.viability_score >= 7 ? 'success' : result.viability_score >= 4 ? 'warning' : 'error');
        addLog(`Decision: ${result.decision}`, result.decision === 'PROCEED' ? 'success' : 'warning');
        addLog(`Reason: ${result.reason}`, 'info');

        updateProgress('Viability Check', 100, `Decision: ${result.decision}`);

        return result;
      } catch (err) {
        addLog(`Viability check failed: ${err.message} - proceeding anyway`, 'warning');
        // Default to proceed if check fails
        return {
          checks: {},
          viability_score: 7,
          decision: 'PROCEED',
          reason: 'Viability check failed - defaulting to proceed',
          scope: 'Standard skill scope'
        };
      }
    }

    // ============================================
    // STAGE 3: RESOURCE GATHERING
    // Replaces knowledge enhancement with real resource acquisition
    // ============================================

    async function findConcreteExamples(domain, requirements) {
      addLog('Finding real-world examples for skill...', 'info');

      const prompt = `Find and describe 3-5 concrete, real-world examples for this domain.

DOMAIN: ${domain}
SKILL: ${requirements.skill_name}
DESCRIPTION: ${requirements.description}

For each example, provide:
1. A specific use case or scenario
2. Key components or steps involved
3. What makes it effective

Return ONLY valid JSON (no markdown):
{
  "examples": [
    {
      "title": "example title",
      "scenario": "specific use case",
      "components": ["component1", "component2"],
      "effectiveness": "what makes this work well"
    }
  ]
}`;

      try {
        let response = await callClaude(prompt, 1500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        addLog(`‚úì Found ${parsed.examples.length} concrete examples`, 'success');
        return parsed.examples || [];
      } catch (err) {
        addLog(`Example finding failed: ${err.message}`, 'warning');
        return [];
      }
    }

    function analyzeResourceNeeds(examples, requirements) {
      addLog('Analyzing resource requirements...', 'info');

      // Determine what types of resources would be helpful
      const resourcePlan = {
        scripts: [],
        references: [],
        assets: []
      };

      // Check if skill needs executable scripts (deterministic tasks)
      // REFERENCE_CODEGEN skills should NOT generate scripts - they're just documentation
      // Scripts only make sense for EXECUTOR_INTERNAL (deterministic operations)
      const shouldGenerateScripts = requirements.skill_category !== 'REFERENCE_CODEGEN' &&
                                   requirements.skill_category !== 'KNOWLEDGE' &&
                                   requirements.skill_category !== 'METHODOLOGY' &&
                                   (requirements.needs_scripts ||
                                    requirements.description.toLowerCase().includes('automat') ||
                                    requirements.description.toLowerCase().includes('process'));

      if (shouldGenerateScripts) {
        resourcePlan.scripts.push({
          name: `${requirements.skill_name}-helper.py`,
          purpose: 'Helper script for deterministic operations',
          type: 'python'
        });
      } else if (requirements.skill_category === 'REFERENCE_CODEGEN') {
        addLog('‚ÑπÔ∏è Skipping script generation for REFERENCE_CODEGEN skill (documentation only)', 'info');
      }

      // Check if skill needs reference documentation
      if (examples.length > 0) {
        resourcePlan.references.push({
          name: 'examples.md',
          purpose: 'Real-world examples and patterns',
          content: examples
        });
      }

      // Check if skill needs templates or assets
      if (requirements.description.toLowerCase().includes('template') ||
          requirements.description.toLowerCase().includes('format')) {
        resourcePlan.assets.push({
          name: 'template.md',
          purpose: 'Template for common patterns',
          type: 'markdown'
        });
      }

      addLog(`Resource plan: ${resourcePlan.scripts.length} scripts, ${resourcePlan.references.length} references, ${resourcePlan.assets.length} assets`, 'info');
      return resourcePlan;
    }

    async function acquireResources(resourcePlan, requirements) {
      addLog('Acquiring resources...', 'info');

      const resources = {
        scripts: {},
        references: {},
        assets: {}
      };

      // Generate scripts
      for (const scriptSpec of resourcePlan.scripts) {
        addLog(`Generating script: ${scriptSpec.name}`, 'info');

        const prompt = `Generate a ${scriptSpec.type} script for: ${scriptSpec.purpose}

SKILL: ${requirements.skill_name}
DESCRIPTION: ${requirements.description}

Create a well-documented, production-ready script.

Return ONLY the script code, no markdown, no explanations.`;

        try {
          const code = await callClaude(prompt, 1500);
          resources.scripts[scriptSpec.name] = code;
          addLog(`‚úì Generated ${scriptSpec.name}`, 'success');
        } catch (err) {
          addLog(`Failed to generate ${scriptSpec.name}: ${err.message}`, 'warning');
        }
      }

      // Create reference documents
      for (const refSpec of resourcePlan.references) {
        addLog(`Creating reference: ${refSpec.name}`, 'info');
        resources.references[refSpec.name] = {
          title: refSpec.purpose,
          content: refSpec.content
        };
      }

      // Create asset templates
      for (const assetSpec of resourcePlan.assets) {
        addLog(`Creating asset: ${assetSpec.name}`, 'info');

        const prompt = `Create a ${assetSpec.type} template for: ${assetSpec.purpose}

SKILL: ${requirements.skill_name}

Return ONLY the template content.`;

        try {
          const template = await callClaude(prompt, 1000);
          resources.assets[assetSpec.name] = template;
          addLog(`‚úì Created ${assetSpec.name}`, 'success');
        } catch (err) {
          addLog(`Failed to create ${assetSpec.name}: ${err.message}`, 'warning');
        }
      }

      return resources;
    }

    async function stage3_gatherResourcesAndExamples(requirements, domainKnowledge) {
      addLog('=== STAGE 3: RESOURCE GATHERING ===', 'info');
      updateProgress('Resource Gathering', 10, 'Finding real-world examples...');

      // Find concrete examples
      const examples = await findConcreteExamples(requirements.domain || requirements.skill_name, requirements);

      updateProgress('Resource Gathering', 40, 'Analyzing resource needs...');

      // Analyze what resources are needed
      const resourcePlan = analyzeResourceNeeds(examples, requirements);

      updateProgress('Resource Gathering', 60, 'Acquiring resources...');

      // Acquire/create resources
      const resources = await acquireResources(resourcePlan, requirements);

      updateProgress('Resource Gathering', 100, 'Resource gathering complete');
      addLog(`‚úì Resource gathering complete: ${Object.keys(resources.scripts).length} scripts, ${Object.keys(resources.references).length} references, ${Object.keys(resources.assets).length} assets`, 'success');

      return {
        examples: examples,
        resourcePlan: resourcePlan,
        resources: resources,
        domainKnowledge: domainKnowledge
      };
    }

    // ============================================
    // STAGE 7: SKILL TESTING WITH CLAUDE
    // Tests the generated skill with real Claude API calls
    // ============================================

    async function generateTestCases(requirements, skillContent) {
      addLog('Generating test cases for skill validation...', 'info');

      const prompt = `Given this skill package, generate 3-5 test cases to validate it works correctly.

SKILL NAME: ${requirements.skill_name}
SKILL DESCRIPTION: ${requirements.description}
SKILL CONTENT (first 1000 chars): ${skillContent.substring(0, 1000)}

For each test case, provide:
1. A user query/request that should trigger this skill
2. Expected behavior or output characteristics
3. Success criteria

Return ONLY valid JSON (no markdown):
{
  "test_cases": [
    {
      "query": "user query that should trigger this skill",
      "expected_behavior": "what the skill should do or provide",
      "success_criteria": ["criterion 1", "criterion 2"]
    }
  ]
}`;

      try {
        let response = await callClaude(prompt, 1500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);
        return parsed.test_cases || [];
      } catch (err) {
        addLog(`Test case generation failed: ${err.message}`, 'warning');
        // Fallback to basic test case
        return [{
          query: `Help me with ${requirements.skill_name}`,
          expected_behavior: `Should use the skill to provide relevant guidance`,
          success_criteria: ["Response is relevant", "Uses skill knowledge"]
        }];
      }
    }

    async function testSkillWithClaude(skillContent, testCase) {
      addLog(`Testing: "${testCase.query.substring(0, 50)}..."`, 'info');

      const testPrompt = `You have access to the following skill:

---
${skillContent}
---

User query: ${testCase.query}

Use the skill to respond to this query.`;

      try {
        const response = await callClaude(testPrompt, 2000);
        return {
          query: testCase.query,
          response: response,
          success: true
        };
      } catch (err) {
        return {
          query: testCase.query,
          response: null,
          success: false,
          error: err.message
        };
      }
    }

    function validateTestResponse(response, testCase) {
      if (!response.success || !response.response) {
        return {
          passed: false,
          reason: `Test execution failed: ${response.error || 'No response'}`
        };
      }

      const responseText = response.response.toLowerCase();
      const query = testCase.query.toLowerCase();

      // Basic validation: response should be relevant and non-empty
      if (responseText.length < 50) {
        return {
          passed: false,
          reason: 'Response too short (less than 50 characters)'
        };
      }

      // Check if response seems relevant (contains key terms from query or skill)
      const relevanceScore = testCase.success_criteria.reduce((score, criterion) => {
        const criterionWords = criterion.toLowerCase().split(/\s+/);
        const matchedWords = criterionWords.filter(word =>
          word.length > 3 && responseText.includes(word)
        );
        return score + (matchedWords.length / criterionWords.length);
      }, 0);

      const passed = relevanceScore > 0.3 || responseText.length > 200;

      return {
        passed: passed,
        reason: passed ? 'Response appears relevant and substantive' : `Low relevance score: ${relevanceScore.toFixed(2)}`,
        relevanceScore: relevanceScore
      };
    }

    async function stage7_testSkill(skillPackage, requirements) {
      addLog('=== STAGE 7: SKILL TESTING ===', 'info');
      updateProgress('Testing', 10, 'Generating test cases...');

      const skillContent = `---\n${skillPackage.metadata}\n---\n\n${skillPackage.documentation}`;

      // Generate test cases
      const testCases = await generateTestCases(requirements, skillContent);
      addLog(`Generated ${testCases.length} test cases`, 'success');

      updateProgress('Testing', 30, `Running ${testCases.length} tests...`);

      // Run tests
      const results = [];
      for (let i = 0; i < testCases.length; i++) {
        const testCase = testCases[i];
        updateProgress('Testing', 30 + (50 * (i / testCases.length)),
          `Testing case ${i + 1}/${testCases.length}...`);

        const response = await testSkillWithClaude(skillContent, testCase);
        const validation = validateTestResponse(response, testCase);

        results.push({
          test: testCase,
          response: response,
          validation: validation,
          passed: validation.passed
        });

        const status = validation.passed ? '‚úì' : '‚úó';
        addLog(`${status} Test ${i + 1}: ${validation.passed ? 'PASSED' : 'FAILED'} - ${validation.reason}`,
          validation.passed ? 'success' : 'warning');
      }

      // Calculate pass rate
      const passedTests = results.filter(r => r.passed).length;
      const passRate = passedTests / results.length;

      updateProgress('Testing', 100, `Testing complete: ${passedTests}/${results.length} passed`);
      addLog(`Test Results: ${(passRate * 100).toFixed(0)}% pass rate (${passedTests}/${results.length})`,
        passRate >= 0.8 ? 'success' : 'warning');

      return {
        passRate: passRate,
        results: results,
        totalTests: results.length,
        passedTests: passedTests,
        failedTests: results.length - passedTests,
        recommendation: passRate >= 0.8 ? 'APPROVE' : 'NEEDS_REFINEMENT'
      };
    }

    // ============================================
    // STAGE 8: ITERATION LOOP
    // Analyzes test failures and suggests improvements
    // ============================================

    function analyzeTestFailures(testResults) {
      const failures = testResults.results.filter(r => !r.passed);

      if (failures.length === 0) {
        return {
          issues: [],
          recommendations: []
        };
      }

      const issues = [];
      const recommendations = [];

      // Analyze failure patterns
      const hasResponseFailures = failures.some(f => !f.response.success);
      const hasRelevanceFailures = failures.some(f =>
        f.validation.reason && f.validation.reason.includes('relevance')
      );
      const hasLengthFailures = failures.some(f =>
        f.validation.reason && f.validation.reason.includes('too short')
      );

      if (hasResponseFailures) {
        issues.push('response_failure');
        recommendations.push('Skill may be too complex or unclear - simplify instructions');
      }

      if (hasRelevanceFailures) {
        issues.push('relevance_failure');
        recommendations.push('Skill instructions may not be specific enough - add more concrete examples');
      }

      if (hasLengthFailures) {
        issues.push('insufficient_output');
        recommendations.push('Skill may need more detailed guidance on expected output format');
      }

      return {
        issues: issues,
        recommendations: recommendations,
        failureDetails: failures.map(f => ({
          query: f.test.query,
          reason: f.validation.reason
        }))
      };
    }

    async function refineSkillBasedOnFailures(skillPackage, analysis, testResults, requirements) {
      addLog('Attempting to refine skill based on test failures...', 'info');

      // Build failure context
      const failureContext = analysis.failureDetails.map(f =>
        `Query: "${f.query}"\nIssue: ${f.reason}`
      ).join('\n\n');

      const prompt = `Improve this skill's documentation based on test failures.

CURRENT DOCUMENTATION:
${skillPackage.documentation}

TEST FAILURES (${testResults.failedTests}/${testResults.totalTests}):
${failureContext}

IDENTIFIED ISSUES:
${analysis.recommendations.join('\n')}

INSTRUCTIONS:
- Fix the issues identified above
- Make instructions more clear and specific
- Add concrete examples where needed
- Ensure proper formatting and structure
- Do NOT include YAML frontmatter (just the markdown documentation)

Return the IMPROVED documentation (markdown only, no frontmatter):`;

      try {
        const improvedDocs = await callClaude(prompt, 4000);
        addLog('‚úì Generated improved documentation', 'success');

        // Return refined skill package
        return {
          metadata: skillPackage.metadata,
          documentation: improvedDocs,
          requirements: skillPackage.requirements
        };
      } catch (err) {
        addLog(`Failed to refine skill: ${err.message}`, 'error');
        return skillPackage; // Return original if refinement fails
      }
    }

    async function stage8_iterateIfNeeded(skillPackage, testResults, requirements, iterationCount = 0, research = null) {
      addLog('=== STAGE 8: ITERATION ANALYSIS ===', 'info');

      // Check if iteration is needed
      if (testResults.passRate >= 0.8) {
        addLog('‚úì Quality threshold met - no iteration needed', 'success');
        return {
          status: 'COMPLETE',
          finalSkill: skillPackage,
          testResults: testResults,
          iterations: iterationCount
        };
      }

      // Check iteration limit
      if (iterationCount >= 3) {
        addLog('‚ö† Maximum iterations reached - proceeding with current version', 'warning');
        return {
          status: 'MAX_ITERATIONS_REACHED',
          finalSkill: skillPackage,
          testResults: testResults,
          iterations: iterationCount,
          recommendation: 'Manual review recommended'
        };
      }

      // Analyze failures
      const analysis = analyzeTestFailures(testResults);
      addLog(`Identified ${analysis.issues.length} issue types from ${testResults.failedTests} failures`, 'warning');

      analysis.recommendations.forEach((rec, i) => {
        addLog(`Recommendation ${i + 1}: ${rec}`, 'info');
      });

      // AUTO-REGENERATE: Refine the skill based on failures
      addLog(`üîÑ Iteration ${iterationCount + 1}/3: Attempting auto-refinement...`, 'info');

      const refinedSkill = await refineSkillBasedOnFailures(
        skillPackage,
        analysis,
        testResults,
        requirements
      );

      // Re-test the refined skill
      addLog('Re-testing refined skill...', 'info');
      const newTestResults = await stage7_testSkill(refinedSkill, requirements);

      // Check if refinement improved the skill
      if (newTestResults.passRate > testResults.passRate) {
        addLog(`‚úì Improvement: ${(testResults.passRate * 100).toFixed(0)}% ‚Üí ${(newTestResults.passRate * 100).toFixed(0)}%`, 'success');
      } else {
        addLog(`No improvement: ${(testResults.passRate * 100).toFixed(0)}% ‚Üí ${(newTestResults.passRate * 100).toFixed(0)}%`, 'warning');
      }

      // Recursively iterate if still below threshold
      if (newTestResults.passRate < 0.8 && iterationCount + 1 < 3) {
        addLog('Still below threshold - continuing iteration...', 'info');
        return await stage8_iterateIfNeeded(
          refinedSkill,
          newTestResults,
          requirements,
          iterationCount + 1,
          research
        );
      }

      // Return final result
      return {
        status: newTestResults.passRate >= 0.8 ? 'COMPLETE' : 'NEEDS_REFINEMENT',
        finalSkill: refinedSkill,
        testResults: newTestResults,
        iterations: iterationCount + 1,
        analysis: analysis,
        improvement: newTestResults.passRate - testResults.passRate
      };
    }

    async function startGeneration() {
      const input = document.getElementById('skillInput').value.trim();
      if (!input || isGenerating) return;

      try {
        isGenerating = true;
        document.getElementById('generateBtn').disabled = true;
        document.getElementById('generateBtn').innerHTML = '‚è≥ Generating... <span class="loading-spinner"></span>';
        document.getElementById('inputCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');
        document.getElementById('logContainer').innerHTML = '';

        // Stage 0: Viability Check (NEW - determines if this should be a skill)
        setStep(0);
        const viabilityCheck = await stage0_viabilityCheck(input);

        if (viabilityCheck.decision === 'ABORT') {
          addLog('‚ö†Ô∏è Viability check recommendation: This should be a prompt template, not a skill', 'warning');
          addLog(`Alternative: ${viabilityCheck.alternative}`, 'info');
          // For now, we'll show a warning but continue
          addLog('Proceeding with skill generation anyway...', 'warning');
        } else if (viabilityCheck.decision === 'NEEDS_REFINEMENT') {
          addLog('‚ö†Ô∏è Viability check: Skill needs refinement', 'warning');
          addLog(`Recommendation: ${viabilityCheck.reason}`, 'info');
        }

        // Phase 1: Extract Requirements
        setStep(1);
        const requirements = await extractRequirements(input);
        currentRequirements = requirements;

        // Store viability check results
        currentRequirements.viability_check = viabilityCheck;

        // Phase 0: Utility Analysis (runs after extraction)
        setStep(2);
        const utilityAnalysis = await analyzeUtility(requirements);

        // NEW: Skill Categorization Gate
        // Determines if skill is a real power-up and sets max utility ceiling
        const categorization = await categorizeSkill(input, requirements);
        const categoryMaxUtility = categorization.max_utility_score;
        const originalScore = utilityAnalysis.utility_score;

        // Apply category ceiling to utility score
        if (originalScore > categoryMaxUtility) {
          addLog(`‚ö†Ô∏è Applying category ceiling: ${originalScore}/10 ‚Üí ${categoryMaxUtility}/10 (${categorization.category} max)`, 'warning');
          utilityAnalysis.utility_score = categoryMaxUtility;
          utilityAnalysis.utility_category = categorizeUtilityScore(categoryMaxUtility);
          utilityAnalysis.category_capped = true;
          utilityAnalysis.original_score = originalScore;
        }

        // Add categorization info to analysis
        utilityAnalysis.skill_category = categorization.category;
        utilityAnalysis.category_reasoning = categorization.category_reasoning;
        utilityAnalysis.is_real_power_up = categorization.is_real_power_up;
        utilityAnalysis.category_max_utility = categoryMaxUtility;
        utilityAnalysis.indicators_found = categorization.indicators_found;

        // Also add category to requirements so it flows through pipeline
        currentRequirements.skill_category = categorization.category;

        // NEW: Factory Mode Detection - determines if KNOWLEDGE skill needs enhancement
        const factoryMode = determineFactoryMode(utilityAnalysis);
        addLog(`Factory mode: ${factoryMode.mode}`, 'info');
        addLog(`Reason: ${factoryMode.reason}`, 'info');

        // Store mode for later use
        utilityAnalysis.factory_mode = factoryMode.mode;

        // If ENHANCEMENT mode, run Knowledge Enhancement Engine
        if (factoryMode.mode === 'ENHANCEMENT') {
          const enhancement = await enhanceKnowledgeSkill(
            requirements.skill_name,
            utilityAnalysis.power_up_statement
          );

          if (enhancement.success) {
            // Store enhancement results for use in research phase
            utilityAnalysis.knowledge_enhancement = enhancement;
            // Update the skill name to use the enhanced concept
            currentRequirements.original_skill_name = requirements.skill_name;
            currentRequirements.skill_name = enhancement.enhancedConcept;
            currentRequirements.description = enhancement.valueProposition;
            addLog(`‚úì Skill enhanced: ${enhancement.enhancedConcept}`, 'success');
          } else {
            addLog('‚ö† Enhancement failed - proceeding with original concept', 'warning');
          }
        }

        // Update phase_routing based on final score, category, and factory mode
        const finalScore = utilityAnalysis.utility_score;
        if (finalScore >= 7) {
          utilityAnalysis.phase_routing = 'PROCEED';
        } else if (finalScore >= 4) {
          // MEDIUM_UTILITY: REDESIGN for TEMPLATE/EXECUTOR, PROCEED for real power-ups
          if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REDESIGN';
          } else {
            utilityAnalysis.phase_routing = 'PROCEED';
          }
        } else {
          // LOW_UTILITY: Special handling for ENHANCEMENT mode
          if (factoryMode.mode === 'ENHANCEMENT') {
            // KNOWLEDGE skills that were enhanced should proceed to generation
            utilityAnalysis.phase_routing = 'PROCEED';
          } else if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REJECT';
          } else {
            utilityAnalysis.phase_routing = 'REDESIGN';
          }
        }

        // NEW: Constraint Validation Gate
        // Validates that power-up claims don't contradict skill's own constraints
        addLog('Running constraint validation...', 'info');
        const validationResult = validateConstraints(requirements, utilityAnalysis);

        let finalAnalysis = utilityAnalysis;
        if (validationResult.hasContradictions) {
          // Log found constraints
          addLog(`‚úì Found ${validationResult.constraints.length} constraint(s):`, 'info');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });

          // Log contradictions
          addLog(`‚ö†Ô∏è Constraint contradictions detected: ${validationResult.contradictions.length} claim(s) invalidated`, 'warning');
          validationResult.contradictions.forEach(contradiction => {
            addLog(`  ‚úó Claim: "${contradiction.claim}"`, 'warning');
            addLog(`    Conflicts: "${contradiction.constraint.substring(0, 60)}${contradiction.constraint.length > 60 ? '...' : ''}"`, 'warning');
          });

          addLog(`Score recalculated: ${validationResult.originalScore}/10 ‚Üí ${validationResult.revisedScore}/10 (${validationResult.scoreChange})`, 'warning');
          finalAnalysis = validationResult.revisedAnalysis;
        } else if (validationResult.hasConstraints) {
          addLog(`‚úì Found ${validationResult.constraints.length} constraint(s) - all claims validated`, 'success');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });
          addLog(`‚úì Constraint validation passed: ${validationResult.claimsChecked || 0} claim(s) verified`, 'success');
        } else {
          addLog('‚úì No constraints found - analysis valid', 'success');
        }

        utilityAnalysisResult = finalAnalysis;

        // Hide progress card and show utility results
        document.getElementById('progressCard').classList.add('hidden');
        await showUtilityResults(finalAnalysis, validationResult);

        // For HIGH_UTILITY, we could auto-proceed or wait for user
        // Currently waiting for user to click "Continue to Research"
        // REDESIGN and REJECT paths stop here and wait for user action

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
        document.getElementById('generateBtn').disabled = false;
        document.getElementById('generateBtn').textContent = 'Generate This Skill ‚Üí';
      }
    }

    function downloadSkill() {
      if (!generatedSkillData) return;

      const url = URL.createObjectURL(generatedSkillData.package);
      const a = document.createElement('a');
      a.href = url;
      a.download = generatedSkillData.filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`Downloaded ${generatedSkillData.filename}`, 'success');
    }

    async function copyPromptToClipboard() {
      if (!generatedSkillData || !generatedSkillData.promptForClipboard) {
        addLog('No skill available to copy', 'error');
        return;
      }

      try {
        // Use pre-cached prompt (no async operations to preserve iOS Safari gesture context)
        const prompt = generatedSkillData.promptForClipboard;

        // Try clipboard API
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(prompt);
          showCopySuccess();
          addLog('Skill prompt copied to clipboard!', 'success');
        } else {
          throw new Error('Clipboard API not available. Please use HTTPS or a modern browser.');
        }

      } catch (error) {
        addLog(`Failed to copy: ${error.message}`, 'error');
        console.error('Copy error:', error);
      }
    }

    function showCopySuccess() {
      const button = document.getElementById('copyPromptBtn');
      const originalText = button.innerHTML;
      button.innerHTML = '‚úì Copied!';
      button.disabled = true;

      setTimeout(() => {
        button.innerHTML = originalText;
        button.disabled = false;
      }, 2000);
    }


    function resetFactory() {
      location.reload();
    }

    init();
  </script>
</body>
</html>

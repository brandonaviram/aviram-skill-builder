<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deep Research Skill Factory - Aviram OS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0b0d;
      --bg-medium: #14161a;
      --bg-light: #1e2127;
      --glass-bg: rgba(30, 33, 39, 0.4);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --text-primary: #e8eaed;
      --text-secondary: #9aa0a6;
      --accent-primary: #8ab4f8;
      --accent-secondary: #81c995;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #0a0b0d 0%, #14161a 50%, #1e2127 100%);
      background-attachment: fixed;
      min-height: 100vh;
      padding: 24px;
      position: relative;
      overflow-x: hidden;
      color: var(--text-primary);
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 30%, rgba(138, 180, 248, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(129, 201, 149, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.01) 0%, transparent 80%);
      pointer-events: none;
      animation: ambientShift 30s ease-in-out infinite;
      z-index: 0;
    }

    @keyframes ambientShift {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.1); }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    .aviram-surface {
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      background: var(--glass-bg);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      box-shadow:
        0 8px 32px var(--shadow-color),
        inset 0 1px 0 var(--glass-highlight);
      padding: 32px;
      margin-bottom: 24px;
      contain: layout style paint;
      will-change: backdrop-filter, transform;
      transform: translate3d(0, 0, 0);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .aviram-surface:hover {
      backdrop-filter: blur(24px) saturate(140%);
      -webkit-backdrop-filter: blur(24px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.12);
      transform: translate3d(0, -2px, 0);
      box-shadow:
        0 12px 48px var(--shadow-color),
        inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .aviram-surface::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg,
        transparent 0%,
        var(--accent-primary) 50%,
        transparent 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .aviram-surface:hover::before {
      opacity: 0.5;
    }

    .header-surface {
      backdrop-filter: blur(30px) saturate(140%);
      -webkit-backdrop-filter: blur(30px) saturate(140%);
      background: rgba(30, 33, 39, 0.5);
      border-radius: 24px;
      padding: 48px 40px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
      font-size: 48px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      letter-spacing: -1px;
      line-height: 1.1;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .stepper {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 32px 0;
      padding: 12px 0;
      position: relative;
    }

    .step {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      position: relative;
      z-index: 2;
    }

    .step-circle {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(30, 33, 39, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--text-secondary);
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .step-circle::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 50%;
      background: conic-gradient(
        var(--accent-primary) 0deg,
        transparent 90deg
      );
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .step-circle.active {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      transform: scale(1.15);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .step-circle.active::before {
      opacity: 0.3;
      animation: rotate 3s linear infinite;
    }

    @keyframes rotate {
      to { transform: rotate(360deg); }
    }

    .step-circle.complete {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow: 0 0 24px rgba(129, 201, 149, 0.3);
    }

    .step-label {
      margin-top: 14px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .step-label.active {
      color: var(--accent-primary);
    }

    .step-line {
      position: absolute;
      top: 32px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: rgba(255, 255, 255, 0.05);
      z-index: 1;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .step-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 12px currentColor;
    }

    .step-line.complete::after {
      width: 100%;
    }

    .step:last-child .step-line {
      display: none;
    }

    textarea {
      width: 100%;
      height: 240px;
      padding: 20px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(20, 22, 26, 0.5);
      border: 1.5px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
      resize: vertical;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    textarea:focus {
      outline: none;
      background: rgba(20, 22, 26, 0.7);
      border-color: var(--accent-primary);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.3),
        0 0 24px rgba(138, 180, 248, 0.2);
    }

    .btn {
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(138, 180, 248, 0.15);
      border: 1.5px solid var(--accent-primary);
      color: var(--accent-primary);
      padding: 18px 36px;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 20px;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 20px rgba(138, 180, 248, 0.2);
      text-shadow: 0 0 20px rgba(138, 180, 248, 0.5);
      transform: translate3d(0, 0, 0);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg,
        rgba(138, 180, 248, 0.2),
        rgba(129, 201, 149, 0.2));
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .btn:hover:not(:disabled)::before {
      opacity: 1;
    }

    .btn:hover:not(:disabled) {
      background: rgba(138, 180, 248, 0.25);
      border-color: rgba(138, 180, 248, 0.8);
      transform: translate3d(0, -3px, 0) scale(1.02);
      box-shadow:
        0 8px 32px rgba(138, 180, 248, 0.3),
        0 0 40px rgba(138, 180, 248, 0.2);
    }

    .btn:active:not(:disabled) {
      transform: translate3d(0, 0, 0) scale(0.98);
    }

    .btn:disabled {
      background: rgba(30, 33, 39, 0.5);
      border-color: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      cursor: not-allowed;
      opacity: 0.5;
      text-shadow: none;
    }

    .btn.success {
      background: rgba(129, 201, 149, 0.15);
      border-color: var(--accent-secondary);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 20px rgba(129, 201, 149, 0.2),
        0 0 30px rgba(129, 201, 149, 0.15);
    }

    .btn.success:hover {
      background: rgba(129, 201, 149, 0.25);
      box-shadow:
        0 8px 32px rgba(129, 201, 149, 0.3),
        0 0 40px rgba(129, 201, 149, 0.2);
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    .button-group .btn {
      flex: 1;
      min-width: 200px;
      margin-top: 0;
    }

    .btn-secondary {
      background: rgba(100, 100, 120, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
      color: var(--text-primary);
      box-shadow: 0 4px 20px rgba(100, 100, 120, 0.2);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(100, 100, 120, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow:
        0 8px 32px rgba(100, 100, 120, 0.3),
        0 0 40px rgba(100, 100, 120, 0.2);
    }

    @media (max-width: 768px) {
      .button-group {
        flex-direction: column;
      }

      .button-group .btn {
        width: 100%;
        min-width: 0;
      }
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(20, 22, 26, 0.6);
      border-radius: 8px;
      overflow: hidden;
      margin: 24px 0;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.05);
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg,
        var(--accent-primary),
        var(--accent-secondary));
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 20px currentColor;
      border-radius: 8px;
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .log-container {
      max-height: 520px;
      overflow-y: auto;
      padding: 20px;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      background: rgba(10, 11, 13, 0.6);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 2px 12px rgba(0, 0, 0, 0.5);
    }

    .log-container::-webkit-scrollbar {
      width: 6px;
    }

    .log-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
    }

    .log-container::-webkit-scrollbar-thumb {
      background: rgba(138, 180, 248, 0.3);
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    .log-container::-webkit-scrollbar-thumb:hover {
      background: rgba(138, 180, 248, 0.5);
    }

    .log-entry {
      padding: 14px 18px;
      margin-bottom: 10px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.7;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      transform: translate3d(0, 0, 0);
      animation: logEntryAppear 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes logEntryAppear {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .log-entry.info {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: #aec7fa;
    }

    .log-entry.success {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.2);
      color: #a8dab5;
    }

    .log-entry.warning {
      background: rgba(251, 188, 5, 0.08);
      border-color: rgba(251, 188, 5, 0.2);
      color: #fdd663;
    }

    .log-entry.error {
      background: rgba(242, 139, 130, 0.08);
      border-color: rgba(242, 139, 130, 0.2);
      color: #f8b4ae;
    }

    .log-time {
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      opacity: 0.6;
      margin-right: 12px;
      letter-spacing: 0.5px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    @media (max-width: 1024px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .aviram-surface {
        backdrop-filter: blur(12px) saturate(110%);
        -webkit-backdrop-filter: blur(12px) saturate(110%);
      }

      textarea {
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }
    }

    @media (prefers-contrast: high) {
      .aviram-surface {
        background: rgba(30, 33, 39, 0.95);
        backdrop-filter: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      textarea {
        background: rgba(10, 11, 13, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    .examples {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .example-btn {
      display: block;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 12px 18px;
      text-align: left;
      font-size: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 10px;
      margin-bottom: 8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      width: 100%;
      border: 1px solid transparent;
    }

    .example-btn:hover {
      background: rgba(138, 180, 248, 0.08);
      border-color: rgba(138, 180, 248, 0.2);
      color: var(--accent-primary);
      padding-left: 24px;
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.1);
    }

    .status-badge {
      display: inline-block;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 600;
      margin: 16px 0;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.3px;
    }

    .status-badge.success {
      background: rgba(129, 201, 149, 0.12);
      border-color: rgba(129, 201, 149, 0.4);
      color: var(--accent-secondary);
      box-shadow:
        0 4px 16px rgba(129, 201, 149, 0.2),
        0 0 24px rgba(129, 201, 149, 0.1);
    }

    .status-badge.error {
      background: rgba(242, 139, 130, 0.12);
      border-color: rgba(242, 139, 130, 0.4);
      color: #f8b4ae;
      box-shadow:
        0 4px 16px rgba(242, 139, 130, 0.2),
        0 0 24px rgba(242, 139, 130, 0.1);
    }

    .file-tree {
      margin-top: 24px;
      font-family: 'SF Mono', 'Courier New', monospace;
      font-size: 13px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(10, 11, 13, 0.4);
      padding: 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      line-height: 1.8;
    }

    .file-item {
      padding: 4px 0;
      padding-left: 20px;
      color: var(--text-secondary);
      transition: color 0.2s ease;
    }

    .file-item:hover {
      color: var(--accent-primary);
    }

    .file-item.folder {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .hidden {
      display: none;
    }

    .loading-spinner {
      border: 3px solid rgba(138, 180, 248, 0.2);
      border-top: 3px solid var(--accent-primary);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      display: inline-block;
      margin-left: 12px;
      vertical-align: middle;
      box-shadow: 0 0 20px rgba(138, 180, 248, 0.3);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .reset-link {
      color: var(--text-secondary);
      cursor: pointer;
      text-decoration: none;
      font-size: 13px;
      float: right;
      font-weight: 600;
      padding: 10px 18px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(138, 180, 248, 0.08);
      border: 1px solid rgba(138, 180, 248, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .reset-link:hover {
      background: rgba(138, 180, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      box-shadow: 0 2px 12px rgba(138, 180, 248, 0.2);
    }

    h2 {
      color: var(--text-primary);
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 20px;
      letter-spacing: -0.3px;
    }

    h3 {
      color: var(--text-primary);
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      opacity: 0.9;
    }

    p {
      color: var(--text-secondary);
      line-height: 1.7;
    }

    .system-status {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-secondary);
      box-shadow:
        0 0 20px var(--accent-secondary),
        0 0 40px rgba(129, 201, 149, 0.3);
      animation: pulse 3s ease-in-out infinite;
      z-index: 1000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    .api-config {
      margin-bottom: 24px;
      padding: 20px;
      background: rgba(251, 188, 5, 0.08);
      border: 1px solid rgba(251, 188, 5, 0.2);
      border-radius: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config.collapsed {
      background: rgba(129, 201, 149, 0.08);
      border-color: rgba(129, 201, 149, 0.3);
      padding: 16px 20px;
    }

    .api-config-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .api-config-status {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    .api-config-status .check-icon {
      color: var(--accent-secondary);
      font-size: 18px;
      font-weight: bold;
    }

    .api-config-status .status-text {
      color: var(--accent-secondary);
      font-weight: 600;
      font-size: 14px;
    }

    .api-config-actions {
      display: flex;
      gap: 8px;
    }

    .api-config-btn {
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 8px;
      border: 1px solid;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .api-config-btn.edit {
      color: var(--accent-primary);
      border-color: rgba(138, 180, 248, 0.3);
    }

    .api-config-btn.edit:hover {
      background: rgba(138, 180, 248, 0.1);
      border-color: var(--accent-primary);
    }

    .api-config-btn.clear {
      color: #f8b4ae;
      border-color: rgba(242, 139, 130, 0.3);
    }

    .api-config-btn.clear:hover {
      background: rgba(242, 139, 130, 0.1);
      border-color: rgba(242, 139, 130, 0.5);
    }

    .api-config-form {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .api-config-form.hidden {
      display: none;
    }

    .api-config input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(10, 11, 13, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: 'SF Mono', monospace;
      font-size: 13px;
      margin-top: 8px;
    }

    .api-config input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="aviram-surface header-surface">
      <h1>🏭 Deep Research Skill Factory</h1>
      <p class="subtitle">SKILL FACTORY • TURN WORKFLOWS INTO CLAUDE SUPERPOWERS</p>
    </div>

    <div class="aviram-surface">
      <div class="stepper" id="stepper"></div>
    </div>

    <div class="grid">
      <div>
        <div class="aviram-surface" id="inputCard">
          <div class="api-config" id="apiConfig">
            <!-- Collapsed State (shown when API key is saved) -->
            <div class="api-config-header hidden" id="apiConfigCollapsed">
              <div class="api-config-status">
                <span class="check-icon">✓</span>
                <span class="status-text">API Key Configured</span>
              </div>
              <div class="api-config-actions">
                <button class="api-config-btn edit" onclick="expandApiConfig()">Edit</button>
                <button class="api-config-btn clear" onclick="clearApiKey()">Clear</button>
              </div>
            </div>

            <!-- Expanded State (shown on first visit or when editing) -->
            <div class="api-config-form" id="apiConfigForm">
              <h3>⚙️ API Configuration</h3>
              <p style="font-size: 13px; margin-bottom: 8px;">Enter your Anthropic API key to enable skill generation:</p>
              <input
                type="password"
                id="apiKey"
                placeholder="sk-ant-..."
                autocomplete="off"
                onchange="saveApiKey()"
                onkeypress="if(event.key === 'Enter') saveApiKey()"
              />
              <p style="font-size: 11px; margin-top: 8px; opacity: 0.7;">Your key is stored locally in your browser only. Get one at console.anthropic.com</p>
            </div>
          </div>

          <h2>What do you want Claude to know how to do?</h2>
          <p style="color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
            Think of a workflow you repeat. A technical thing you explain constantly. A pattern you wish Claude just *knew*. Write it here. The system researches, architects, and packages it into a skill Claude can use forever.
          </p>
          <textarea
            id="skillInput"
            placeholder="Real examples that work:

• Parse PDF tables into clean JSON, handle malformed data gracefully
• Build type-safe React forms with accessible error states
• Wrap REST APIs with auth refresh, retry logic, request deduplication

The more texture you give, the sharper the output. But even 'email automation' is enough to start."
          ></textarea>
          <button class="btn" id="generateBtn" onclick="startGeneration()">
            Generate This Skill →
          </button>

          <div class="examples">
            <h3>Skills People Actually Use</h3>
            <button class="example-btn" onclick="setExample('Parse PDF tables and forms into structured JSON. Handle malformed PDFs, extract nested tables, preserve formatting context.')">→ PDF parsing with error handling</button>
            <button class="example-btn" onclick="setExample('Build accessible React forms with real-time validation, error recovery, and keyboard navigation. Include ARIA labels and focus management.')">→ Production-grade React forms</button>
            <button class="example-btn" onclick="setExample('Create REST API clients with token refresh, exponential backoff, request deduplication, and typed responses.')">→ Industrial-strength API wrappers</button>
          </div>
        </div>

        <div class="aviram-surface hidden" id="utilityCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Utility Analysis</h2>
            <a class="reset-link" onclick="resetFactory()">← New</a>
          </div>

          <div id="utilityResults">
            <!-- Category Badge Section -->
            <div id="categoryBadgeSection" style="margin-bottom: 24px;">
              <!-- Category badge will be injected here -->
            </div>

            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 20px;">
              <div style="flex: 1;">
                <h3>Utility Score</h3>
                <div style="font-size: 48px; font-weight: 700; color: var(--accent-primary);" id="utilityScoreDisplay">-/10</div>
                <div id="utilityCategoryDisplay" style="font-size: 14px; font-weight: 600; margin-top: 8px;"></div>
              </div>
              <div style="flex: 2;">
                <h3>Power-Up Statement</h3>
                <p id="powerUpStatement" style="font-size: 15px; line-height: 1.6; color: var(--text-primary);"></p>
              </div>
            </div>

            <div style="margin: 24px 0;">
              <h3>Reasoning</h3>
              <p id="utilityReasoning" style="color: var(--text-secondary); line-height: 1.7;"></p>
            </div>

            <!-- Category Explanation Section -->
            <div id="categoryExplanationSection" class="hidden" style="margin: 24px 0;">
              <!-- Category explanation will be injected here -->
            </div>

            <!-- Constraint Validation Report -->
            <div id="constraintValidationReport" class="hidden"></div>

            <div id="utilityProceedSection" class="hidden">
              <div class="status-badge success">
                ✓ HIGH UTILITY - Proceeding to Research
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                <strong>Research Direction:</strong> <span id="researchDirection"></span>
              </p>
              <button class="btn success" onclick="continueToResearch()">
                Continue to Research Phase →
              </button>
            </div>

            <div id="utilityRedesignSection" class="hidden">
              <div class="status-badge" style="background: rgba(251, 188, 5, 0.12); border-color: rgba(251, 188, 5, 0.4); color: #fdd663;">
                ⚠ MEDIUM UTILITY - Redesign Recommended
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                This skill has value but could be more focused. Choose a redesign suggestion or proceed anyway:
              </p>
              <div id="redesignOptions" style="margin: 20px 0;"></div>
              <div class="button-group">
                <button class="btn btn-secondary" onclick="proceedAnyway()">
                  Proceed Anyway
                </button>
                <button class="btn" onclick="resetFactory()">
                  Start Over
                </button>
              </div>
            </div>

            <div id="utilityRejectSection" class="hidden">
              <div class="status-badge error">
                ✗ LOW UTILITY - Rejected
              </div>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                <strong>Rejection Reason:</strong> <span id="rejectionReason"></span>
              </p>
              <p style="margin: 16px 0; color: var(--text-secondary);">
                Consider these high-utility alternatives instead:
              </p>
              <div id="rejectAlternatives" style="margin: 20px 0;"></div>
              <button class="btn" onclick="resetFactory()">
                Try New Skill Request
              </button>
            </div>
          </div>
        </div>

        <div class="aviram-surface hidden" id="progressCard">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
            <h2 style="margin: 0;">Progress</h2>
            <a class="reset-link" onclick="resetFactory()">← New</a>
          </div>

          <div id="progressSection">
            <div class="progress-text">
              <span id="progressStage">Initializing...</span>
              <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressMessage" style="margin-top: 14px; font-size: 14px;"></p>
          </div>

          <div id="resultsSection" class="hidden">
            <div class="status-badge success">
              ✓ Generation Complete
            </div>
            <p id="qualityScore" style="margin: 12px 0;"></p>

            <div class="button-group">
              <button class="btn success" id="downloadBtn" onclick="downloadSkill()">
                ⬇️ Download Skill Package
              </button>
              <button class="btn btn-secondary" id="copyPromptBtn" onclick="copyPromptToClipboard()">
                📋 Copy Prompt
              </button>
            </div>

            <div id="fileTree" class="file-tree"></div>
          </div>

          <div id="errorSection" class="hidden">
            <div class="status-badge error">
              ✗ Generation Failed
            </div>
            <p id="errorMessage" style="margin: 12px 0;"></p>
            <button class="btn" onclick="resetFactory()">Try Again</button>
          </div>
        </div>
      </div>

      <div class="aviram-surface">
        <h2>Generation Log</h2>
        <div class="log-container" id="logContainer">
          <p style="color: var(--text-secondary); opacity: 0.6;">Logs will appear here during generation...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="system-status" title="System Ready"></div>

  <script>
    function initAviramContext() {
      const supportsBackdropFilter = CSS.supports('backdrop-filter', 'blur(1px)') ||
                                     CSS.supports('-webkit-backdrop-filter', 'blur(1px)');

      if (!supportsBackdropFilter) {
        console.warn('Backdrop filter not supported - using fallback');
        document.querySelectorAll('.aviram-surface').forEach(el => {
          el.style.background = 'rgba(30, 33, 39, 0.95)';
        });
      }

      document.querySelectorAll('.aviram-surface').forEach(surface => {
        surface.addEventListener('mouseenter', function() {
          this.style.willChange = 'backdrop-filter, transform';
        });

        surface.addEventListener('mouseleave', function() {
          this.style.willChange = 'auto';
        });
      });
    }

    let currentStep = 0;
    let generatedSkillData = null;
    let isGenerating = false;

    const steps = ['Input', 'Utility Analysis', 'Research', 'Generate', 'Validate', 'Package'];
    const API_KEY_STORAGE_KEY = 'anthropic_api_key';

    // API Key localStorage Management
    function loadApiKey() {
      const savedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
      if (savedKey) {
        document.getElementById('apiKey').value = savedKey;
        collapseApiConfig();
      }
    }

    function saveApiKey() {
      const apiKey = document.getElementById('apiKey').value.trim();
      if (apiKey) {
        localStorage.setItem(API_KEY_STORAGE_KEY, apiKey);
        collapseApiConfig();
        addLog('API key saved locally', 'success');
      }
    }

    function collapseApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.add('collapsed');
      collapsedView.classList.remove('hidden');
      formView.classList.add('hidden');
    }

    function expandApiConfig() {
      const apiConfig = document.getElementById('apiConfig');
      const collapsedView = document.getElementById('apiConfigCollapsed');
      const formView = document.getElementById('apiConfigForm');

      apiConfig.classList.remove('collapsed');
      collapsedView.classList.add('hidden');
      formView.classList.remove('hidden');

      // Focus the input field
      document.getElementById('apiKey').focus();
    }

    function clearApiKey() {
      if (confirm('Are you sure you want to clear your saved API key?')) {
        localStorage.removeItem(API_KEY_STORAGE_KEY);
        document.getElementById('apiKey').value = '';
        expandApiConfig();
        addLog('API key cleared', 'info');
      }
    }

    function init() {
      initAviramContext();
      renderStepper();
      loadApiKey();
    }

    function renderStepper() {
      const stepper = document.getElementById('stepper');
      stepper.innerHTML = '';

      steps.forEach((stepName, index) => {
        const step = document.createElement('div');
        step.className = 'step';

        const circle = document.createElement('div');
        circle.className = 'step-circle';
        if (index === currentStep) circle.classList.add('active');
        if (index < currentStep) circle.classList.add('complete');
        circle.textContent = index < currentStep ? '✓' : index + 1;

        const label = document.createElement('div');
        label.className = 'step-label';
        if (index === currentStep) label.classList.add('active');
        label.textContent = stepName;

        const line = document.createElement('div');
        line.className = 'step-line';
        if (index < currentStep) line.classList.add('complete');

        step.appendChild(circle);
        step.appendChild(label);
        step.appendChild(line);
        stepper.appendChild(step);
      });
    }

    function setStep(step) {
      currentStep = step;
      renderStepper();
    }

    function setExample(text) {
      document.getElementById('skillInput').value = text;
    }

    function addLog(message, type = 'info') {
      const container = document.getElementById('logContainer');

      if (container.querySelector('p')) {
        container.innerHTML = '';
      }

      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;

      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `<span class="log-time">${time}</span>${message}`;

      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }

    function updateProgress(stage, percent, message) {
      document.getElementById('progressStage').textContent = stage;
      document.getElementById('progressPercent').textContent = `${percent}%`;
      document.getElementById('progressFill').style.width = `${percent}%`;
      document.getElementById('progressMessage').textContent = message;
    }

    function showError(message) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('errorSection').classList.remove('hidden');
      document.getElementById('errorMessage').textContent = message;
    }

    function showResults(validation, tree, filename) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('resultsSection').classList.remove('hidden');
      document.getElementById('qualityScore').textContent = `Quality Score: ${validation.qualityScore}/100`;

      const treeHtml = renderFileTree(tree);
      document.getElementById('fileTree').innerHTML = `<strong style="color: var(--accent-primary);">📦 Package Contents</strong>${treeHtml}`;
    }

    function renderFileTree(node, depth = 0) {
      let html = '';
      const indent = '  '.repeat(depth);

      if (node.type === 'folder') {
        html += `<div class="file-item folder">${indent}📁 ${node.name}/</div>`;
        if (node.children) {
          node.children.forEach(child => {
            html += renderFileTree(child, depth + 1);
          });
        }
      } else {
        const size = node.size ? ` (${(node.size / 1024).toFixed(1)} KB)` : '';
        html += `<div class="file-item file">${indent}📄 ${node.name}${size}</div>`;
      }

      return html;
    }

    function sanitizeFileName(name) {
      return name
        .toLowerCase()
        .replace(/[<>:"/\\|?*\x00-\x1F]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 255);
    }

    async function callClaude(prompt, maxTokens = 2000) {
      const apiKey = document.getElementById('apiKey').value.trim();

      if (!apiKey) {
        throw new Error('Please enter your Anthropic API key');
      }

      try {
        const response = await fetch("/api/claude", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            apiKey,
            prompt,
            maxTokens
          })
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.error || `API request failed with status ${response.status}`);
        }

        const data = await response.json();
        return data.text;
      } catch (err) {
        if (err.message.includes('API request failed')) {
          throw err;
        }
        throw new Error(`Network error: ${err.message}. Check your API key and internet connection.`);
      }
    }

    async function extractRequirements(input) {
      addLog('Analyzing input and extracting requirements...', 'info');
      updateProgress('Input Processing', 10, 'Parsing requirements...');

      const prompt = `Extract skill requirements from this input as JSON:

INPUT: ${input}

Return ONLY valid JSON (no markdown):
{
  "skill_name": "lowercase-hyphenated-name",
  "description": "what it does and when to use it",
  "programming_language": "python|javascript|bash",
  "complexity": "simple|moderate|complex",
  "required_apis": ["api1", "api2"],
  "key_features": ["feature1", "feature2"],
  "needs_scripts": true|false,
  "needs_references": false
}`;

      try {
        let response = await callClaude(prompt);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const extracted = JSON.parse(response);

        addLog(`Extracted skill: ${extracted.skill_name}`, 'success');
        updateProgress('Input Processing', 100, 'Requirements extracted');
        return extracted;
      } catch (err) {
        throw new Error(`Failed to extract requirements: ${err.message}`);
      }
    }

    async function analyzeUtility(requirements) {
      addLog('Analyzing skill utility...', 'info');
      updateProgress('Utility Analysis', 10, 'Evaluating utility value...');

      const prompt = `You are the Universal Utility Analyzer. Your job is to determine whether
a skill request will genuinely power up Claude or if it's just organized
documentation that Claude can already produce.

Your north star: Skills should make Claude measurably better at something,
not just give it well-organized information it already has.

Evaluate this skill request using the three universal questions:

1. Can Claude already do this well from training data?
2. What specific value does this skill provide that Claude doesn't have?
   - Executable code solving hard problems?
   - Embedded domain data or algorithms?
   - Non-obvious patterns/edge cases?
   - 2x+ performance improvement?
3. Can you complete: "This skill powers up Claude by: [SPECIFIC CAPABILITY]"?

Apply scoring: executable code (HIGH), embedded data (HIGH), domain patterns (HIGH),
generic documentation (LOW), templates Claude can generate (LOW), vague capability (LOW).

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

Output your analysis as JSON with these exact fields:
{
  "utility_score": 0-10,
  "utility_category": "HIGH_UTILITY|MEDIUM_UTILITY|LOW_UTILITY",
  "power_up_statement": "This skill powers up Claude by: [specific and testable capability]",
  "reasoning": "Why this scores as high/medium/low",
  "research_direction": "What to focus on if proceeding",
  "rejection_reason": "Why rejected (only if LOW_UTILITY)",
  "recommended_redesigns": ["Alternative 1", "Alternative 2", "Alternative 3"],
  "domain": "detected domain",
  "phase_routing": "PROCEED|REDESIGN|REJECT"
}

ROUTING RULES:
- Score 7-10: "PROCEED" (HIGH_UTILITY)
- Score 4-6: "REDESIGN" (MEDIUM_UTILITY) - suggest 2-3 alternatives
- Score 0-3: "REJECT" (LOW_UTILITY) - suggest 2-3 alternatives

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const analysis = JSON.parse(response);

        // Validate response structure
        if (!analysis.utility_score || !analysis.utility_category || !analysis.phase_routing) {
          throw new Error('Invalid analysis structure received');
        }

        addLog(`Utility score: ${analysis.utility_score}/10 (${analysis.utility_category})`,
               analysis.utility_score >= 7 ? 'success' : analysis.utility_score >= 4 ? 'warning' : 'error');
        addLog(`Power-up: ${analysis.power_up_statement}`, 'info');
        updateProgress('Utility Analysis', 100, `Analysis complete: ${analysis.phase_routing}`);

        return analysis;
      } catch (err) {
        throw new Error(`Utility analysis failed: ${err.message}`);
      }
    }

    async function categorizeSkill(skillInput, requirements) {
      /**
       * PHASE 0 CATEGORIZATION GATE
       *
       * Categorize skill request to determine if it's a real power-up.
       * This gate prevents template/executor skills from scoring HIGH_UTILITY.
       *
       * Categories:
       * - TEMPLATE: Code generation (NOT power-up, max 3/10)
       * - METHODOLOGY: Reasoning frameworks (REAL power-up, max 9/10)
       * - KNOWLEDGE: Domain knowledge (REAL power-up, max 9/10)
       * - PROCESSOR: Processing/analysis logic (REAL power-up, max 9/10)
       * - EXECUTOR: External automation (NOT power-up, max 2/10)
       */
      addLog('Categorizing skill type...', 'info');

      const prompt = `Categorize this skill request. The category determines the maximum
utility score and whether it's a real power-up for Claude.

Skill request: ${skillInput}
Skill name: ${requirements.skill_name}
Description: ${requirements.description}

Return ONLY valid JSON (no markdown, no extra text):
{
  "category": "TEMPLATE|METHODOLOGY|KNOWLEDGE|PROCESSOR|EXECUTOR",
  "category_reasoning": "why this category",
  "is_real_power_up": boolean,
  "max_utility_score": integer (0-10),
  "power_up_description": "if true, what new capability Claude gains",
  "indicators_found": ["list of words/phrases that indicated category"]
}

DEFINITION GUIDE:

TEMPLATE: Code generation tools for humans to implement
- Claude does: Recommend code templates
- Claude gains: Nothing (already knows these patterns)
- Examples: "web scraping framework", "API client generator", "boilerplate generator"
- Max utility: 3/10
- Indicators: "framework", "generator", "templates", "examples", "boilerplate", "scaffolding"

METHODOLOGY: Reasoning frameworks Claude applies directly
- Claude does: Use reasoning process
- Claude gains: New way of thinking about problems
- Examples: "contradiction detector", "research methodology", "verification framework"
- Max utility: 9/10
- Indicators: "methodology", "framework for thinking", "systematic approach", "process"

KNOWLEDGE: Domain knowledge Claude uses in reasoning
- Claude does: Apply knowledge in analysis
- Claude gains: New domain expertise
- Examples: "constraint patterns", "best practices", "optimization algorithms"
- Max utility: 9/10
- Indicators: "patterns", "rules", "algorithms", "best practices", "knowledge base"

PROCESSOR: Processing/analysis logic Claude executes
- Claude does: Execute processing/analysis
- Claude gains: New capability to analyze/process
- Examples: "query analyzer", "text classifier", "contradiction detector", "motion generator"
- Max utility: 9/10
- Indicators: "analyzer", "detector", "scorer", "classifier", "processor", "generator"

EXECUTOR: External automation (not Claude thinking)
- Claude does: Recommend automation scripts
- Claude gains: Nothing (Claude can't execute)
- Examples: "database runner", "deployment automator", "CI/CD executor"
- Max utility: 2/10
- Indicators: "runner", "executor", "automation", "deployment", "runs code"

CRITICAL: Be strict about categorization.
- If unsure between TEMPLATE and METHODOLOGY, ask: "Can Claude apply
  this in reasoning?" If NO → TEMPLATE. If YES → METHODOLOGY.
- If unsure between PROCESSOR and EXECUTOR, ask: "Does Claude do the
  thinking?" If YES → PROCESSOR. If NO → EXECUTOR.
- If skill name contains "generator" or "framework" BUT generates content/logic
  (not just code templates), classify as PROCESSOR not TEMPLATE.
  Example: "physics motion generator" → PROCESSOR (Claude generates motion)
  Example: "API client framework" → TEMPLATE (just code templates)`;

      try {
        let response = await callClaude(prompt, 500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const categorization = JSON.parse(response);

        addLog(`✓ Category: ${categorization.category}`, 'info');
        addLog(`✓ Real power-up: ${categorization.is_real_power_up}`, 'info');
        addLog(`✓ Max utility for ${categorization.category}: ${categorization.max_utility_score}/10`, 'info');

        return categorization;
      } catch (err) {
        throw new Error(`Categorization failed: ${err.message}`);
      }
    }

    // ========== DOMAIN EXTRACTION & VALIDATION ==========
    // Prevents domain pivoting bug by extracting practitioners and validating suggestions

    async function extractDomainContext(requirements, detectedDomain) {
      /**
       * Extract comprehensive domain context including practitioners and exclusions
       * Returns domain metadata to constrain Problem Identifier Agent
       */
      const prompt = `Extract domain context from this skill request to prevent domain pivoting.

Skill Request: ${requirements.skill_name}
Description: ${requirements.description || 'N/A'}
Detected Domain: ${detectedDomain}

Return JSON with:
{
  "primary_domain": "exact domain name (e.g., 'web research', 'motion design', 'backend coding')",
  "domain_category": "CREATIVE|CODING|RESEARCH|AUTOMATION|FINANCE|DESIGN|WORKFLOW|DATA|COMMUNICATION",
  "domain_practitioners": ["list of 2-4 specific practitioner types who work in this domain"],
  "domain_context": "brief 1-sentence explanation of what this domain involves",
  "excluded_domains": ["list of 3-5 related but DIFFERENT domains to NOT pivot to"]
}

Examples:

Input: "web research analyst skill"
Output: {
  "primary_domain": "web research",
  "domain_category": "RESEARCH",
  "domain_practitioners": ["journalists", "researchers", "competitive analysts", "fact-checkers"],
  "domain_context": "Research and verification of information from web sources",
  "excluded_domains": ["investment research", "financial analysis", "M&A due diligence", "market research", "academic research"]
}

Input: "motion design skill"
Output: {
  "primary_domain": "motion design",
  "domain_category": "CREATIVE",
  "domain_practitioners": ["animators", "motion designers", "VFX artists", "animation directors"],
  "domain_context": "Creating animated motion graphics and visual effects",
  "excluded_domains": ["product design", "UX design", "frontend development", "game development", "video editing"]
}

Input: "database schema generator"
Output: {
  "primary_domain": "backend coding",
  "domain_category": "CODING",
  "domain_practitioners": ["backend engineers", "database engineers", "API developers", "systems architects"],
  "domain_context": "Server-side development and database management",
  "excluded_domains": ["frontend development", "DevOps", "data science", "data analytics", "cloud architecture"]
}

Return ONLY the JSON object.`;

      try {
        let response = await callClaude(prompt, 500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        return JSON.parse(response);
      } catch (err) {
        // Fallback to basic domain context
        return {
          primary_domain: detectedDomain,
          domain_category: "GENERAL",
          domain_practitioners: ["practitioners", "users", "professionals"],
          domain_context: `Work in the ${detectedDomain} domain`,
          excluded_domains: ["other domains", "unrelated industries"]
        };
      }
    }

    async function validateDomainRelevance(userDomain, problemAnalysis, practitioners) {
      /**
       * Validate that ALL suggestions stay within the user's specified domain
       * Returns validation results with scores and issues
       */
      const suggestions = problemAnalysis.redesign_suggestions || [];
      const validationResults = [];
      const scores = [];

      for (let i = 0; i < suggestions.length; i++) {
        const suggestion = suggestions[i];

        // Check if domain_relevance_score is present and sufficient
        const score = suggestion.domain_relevance_score || 0;
        scores.push(score);

        if (score < 7) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Low domain relevance score: ${score}/10 (minimum 7 required)`,
            score: score,
            recommendation: 'REJECT'
          });
        }

        // Validate that suggestion mentions user domain practitioners or domain
        const suggestionText = JSON.stringify(suggestion).toLowerCase();
        const domainLower = userDomain.toLowerCase();
        const practitionersFound = practitioners.some(p =>
          suggestionText.includes(p.toLowerCase())
        );
        const domainMentioned = suggestionText.includes(domainLower);

        if (!practitionersFound && !domainMentioned) {
          validationResults.push({
            suggestion: suggestion.redesigned_skill,
            issue: `Does not mention ${userDomain} domain or its practitioners`,
            score: score,
            recommendation: 'REJECT'
          });
        }
      }

      return {
        domain: userDomain,
        total_suggestions: suggestions.length,
        validation_issues: validationResults,
        all_relevant: validationResults.length === 0,
        scores: scores,
        issues: validationResults,
        recommendation: validationResults.length === 0 ? 'PROCEED' : 'REVISE'
      };
    }

    // ========== PROBLEM IDENTIFIER AGENT ==========

    async function analyzeProblem(requirements, utilityAnalysis) {
      addLog('Identifying real practitioner problems...', 'info');
      updateProgress('Problem Analysis', 30, 'Researching domain pain points...');

      // Step 1: Enhanced domain extraction with practitioners
      addLog(`Extracting domain context for: ${utilityAnalysis.domain}`, 'info');
      const domainContext = await extractDomainContext(requirements, utilityAnalysis.domain);
      addLog(`✓ Domain identified: ${domainContext.primary_domain}`, 'success');
      addLog(`✓ Domain practitioners: ${domainContext.domain_practitioners.join(', ')}`, 'info');

      const prompt = `You are the Problem Identifier Agent for the ${domainContext.primary_domain} domain.

⚠️ CRITICAL CONSTRAINT - DOMAIN LOCK ⚠️
ALL problem identification and redesign suggestions must be grounded EXCLUSIVELY
in the ${domainContext.primary_domain} domain and for practitioners who work in
this domain. Do NOT pivot to other industries or domains.

Domain: ${domainContext.primary_domain}
Practitioners: ${domainContext.domain_practitioners.join(', ')}
Domain Context: ${domainContext.domain_context}

🚫 DO NOT PIVOT TO THESE UNRELATED DOMAINS:
${domainContext.excluded_domains.map(d => `- ${d}`).join('\n')}

Your job is to research what practitioners in the ${domainContext.primary_domain}
domain actually struggle with, then suggest skill redesigns grounded in those
real problems.

Given a skill request, answer:

1. PRACTITIONER PAIN POINTS (MUST BE IN ${domainContext.primary_domain.toUpperCase()})
   - What do ${domainContext.domain_practitioners.join(' or ')} struggle with? (Be specific, not generic)
   - What's their current workaround? (How do they solve it today?)
   - What does this problem cost them? (Time, money, errors)
   - How often do they face this? (Daily, per project, rare?)
   - Example: Not "budgeting is hard" but "predicting multi-location
     shoot costs with labor conflicts takes 8+ hours per production"

   ⚠️ VERIFY: Does this problem apply to ${domainContext.domain_practitioners.join(' or ')}
   in ${domainContext.primary_domain}? If NO, find a different problem.

2. CLAUDE CAPABILITY GAP (SPECIFIC TO ${domainContext.primary_domain.toUpperCase()})
   - What specifically can't Claude do well for ${domainContext.primary_domain}? (Not "general advice")
   - What would Claude need to do this? (Be concrete)
   - Example: "Claude can discuss budgeting but cannot model
     constraint satisfaction with location-specific dependencies"

3. VALUE UNLOCK (MEASURABLE FOR ${domainContext.primary_domain.toUpperCase()} PRACTITIONERS)
   - What would solving this unlock for ${domainContext.domain_practitioners.join(' or ')}? (Measurable outcome)
   - How much time/money would it save? (Be specific)
   - What becomes possible? (New capability)
   - Example: "Generating accurate cost predictions in minutes vs.
     8+ hours, preventing 5-15% budget overruns"

Then suggest 2-3 redesigns where each:
- Targets ONE specific practitioner pain point IN ${domainContext.primary_domain.toUpperCase()}
- States what Claude can't do that's needed FOR ${domainContext.primary_domain.toUpperCase()}
- Shows why it would be HIGH_UTILITY
- Includes measurable outcome FOR ${domainContext.domain_practitioners.join(' or ')}
- Describes specific implementation (what data in → what out)

Focus on PROBLEMS in ${domainContext.primary_domain}, not generic technical additions.

❌ EXAMPLE OF BAD DOMAIN PIVOTING (DO NOT DO THIS):
  User domain: "web research"
  Bad suggestion: "Investment analyst due diligence problems" ← WRONG! Different domain!

✅ EXAMPLE OF GOOD DOMAIN-CONSTRAINED APPROACH:
  User domain: "web research"
  Good suggestion: "Cross-reference contradiction detector for journalists" ← CORRECT! Same domain!

If you cannot find domain-relevant problems that would be solved by a higher-utility
skill in ${domainContext.primary_domain}, explicitly state:
"No high-utility redesign opportunities identified in ${domainContext.primary_domain}.
The original skill concept may not have sufficient problem-solving potential in this domain."

SKILL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

CURRENT UTILITY ANALYSIS:
Score: ${utilityAnalysis.utility_score}/10
Category: ${utilityAnalysis.utility_category}
Domain: ${utilityAnalysis.domain}
Power-up: ${utilityAnalysis.power_up_statement}

Return JSON with this exact structure:
{
  "domain_analysis": {
    "user_specified_domain": "${domainContext.primary_domain}",
    "domain_verified": true,
    "domain_constraints_applied": true,
    "practitioners_analyzed": ${JSON.stringify(domainContext.domain_practitioners)}
  },
  "domain_research": {
    "practitioner_pain_points": [
      {
        "problem": "Specific problem practitioners face IN ${domainContext.primary_domain.toUpperCase()}",
        "why_hard": "What makes this challenging",
        "current_workaround": "How they solve it now",
        "cost_of_problem": "Time/money/errors cost",
        "frequency": "How often this occurs",
        "domain_relevance_score": 8-10
      }
    ],
    "claude_capability_gap": "What Claude specifically cannot do well for ${domainContext.primary_domain}",
    "value_unlock": "What would be unlocked by solving this FOR ${domainContext.domain_practitioners.join(' or ')}"
  },
  "redesign_suggestions": [
    {
      "original_skill": "${requirements.skill_name}",
      "redesigned_skill": "new-skill-name with specific capability",
      "problem_it_solves": "Specific practitioner pain point addressed IN ${domainContext.primary_domain.toUpperCase()}",
      "claude_power_up": "Specific capability this adds to Claude FOR ${domainContext.primary_domain.toUpperCase()}",
      "estimated_utility_score": 7-9,
      "why_higher_utility": "Why this scores higher than original",
      "measurable_outcome": "Concrete, measurable result FOR ${domainContext.domain_practitioners.join(' or ')}",
      "specific_implementation": "What data goes in → what comes out",
      "domain_relevance_score": 8-10,
      "domain_fit_explanation": "Why this is relevant to ${domainContext.primary_domain}"
    }
  ]
}

⚠️ FINAL VALIDATION BEFORE RETURNING:
Review ALL suggestions and verify EVERY problem/redesign is exclusively relevant
to ${domainContext.primary_domain} and its practitioners. If ANY suggestion
mentions or targets a different domain, REJECT it and replace with an in-domain
alternative.

Return ONLY the JSON object, no markdown, no other text.`;

      try {
        let response = await callClaude(prompt, 2500);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const problemAnalysis = JSON.parse(response);

        // Step 2: Validate domain relevance of all suggestions
        addLog('Validating problem domain relevance...', 'info');
        const validation = await validateDomainRelevance(
          domainContext.primary_domain,
          problemAnalysis,
          domainContext.domain_practitioners
        );

        if (validation.all_relevant) {
          addLog(`✓ All ${validation.total_suggestions} suggestions verified in-domain`, 'success');
          addLog(`✓ Domain relevance scores: ${validation.scores.join(', ')}`, 'info');
        } else {
          addLog(`⚠ ${validation.issues.length} domain pivoting issues detected`, 'warning');
          validation.issues.forEach(issue => {
            addLog(`  - ${issue.suggestion}: ${issue.issue}`, 'warning');
          });
          throw new Error('Domain pivoting detected - suggestions cross into unrelated domains');
        }

        addLog('Problem analysis complete', 'success');
        updateProgress('Problem Analysis', 100, 'Problem-grounded redesigns identified');

        return problemAnalysis;
      } catch (err) {
        addLog('Problem analysis failed - using fallback', 'warning');
        // Return a basic structure if analysis fails
        return {
          domain_research: {
            practitioner_pain_points: [{
              problem: "Generic workflow inefficiency",
              why_hard: "Manual process",
              current_workaround: "Manual work",
              cost_of_problem: "Time consuming",
              frequency: "Regular"
            }],
            claude_capability_gap: "Needs more specific capabilities",
            value_unlock: "Improved efficiency"
          },
          redesign_suggestions: utilityAnalysis.recommended_redesigns.map(r => ({
            original_skill: requirements.skill_name,
            redesigned_skill: r,
            problem_it_solves: "Addresses domain-specific challenges",
            claude_power_up: "Enhanced capabilities for this domain",
            estimated_utility_score: 7,
            why_higher_utility: "More focused on solving specific problems",
            measurable_outcome: "Improved workflow efficiency",
            specific_implementation: "Framework-based approach"
          }))
        };
      }
    }

    // ========== CONSTRAINT VALIDATION GATE ==========
    // Prevents false power-up claims that contradict skill's own constraints

    function extractYAMLConstraints(text) {
      /**
       * Extract constraints from YAML frontmatter (primary source)
       * Looks for metadata.constraints field in YAML section
       */
      const constraints = [];

      try {
        // Find YAML frontmatter (between --- delimiters)
        const yamlMatch = text.match(/^---\s*\n([\s\S]*?)\n---/);
        if (!yamlMatch) {
          return constraints; // No YAML frontmatter found
        }

        const yamlText = yamlMatch[1];

        // Simple YAML parsing for constraints field
        // Look for "constraints:" or "  constraints:" (nested in metadata)
        const constraintsMatch = yamlText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
        if (constraintsMatch) {
          // Found top-level constraints
          const constraintStr = constraintsMatch[1].trim();
          // Split by period or newline
          const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
          constraints.push(...splitConstraints.map(c => c.trim()));
        }

        // Also check for nested metadata.constraints
        const metadataSection = yamlText.match(/metadata:\s*\n([\s\S]*?)(?=\n\S|\n---|\n$)/);
        if (metadataSection) {
          const metadataText = metadataSection[1];
          const metadataConstraintsMatch = metadataText.match(/^\s*constraints:\s*["']?(.*?)["']?\s*$/m);
          if (metadataConstraintsMatch) {
            const constraintStr = metadataConstraintsMatch[1].trim();
            const splitConstraints = constraintStr.split(/[.]\s*/).filter(c => c.trim());
            constraints.push(...splitConstraints.map(c => c.trim()));
          }
        }
      } catch (err) {
        // If YAML parsing fails, return empty and fall back to text extraction
        console.warn('YAML constraint extraction failed:', err);
      }

      return constraints;
    }

    function extractTextConstraints(description) {
      /**
       * Extract constraint statements from text (secondary source)
       * Looks for constraint keywords in description body
       */
      const constraintKeywords = [
        'Cannot',
        'cannot',
        'Cannot access',
        'Cannot perform',
        'No access to',
        'Does not',
        'Cannot provide',
        'Limited to',
        'Restricted',
        'No real-time',
        'Users must',
        'User must',
        'Requires user to',
        'Not available',
        'Unable to',
        'No live',
        'Not capable'
      ];

      const constraints = [];
      const lines = description.split(/[.!?\n]/);

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Skip YAML frontmatter lines
        if (trimmed === '---') continue;
        if (trimmed.includes(':') && trimmed.split(':')[0].match(/^\s*[a-z_]+$/)) {
          // Likely a YAML field, skip
          continue;
        }

        for (const keyword of constraintKeywords) {
          if (trimmed.includes(keyword)) {
            // Clean up markdown formatting
            let cleaned = trimmed.replace(/^[*\-]\s*/, '').replace(/^\*\*/, '').replace(/\*\*$/, '');
            cleaned = cleaned.trim();
            if (cleaned && cleaned.length > 10) { // Avoid single words
              constraints.push(cleaned);
              break; // Don't add same line multiple times
            }
          }
        }
      }

      return constraints;
    }

    function extractConstraints(description) {
      /**
       * Extract ALL constraints from YAML metadata + description text
       * Returns array of constraint strings
       */
      const constraints = [];

      // Priority 1: YAML metadata constraints (most reliable)
      const yamlConstraints = extractYAMLConstraints(description);
      constraints.push(...yamlConstraints);

      // Priority 2: Text-based constraints (supplementary)
      const textConstraints = extractTextConstraints(description);

      // Deduplicate - avoid repeating similar constraints
      for (const textConstraint of textConstraints) {
        const textLower = textConstraint.toLowerCase();
        const isDuplicate = constraints.some(existing => {
          const existingLower = existing.toLowerCase();
          // Check for substantial overlap
          return existingLower.includes(textLower) || textLower.includes(existingLower);
        });

        if (!isDuplicate) {
          constraints.push(textConstraint);
        }
      }

      return constraints;
    }

    function extractPowerUpClaims(powerUpStatement) {
      /**
       * Extract specific capability claims from power-up statement
       * Returns array of claimed capabilities
       */
      const claims = [];
      const statement = powerUpStatement.toLowerCase();

      // Common claim markers
      const markers = [
        'providing',
        'enables',
        'powers up',
        'generates',
        'creates',
        'executes',
        'performs',
        'offers',
        'delivers',
        'gives',
        'adds'
      ];

      // Extract phrases after markers
      for (const marker of markers) {
        const regex = new RegExp(marker + '\\s+([^,;.]+)', 'gi');
        const matches = statement.matchAll(regex);

        for (const match of matches) {
          if (match[1]) {
            claims.push(match[1].trim());
          }
        }
      }

      // Also look for capability keywords directly
      const capabilityKeywords = [
        'web scraping',
        'data extraction',
        'real-time',
        'live data',
        'api calls',
        'database access',
        'authentication',
        'automated',
        'executable',
        'integration'
      ];

      for (const keyword of capabilityKeywords) {
        if (statement.includes(keyword)) {
          claims.push(keyword);
        }
      }

      return [...new Set(claims)]; // Remove duplicates
    }

    function validateConstraints(requirements, utilityAnalysis) {
      /**
       * Main constraint validation function
       * Checks if power-up claims contradict skill's own constraints
       * Returns validation report with revised score if needed
       */
      const description = requirements.description;
      const powerUpStatement = utilityAnalysis.power_up_statement;

      // Step 1: Extract constraints
      const constraints = extractConstraints(description);

      if (constraints.length === 0) {
        // No constraints found, analysis is valid as-is
        return {
          hasConstraints: false,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 2: Extract power-up claims
      const claims = extractPowerUpClaims(powerUpStatement);

      if (claims.length === 0) {
        // No specific claims found, analysis is valid as-is
        return {
          hasConstraints: true,
          constraints: constraints,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 3: Check for contradictions
      const contradictions = [];
      const validClaims = [];

      for (const claim of claims) {
        let isContradicted = false;
        let conflictingConstraint = null;

        for (const constraint of constraints) {
          if (detectContradiction(claim, constraint)) {
            isContradicted = true;
            conflictingConstraint = constraint;
            contradictions.push({
              claim: claim,
              constraint: conflictingConstraint,
              reason: 'Claim contradicts explicit constraint'
            });
            break;
          }
        }

        if (!isContradicted) {
          validClaims.push(claim);
        }
      }

      // Step 4: If no contradictions, return original analysis
      if (contradictions.length === 0) {
        return {
          hasConstraints: true,
          constraints: constraints,
          claimsChecked: claims.length,
          hasContradictions: false,
          originalAnalysis: utilityAnalysis
        };
      }

      // Step 5: Contradictions found - recalculate score
      const validClaimsRatio = validClaims.length / claims.length;
      const originalScore = utilityAnalysis.utility_score;
      const newScore = recalculateUtilityScore(
        originalScore,
        contradictions.length,
        validClaimsRatio
      );

      // Step 6: Rebuild power-up statement
      const revisedPowerUp = validClaims.length > 0
        ? `This skill powers up Claude by: ${validClaims.join(', ')}`
        : '⚠️ No valid power-up statement (claims contradicted by constraints)';

      // Step 7: Update category based on new score
      const revisedCategory = categorizeUtilityScore(newScore);

      // Step 8: Update phase routing based on new score
      const revisedRouting = newScore >= 7 ? 'PROCEED'
        : newScore >= 4 ? 'REDESIGN'
        : 'REJECT';

      // Step 9: Build revised analysis
      const revisedAnalysis = {
        ...utilityAnalysis,
        utility_score: newScore,
        utility_category: revisedCategory,
        power_up_statement: revisedPowerUp,
        phase_routing: revisedRouting,
        reasoning: utilityAnalysis.reasoning +
          `\n\n⚠️ CONSTRAINT VALIDATION ADJUSTMENT: Original score ${originalScore}/10 reduced to ${newScore}/10. ` +
          `${contradictions.length} power-up claim(s) contradicted by skill's own constraints.`
      };

      return {
        hasConstraints: true,
        constraints: constraints,
        claimsChecked: claims.length,
        hasContradictions: true,
        contradictions: contradictions,
        validClaims: validClaims,
        originalScore: originalScore,
        revisedScore: newScore,
        scoreChange: newScore - originalScore,
        validClaimsRatio: validClaimsRatio,
        originalAnalysis: utilityAnalysis,
        revisedAnalysis: revisedAnalysis
      };
    }

    function detectContradiction(claim, constraint) {
      /**
       * Check if a claim contradicts a constraint
       * Returns true if contradiction detected
       *
       * IMPORTANT: Only explicit prohibitions (cannot, no access, etc.) are contradictions.
       * Requirements like "users must provide API key" are NOT contradictions - they indicate
       * the capability exists but needs user input.
       */
      const claimLower = claim.toLowerCase();
      const constraintLower = constraint.toLowerCase();

      // Contradiction patterns - ONLY explicit prohibitions
      const contradictionMap = {
        'web scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'scraping': ['cannot scrape', 'cannot access', 'no scraping', 'cannot perform', 'no access to'],
        'data extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'extraction': ['cannot extract', 'cannot access', 'no extraction', 'no access to'],
        'real-time': ['cannot real-time', 'no real-time', 'cannot access live', 'not real-time', 'no access to'],
        'live data': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'live': ['cannot access', 'no live', 'cannot real-time', 'no access to'],
        'api calls': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'api': ['cannot call', 'no api', 'cannot access', 'no access to'],
        'authentication': ['cannot authenticate', 'no auth', 'cannot access', 'no access to'],
        'database': ['cannot access', 'no database', 'no access to'],
        'automated': ['cannot automate', 'no automation'],
        'executable': ['cannot execute', 'no execution'],
        'integration': ['cannot integrate', 'no integration', 'no access to']
      };

      // Check if claim matches any contradiction pattern
      for (const [keyword, blockPatterns] of Object.entries(contradictionMap)) {
        if (claimLower.includes(keyword)) {
          for (const pattern of blockPatterns) {
            if (constraintLower.includes(pattern)) {
              return true;
            }
          }
        }
      }

      // Additional word-overlap check - ONLY for explicit prohibitions
      const claimWords = new Set(claimLower.split(/\s+/).filter(w => w.length > 3));
      const constraintWords = constraintLower.split(/\s+/).filter(w => w.length > 3);

      // If constraint says "cannot X" or "no access to X" and claim includes "X", it's a contradiction
      if (constraintLower.includes('cannot') || constraintLower.includes('no access')) {
        for (const word of claimWords) {
          if (constraintWords.includes(word)) {
            return true;
          }
        }
      }

      return false;
    }

    function recalculateUtilityScore(originalScore, contradictionCount, validClaimsRatio) {
      /**
       * Recalculate utility score based on constraint contradictions
       * Each contradiction = -2 points
       * If <50% of claims are valid = -4 additional points
       */
      let penalty = contradictionCount * 2;

      if (validClaimsRatio < 0.5) {
        penalty += 4;
      }

      const newScore = Math.max(0, originalScore - penalty);
      return newScore;
    }

    function categorizeUtilityScore(score) {
      /**
       * Convert numeric score to category
       */
      if (score >= 7) return 'HIGH_UTILITY';
      if (score >= 4) return 'MEDIUM_UTILITY';
      return 'LOW_UTILITY';
    }

    let utilityAnalysisResult = null;
    let currentRequirements = null;
    let problemAnalysisResult = null;

    async function showUtilityResults(analysis, validationResult = null) {
      document.getElementById('utilityCard').classList.remove('hidden');

      // Display category badge and explanation
      const categoryBadgeSection = document.getElementById('categoryBadgeSection');
      const categoryExplanationSection = document.getElementById('categoryExplanationSection');

      if (analysis.skill_category) {
        // Category color and icon mapping
        const categoryConfig = {
          'TEMPLATE': { color: '#f8b4ae', icon: '📄', label: 'TEMPLATE', powerUp: false },
          'METHODOLOGY': { color: '#8ab4f8', icon: '🧠', label: 'METHODOLOGY', powerUp: true },
          'KNOWLEDGE': { color: '#81c995', icon: '📚', label: 'KNOWLEDGE', powerUp: true },
          'PROCESSOR': { color: '#fdd663', icon: '⚙️', label: 'PROCESSOR', powerUp: true },
          'EXECUTOR': { color: '#f8b4ae', icon: '🤖', label: 'EXECUTOR', powerUp: false }
        };

        const config = categoryConfig[analysis.skill_category] || { color: '#9aa0a6', icon: '❓', label: analysis.skill_category, powerUp: false };

        // Display category badge
        categoryBadgeSection.innerHTML = `
          <div style="background: rgba(${config.powerUp ? '138, 180, 248' : '248, 180, 174'}, 0.1); border: 1px solid ${config.color}; border-radius: 12px; padding: 16px; display: flex; align-items: center; gap: 12px;">
            <div style="font-size: 32px;">${config.icon}</div>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 4px;">
                <span style="background: ${config.color}; color: #0a0b0d; border-radius: 6px; padding: 4px 12px; font-size: 12px; font-weight: 700; letter-spacing: 0.5px;">
                  ${config.label}
                </span>
                ${analysis.is_real_power_up ?
                  '<span style="color: var(--accent-secondary); font-weight: 600; font-size: 13px;">✓ Real Power-up</span>' :
                  '<span style="color: #f8b4ae; font-weight: 600; font-size: 13px;">✗ Not a Power-up</span>'}
                ${analysis.category_capped ?
                  `<span style="color: #fdd663; font-size: 13px; font-weight: 600;">⚠️ Score Capped: ${analysis.original_score} → ${analysis.utility_score}</span>` : ''}
              </div>
              <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
                ${analysis.category_reasoning}
              </div>
            </div>
          </div>
        `;

        // Display category explanation
        const categoryExplanations = {
          'TEMPLATE': 'This is a template/documentation skill. Claude can already generate this type of code from training data. Maximum utility for template skills: 3/10',
          'METHODOLOGY': 'This skill provides a reasoning framework that Claude can apply to analyze and solve problems. Real power-up.',
          'KNOWLEDGE': 'This skill provides domain knowledge that Claude can use in reasoning and analysis. Real power-up.',
          'PROCESSOR': 'This skill provides processing/analysis logic that Claude can execute to analyze information. Real power-up.',
          'EXECUTOR': 'This is an automation script that requires external execution. Claude cannot execute this capability. Maximum utility for executor skills: 2/10'
        };

        if (!analysis.is_real_power_up) {
          categoryExplanationSection.classList.remove('hidden');
          categoryExplanationSection.innerHTML = `
            <div style="background: rgba(248, 180, 174, 0.08); border-left: 4px solid #f8b4ae; border-radius: 8px; padding: 16px;">
              <strong style="color: #f8b4ae;">Why Not a Power-up:</strong>
              <p style="margin: 8px 0 0 0; color: var(--text-secondary); line-height: 1.6;">
                ${categoryExplanations[analysis.skill_category]}
              </p>
            </div>
          `;
        } else {
          categoryExplanationSection.classList.add('hidden');
        }
      }

      // Display constraint validation report if there were contradictions
      const validationContainer = document.getElementById('constraintValidationReport');
      if (validationResult && validationResult.hasContradictions) {
        let validationHTML = `
          <div style="background: rgba(248, 180, 174, 0.08); border: 1px solid rgba(248, 180, 174, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #f8b4ae; margin-bottom: 16px;">🛑 CONSTRAINT CONTRADICTIONS DETECTED</h3>

            <div style="margin-bottom: 16px;">
              <div style="display: flex; gap: 20px; margin-bottom: 12px;">
                <div>
                  <strong style="color: var(--text-secondary);">Original Score:</strong>
                  <span style="color: var(--text-primary); font-size: 18px; margin-left: 8px;">${validationResult.originalScore}/10</span>
                </div>
                <div>
                  <strong style="color: var(--text-secondary);">Revised Score:</strong>
                  <span style="color: #f8b4ae; font-size: 18px; margin-left: 8px;">${validationResult.revisedScore}/10</span>
                  <span style="color: #f8b4ae; margin-left: 4px;">⬇️ ${validationResult.scoreChange}</span>
                </div>
              </div>
            </div>

            <div style="margin-bottom: 16px;">
              <strong style="color: var(--text-primary);">Contradicted Claims:</strong>
              <div style="margin-top: 8px;">`;

        validationResult.contradictions.forEach(c => {
          validationHTML += `
                <div style="background: rgba(0, 0, 0, 0.2); border-left: 3px solid #f8b4ae; padding: 12px; margin-bottom: 8px; border-radius: 4px;">
                  <div style="color: var(--text-primary); margin-bottom: 4px;">
                    <span style="color: #f8b4ae;">✗</span> "${c.claim}"
                  </div>
                  <div style="color: var(--text-secondary); font-size: 13px; margin-left: 20px;">
                    Conflicts with: "${c.constraint}"
                  </div>
                </div>`;
        });

        validationHTML += `
              </div>
            </div>`;

        if (validationResult.validClaims && validationResult.validClaims.length > 0) {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <strong style="color: var(--text-primary);">Valid Claims Remaining:</strong>
              <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                ${validationResult.validClaims.join(', ')}
              </div>
            </div>`;
        } else {
          validationHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: #f8b4ae;">
              ⚠️ No valid power-up claims remain after constraint validation
            </div>`;
        }

        validationHTML += `
            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
              <strong>Routing:</strong> ${validationResult.scoreChange <= -3 ? 'Score dropped significantly - REDESIGN RECOMMENDED' : 'Proceeding with revised score'}
            </div>
          </div>
        `;

        if (validationContainer) {
          validationContainer.innerHTML = validationHTML;
          validationContainer.classList.remove('hidden');
        }
      } else if (validationContainer) {
        validationContainer.classList.add('hidden');
      }

      document.getElementById('utilityScoreDisplay').textContent = `${analysis.utility_score}/10`;
      document.getElementById('utilityCategoryDisplay').textContent = analysis.utility_category.replace('_', ' ');
      document.getElementById('powerUpStatement').textContent = analysis.power_up_statement;
      document.getElementById('utilityReasoning').textContent = analysis.reasoning;

      // Hide all routing sections first
      document.getElementById('utilityProceedSection').classList.add('hidden');
      document.getElementById('utilityRedesignSection').classList.add('hidden');
      document.getElementById('utilityRejectSection').classList.add('hidden');

      // Show appropriate section based on routing
      if (analysis.phase_routing === 'PROCEED') {
        document.getElementById('utilityProceedSection').classList.remove('hidden');
        document.getElementById('researchDirection').textContent = analysis.research_direction;
      } else if (analysis.phase_routing === 'REDESIGN' || analysis.phase_routing === 'REJECT') {
        // For MEDIUM and LOW utility, run Problem Identifier Agent
        addLog('Deploying Problem Identifier Agent...', 'info');

        // Show loading state
        const targetSection = analysis.phase_routing === 'REDESIGN' ?
                             'utilityRedesignSection' : 'utilityRejectSection';
        document.getElementById(targetSection).classList.remove('hidden');
        const containerDiv = analysis.phase_routing === 'REDESIGN' ?
                            document.getElementById('redesignOptions') :
                            document.getElementById('rejectAlternatives');
        containerDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Analyzing real problems in this domain...<span class="loading-spinner"></span></p>';

        try {
          // Run problem analysis
          const problemAnalysis = await analyzeProblem(currentRequirements, analysis);
          problemAnalysisResult = problemAnalysis;

          // Display problem-grounded results
          displayProblemAnalysis(problemAnalysis, analysis);
        } catch (err) {
          addLog('Problem analysis encountered an error, showing basic redesigns', 'warning');
          // Fallback to basic redesigns
          displayBasicRedesigns(analysis);
        }
      }

      // Color code the score display
      const scoreDisplay = document.getElementById('utilityScoreDisplay');
      if (analysis.utility_score >= 7) {
        scoreDisplay.style.color = 'var(--accent-secondary)';
      } else if (analysis.utility_score >= 4) {
        scoreDisplay.style.color = '#fdd663';
      } else {
        scoreDisplay.style.color = '#f8b4ae';
      }
    }

    function displayProblemAnalysis(problemAnalysis, utilityAnalysis) {
      const isRedesign = utilityAnalysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      const research = problemAnalysis.domain_research;
      const domainAnalysis = problemAnalysis.domain_analysis || {};

      let html = `
        <div style="background: rgba(138, 180, 248, 0.08); border: 1px solid rgba(138, 180, 248, 0.2); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <h3 style="color: var(--accent-primary); margin: 0;">⚠️ Real Problem Identified</h3>
            ${domainAnalysis.user_specified_domain ? `
              <span style="background: rgba(138, 180, 248, 0.15); border: 1px solid rgba(138, 180, 248, 0.4); border-radius: 6px; padding: 4px 10px; font-size: 11px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase; letter-spacing: 0.5px;">
                ${domainAnalysis.user_specified_domain}
              </span>
            ` : ''}
          </div>
      `;

      // Display pain points
      if (research.practitioner_pain_points && research.practitioner_pain_points.length > 0) {
        const painPoint = research.practitioner_pain_points[0];
        html += `
          <div style="margin-bottom: 16px;">
            <strong style="color: var(--text-primary);">Problem:</strong>
            <p style="margin: 8px 0; line-height: 1.6;">${painPoint.problem}</p>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; font-size: 13px;">
            <div>
              <strong style="color: var(--text-secondary);">Current Workaround:</strong>
              <p style="margin: 4px 0;">${painPoint.current_workaround}</p>
            </div>
            <div>
              <strong style="color: var(--text-secondary);">Cost:</strong>
              <p style="margin: 4px 0;">${painPoint.cost_of_problem}</p>
            </div>
          </div>
        `;
      }

      html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <strong style="color: var(--text-primary);">Claude Capability Gap:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--text-secondary);">${research.claude_capability_gap}</p>
          </div>
          <div style="margin-top: 12px;">
            <strong style="color: var(--text-primary);">Value Unlock:</strong>
            <p style="margin: 8px 0; line-height: 1.6; color: var(--accent-secondary);">${research.value_unlock}</p>
          </div>
        </div>
      `;

      // Display redesign suggestions
      html += '<h3 style="margin: 24px 0 16px 0;">Problem-Grounded Redesigns</h3>';

      if (problemAnalysis.redesign_suggestions && problemAnalysis.redesign_suggestions.length > 0) {
        problemAnalysis.redesign_suggestions.forEach((suggestion, index) => {
          const scoreColor = suggestion.estimated_utility_score >= 8 ? 'var(--accent-secondary)' : '#fdd663';
          const domainRelevanceScore = suggestion.domain_relevance_score || 'N/A';
          const domainRelevanceColor = domainRelevanceScore >= 8 ? 'var(--accent-secondary)' : domainRelevanceScore >= 7 ? '#fdd663' : '#f8b4ae';

          html += `
            <div style="background: rgba(30, 33, 39, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 16px; cursor: pointer; transition: all 0.3s ease;"
                 onmouseover="this.style.borderColor='var(--accent-primary)'; this.style.background='rgba(138, 180, 248, 0.08)';"
                 onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.background='rgba(30, 33, 39, 0.6)';"
                 onclick='selectRedesign("${suggestion.redesigned_skill.replace(/"/g, '&quot;')}")'>
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px; gap: 8px;">
                <div style="flex: 1;">
                  <h4 style="color: var(--accent-primary); margin: 0 0 8px 0; font-size: 16px;">${suggestion.redesigned_skill}</h4>
                  ${domainAnalysis.user_specified_domain ? `
                    <div style="display: inline-flex; align-items: center; gap: 6px;">
                      <span style="background: rgba(138, 180, 248, 0.12); border: 1px solid rgba(138, 180, 248, 0.3); border-radius: 4px; padding: 2px 8px; font-size: 10px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase;">
                        ${domainAnalysis.user_specified_domain}
                      </span>
                      <span style="color: ${domainRelevanceColor}; font-size: 10px; font-weight: 600;">
                        Domain Fit: ${domainRelevanceScore}/10
                      </span>
                    </div>
                  ` : ''}
                </div>
                <div style="background: ${scoreColor}20; border: 1px solid ${scoreColor}; border-radius: 8px; padding: 4px 12px; font-size: 12px; font-weight: 600; color: ${scoreColor}; white-space: nowrap;">
                  ${suggestion.estimated_utility_score}/10 ⬆️
                </div>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Solves:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.problem_it_solves}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Power-up:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6; color: var(--accent-primary);">${suggestion.claude_power_up}</p>
              </div>
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Outcome:</strong>
                <p style="margin: 4px 0; font-size: 14px; line-height: 1.6;">${suggestion.measurable_outcome}</p>
              </div>
              ${suggestion.domain_fit_explanation ? `
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text-secondary); font-size: 13px;">Domain Fit:</strong>
                <p style="margin: 4px 0; font-size: 13px; line-height: 1.5; color: var(--accent-primary);">${suggestion.domain_fit_explanation}</p>
              </div>
              ` : ''}
              <div style="background: rgba(10, 11, 13, 0.4); border-radius: 8px; padding: 12px; margin-top: 12px;">
                <strong style="color: var(--text-secondary); font-size: 12px;">Implementation:</strong>
                <p style="margin: 4px 0; font-size: 13px; font-family: 'SF Mono', monospace; line-height: 1.5;">${suggestion.specific_implementation}</p>
              </div>
            </div>
          `;
        });
      }

      containerDiv.innerHTML = html;
    }

    function displayBasicRedesigns(analysis) {
      const isRedesign = analysis.phase_routing === 'REDESIGN';
      const containerDiv = isRedesign ?
                          document.getElementById('redesignOptions') :
                          document.getElementById('rejectAlternatives');

      containerDiv.innerHTML = '';

      if (analysis.recommended_redesigns && analysis.recommended_redesigns.length > 0) {
        analysis.recommended_redesigns.forEach((redesign, index) => {
          const btn = document.createElement('button');
          btn.className = 'example-btn';
          btn.textContent = `→ ${redesign}`;
          btn.style.marginBottom = '12px';
          btn.onclick = () => selectRedesign(redesign);
          containerDiv.appendChild(btn);
        });
      }
    }

    function selectRedesign(redesign) {
      document.getElementById('skillInput').value = redesign;
      resetFactory();
    }

    async function continueToResearch() {
      if (!currentRequirements || !utilityAnalysisResult) {
        addLog('Missing requirements or utility analysis', 'error');
        return;
      }

      if (isGenerating) {
        addLog('Generation already in progress', 'warning');
        return;
      }

      try {
        isGenerating = true;
        document.getElementById('utilityCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');

        setStep(3); // Research phase (now step 3 instead of 2)
        const research = await conductResearch(currentRequirements);

        setStep(4); // Generate phase (now step 4 instead of 3)
        const metadata = await generateMetadata(currentRequirements, research);
        const documentation = await generateDocumentation(currentRequirements, research, metadata);

        const skillPackage = { metadata, documentation, requirements: currentRequirements };

        setStep(5); // Validate phase (now step 5 instead of 4)
        const validation = await validateGeneration(skillPackage);

        if (validation.issues.length > 0) {
          throw new Error(`Validation failed: ${validation.issues.join(', ')}`);
        }

        setStep(6); // Package phase (now step 6 instead of 5)
        const pkg = await packageSkill(skillPackage, currentRequirements.skill_name);

        generatedSkillData = {
          package: pkg.content,
          filename: pkg.filename,
          tree: pkg.tree,
          validation
        };

        showResults(validation, pkg.tree, pkg.filename);
        addLog('🎉 Skill generation complete!', 'success');

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
      }
    }

    function proceedAnyway() {
      addLog('Proceeding with MEDIUM_UTILITY skill...', 'warning');
      continueToResearch();
    }

    async function conductResearch(requirements) {
      addLog('Starting research pipeline...', 'info');
      updateProgress('Research', 20, 'Researching documentation...');

      const prompt = `Research for creating a Claude Code Skill:

REQUIREMENTS: ${JSON.stringify(requirements, null, 2)}

Provide a focused research summary (max 1000 tokens):
1. Key technical details and APIs
2. Best practices and patterns
3. Common challenges and solutions
4. Recommended implementation approach

Be specific and actionable.`;

      try {
        const findings = await callClaude(prompt, 1500);
        addLog('Research complete', 'success');
        updateProgress('Research', 100, 'Research synthesis complete');
        return findings;
      } catch (err) {
        addLog('Research failed - using template generation', 'warning');
        return 'Limited research available - generating from templates';
      }
    }

    function sanitizeForYAML(text) {
      // Escape backslashes and double quotes for safe YAML inclusion
      return text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function generateSafeYAML(name, description, metadata = null) {
      const lines = [];

      // Name (validated, safe without quotes if lowercase-hyphenated)
      lines.push(`name: ${name}`);

      // Description (ALWAYS quote to handle special characters)
      const safeDesc = sanitizeForYAML(description);
      lines.push(`description: "${safeDesc}"`);

      // Metadata (if provided)
      if (metadata && Object.keys(metadata).length > 0) {
        lines.push('metadata:');
        for (const [key, value] of Object.entries(metadata)) {
          // Always quote values to prevent type coercion
          const safeValue = sanitizeForYAML(String(value));
          lines.push(`  ${key}: "${safeValue}"`);
        }
      }

      return lines.join('\n');
    }

    async function generateMetadata(requirements, research) {
      addLog('Generating skill metadata...', 'info');
      updateProgress('Generate', 20, 'Creating YAML metadata...');

      const prompt = `You are generating YAML frontmatter for a Claude Code Skill.

REQUIREMENTS: ${JSON.stringify(requirements)}
RESEARCH: ${research.substring(0, 500)}

CRITICAL YAML RULES:
1. ONLY these keys allowed at root: name, description, license, allowed-tools, metadata
2. Put version, author, tags INSIDE metadata (not at root)
3. Description must include BOTH what it does AND when to use it
4. Return ONLY valid JSON with these exact fields (no YAML, no markdown):

REALITY CONSTRAINTS - NEVER promise these capabilities:
- Real-time data access (prices, inventory, weather) without API key requirement
- Authenticated API calls on user's behalf
- Direct database operations
- Live integrations with external services
- Async/background processing or task queues

WHAT CLAUDE CAN DO:
- Create frameworks, templates, and decision trees
- Generate code examples and architectural patterns
- Analyze and synthesize information
- Provide recommendations based on training data
- Structure workflows and processes

{
  "name": "lowercase-hyphenated-name",
  "description": "What Claude actually does (not aspirational). When to use it (realistic triggers). Mention constraints if external tools needed.",
  "metadata": {
    "version": "1.0.0",
    "complexity": "simple",
    "author": "Skill Factory",
    "constraints": "List any limitations like 'Cannot access real-time data' or 'Requires user to provide API key'"
  }
}

Return ONLY the JSON object, no other text.`;

      try {
        let response = await callClaude(prompt, 1000);
        response = response.replace(/```json\s?/g, '').replace(/```\s?/g, '').trim();
        const parsed = JSON.parse(response);

        // Validate name format
        if (!/^[a-z0-9-]+$/.test(parsed.name)) {
          throw new Error('Invalid name format - must be lowercase with hyphens only');
        }
        if (parsed.name.length > 64) {
          throw new Error('Name exceeds 64 character limit');
        }
        if (parsed.description.length > 1024) {
          throw new Error('Description exceeds 1024 character limit');
        }

        // Generate safe YAML using our sanitization function
        const yaml = generateSafeYAML(parsed.name, parsed.description, parsed.metadata);

        addLog('Metadata generated and validated', 'success');
        return yaml;
      } catch (err) {
        addLog(`Metadata generation failed: ${err.message}`, 'error');
        throw new Error(`Metadata generation failed: ${err.message}`);
      }
    }

    async function generateDocumentation(requirements, research, metadata) {
      addLog('Generating documentation...', 'info');
      updateProgress('Generate', 50, 'Writing SKILL.md...');

      const prompt = `Write skill documentation (WITHOUT YAML frontmatter).

REQUIREMENTS: ${JSON.stringify(requirements)}
METADATA: ${metadata}
RESEARCH: ${research}

CRITICAL - REALITY-BASED DOCUMENTATION:
- Focus on what Claude can ACTUALLY do (frameworks, analysis, code examples)
- If external tools/APIs needed, explicitly state where user must defer
- Never promise real-time data, live integrations, or authenticated API calls
- Include a "Limitations" section if the skill has constraints
- Be honest about what requires user action vs Claude's capabilities

Structure:
# Overview
Brief description of what this skill actually does (not aspirational)

# When to Use
Realistic trigger conditions and keywords

# Key Features
- Feature 1 (what Claude provides)
- Feature 2 (realistic capabilities)

# Limitations (if any)
- What this skill cannot do
- When to use external tools instead
- Required user actions for complete workflows

# Usage Examples
Concrete examples with code showing realistic scenarios

# Implementation Details
Technical approach within Claude's capabilities

# Best Practices
Recommendations and tips for using this skill effectively

Keep under 500 lines. Be specific, practical, and honest about constraints.`;

      try {
        const docs = await callClaude(prompt, 4000);
        addLog('Documentation generated', 'success');
        updateProgress('Generate', 100, 'Generation complete');
        return docs;
      } catch (err) {
        throw new Error(`Documentation generation failed: ${err.message}`);
      }
    }

    async function validateGeneration(skillPackage) {
      addLog('Running validation...', 'info');
      updateProgress('Validate', 30, 'Validating metadata...');

      const validation = {
        yamlValid: false,
        qualityScore: 0,
        issues: [],
        warnings: []
      };

      const hasName = skillPackage.metadata.includes('name:');
      const hasDesc = skillPackage.metadata.includes('description:');

      if (hasName && hasDesc) {
        validation.yamlValid = true;
        addLog('YAML validation passed', 'success');
      } else {
        validation.issues.push('Missing required YAML fields');
        addLog('YAML validation failed', 'error');
      }

      // Constraint validation - check for overselling
      updateProgress('Validate', 60, 'Checking constraint compliance...');
      const fullContent = skillPackage.metadata + '\n' + skillPackage.documentation;
      const redFlags = [
        { pattern: /real-?time (data|price|inventory|api|integration)/i, issue: 'Promises real-time data without mentioning constraints' },
        { pattern: /integrates? with|connects? to|fetches? from/i, issue: 'Suggests direct external integrations' },
        { pattern: /database|sql|query|mongodb|postgres/i, issue: 'Implies database access' },
        { pattern: /async|background (process|task|job)|queue/i, issue: 'Suggests async/background processing' },
        { pattern: /authenticate|login|oauth|token refresh/i, issue: 'Implies authentication handling for user' }
      ];

      for (const flag of redFlags) {
        if (flag.pattern.test(fullContent)) {
          // Check if constraints are mentioned nearby
          const constraintMentioned = /constraint|limitation|cannot|requires user|defer|hand off/i.test(fullContent);
          if (!constraintMentioned) {
            validation.warnings.push(flag.issue);
            addLog(`Warning: ${flag.issue}`, 'warning');
          }
        }
      }

      // Quality scoring
      let score = 0;
      if (validation.yamlValid) score += 30;
      if (skillPackage.documentation.length > 500) score += 20;
      if (validation.issues.length === 0) score += 20;
      if (validation.warnings.length === 0) score += 20; // Bonus for no overselling
      if (skillPackage.metadata.includes('constraints:')) score += 10; // Bonus for explicit constraints

      validation.qualityScore = score;

      if (validation.warnings.length > 0) {
        addLog(`Found ${validation.warnings.length} potential overselling warnings`, 'warning');
      }

      addLog(`Quality score: ${score}/100`, score >= 70 ? 'success' : 'warning');
      updateProgress('Validate', 100, 'Validation complete');

      return validation;
    }

    async function packageSkill(skillPackage, skillName) {
      addLog('Creating skill package...', 'info');
      updateProgress('Package', 30, 'Initializing ZIP...');

      const zip = new JSZip();
      const sanitized = sanitizeFileName(skillName);
      const skillFolder = zip.folder(sanitized);

      const skillMd = `---\n${skillPackage.metadata}\n---\n\n${skillPackage.documentation}`;
      skillFolder.file('SKILL.md', skillMd);
      addLog('Added SKILL.md', 'success');

      updateProgress('Package', 60, 'Adding README...');

      const readme = `# ${skillName}

This is a Claude Code Skill package.

## Installation

1. Extract this ZIP file
2. Place the \`${sanitized}\` folder in your Claude Code skills directory:
   - Personal skills: ~/.claude/skills/
   - Project skills: .claude/skills/
3. The skill will be automatically available

## Contents

- \`SKILL.md\` - Main skill documentation

## Usage

This skill will be automatically loaded by Claude Code when relevant.
`;
      skillFolder.file('README.md', readme);
      addLog('Added README.md', 'success');

      updateProgress('Package', 80, 'Compressing...');

      const content = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });

      updateProgress('Package', 100, 'Package ready!');
      addLog('Package created successfully', 'success');

      const tree = {
        name: sanitized,
        type: 'folder',
        children: [
          { name: 'SKILL.md', type: 'file', size: skillMd.length },
          { name: 'README.md', type: 'file', size: readme.length }
        ]
      };

      return { content, filename: `${sanitized}.zip`, tree };
    }

    async function startGeneration() {
      const input = document.getElementById('skillInput').value.trim();
      if (!input || isGenerating) return;

      try {
        isGenerating = true;
        document.getElementById('generateBtn').disabled = true;
        document.getElementById('generateBtn').innerHTML = '⏳ Generating... <span class="loading-spinner"></span>';
        document.getElementById('inputCard').classList.add('hidden');
        document.getElementById('progressCard').classList.remove('hidden');
        document.getElementById('logContainer').innerHTML = '';

        // Phase 1: Extract Requirements
        setStep(1);
        const requirements = await extractRequirements(input);
        currentRequirements = requirements;

        // Phase 0: Utility Analysis (runs after extraction)
        setStep(2);
        const utilityAnalysis = await analyzeUtility(requirements);

        // NEW: Skill Categorization Gate
        // Determines if skill is a real power-up and sets max utility ceiling
        const categorization = await categorizeSkill(input, requirements);
        const categoryMaxUtility = categorization.max_utility_score;
        const originalScore = utilityAnalysis.utility_score;

        // Apply category ceiling to utility score
        if (originalScore > categoryMaxUtility) {
          addLog(`⚠️ Applying category ceiling: ${originalScore}/10 → ${categoryMaxUtility}/10 (${categorization.category} max)`, 'warning');
          utilityAnalysis.utility_score = categoryMaxUtility;
          utilityAnalysis.utility_category = categorizeUtilityScore(categoryMaxUtility);
          utilityAnalysis.category_capped = true;
          utilityAnalysis.original_score = originalScore;
        }

        // Add categorization info to analysis
        utilityAnalysis.skill_category = categorization.category;
        utilityAnalysis.category_reasoning = categorization.category_reasoning;
        utilityAnalysis.is_real_power_up = categorization.is_real_power_up;
        utilityAnalysis.category_max_utility = categoryMaxUtility;
        utilityAnalysis.indicators_found = categorization.indicators_found;

        // Update phase_routing based on final score and category
        const finalScore = utilityAnalysis.utility_score;
        if (finalScore >= 7) {
          utilityAnalysis.phase_routing = 'PROCEED';
        } else if (finalScore >= 4) {
          // MEDIUM_UTILITY: REDESIGN for TEMPLATE/EXECUTOR, PROCEED for real power-ups
          if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REDESIGN';
          } else {
            utilityAnalysis.phase_routing = 'PROCEED';
          }
        } else {
          // LOW_UTILITY: REJECT for TEMPLATE/EXECUTOR, REDESIGN for others
          if (categorization.category === 'TEMPLATE' || categorization.category === 'EXECUTOR') {
            utilityAnalysis.phase_routing = 'REJECT';
          } else {
            utilityAnalysis.phase_routing = 'REDESIGN';
          }
        }

        // NEW: Constraint Validation Gate
        // Validates that power-up claims don't contradict skill's own constraints
        addLog('Running constraint validation...', 'info');
        const validationResult = validateConstraints(requirements, utilityAnalysis);

        let finalAnalysis = utilityAnalysis;
        if (validationResult.hasContradictions) {
          // Log found constraints
          addLog(`✓ Found ${validationResult.constraints.length} constraint(s):`, 'info');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });

          // Log contradictions
          addLog(`⚠️ Constraint contradictions detected: ${validationResult.contradictions.length} claim(s) invalidated`, 'warning');
          validationResult.contradictions.forEach(contradiction => {
            addLog(`  ✗ Claim: "${contradiction.claim}"`, 'warning');
            addLog(`    Conflicts: "${contradiction.constraint.substring(0, 60)}${contradiction.constraint.length > 60 ? '...' : ''}"`, 'warning');
          });

          addLog(`Score recalculated: ${validationResult.originalScore}/10 → ${validationResult.revisedScore}/10 (${validationResult.scoreChange})`, 'warning');
          finalAnalysis = validationResult.revisedAnalysis;
        } else if (validationResult.hasConstraints) {
          addLog(`✓ Found ${validationResult.constraints.length} constraint(s) - all claims validated`, 'success');
          validationResult.constraints.forEach(c => {
            addLog(`  - "${c.substring(0, 80)}${c.length > 80 ? '...' : ''}"`, 'info');
          });
          addLog(`✓ Constraint validation passed: ${validationResult.claimsChecked || 0} claim(s) verified`, 'success');
        } else {
          addLog('✓ No constraints found - analysis valid', 'success');
        }

        utilityAnalysisResult = finalAnalysis;

        // Hide progress card and show utility results
        document.getElementById('progressCard').classList.add('hidden');
        await showUtilityResults(finalAnalysis, validationResult);

        // For HIGH_UTILITY, we could auto-proceed or wait for user
        // Currently waiting for user to click "Continue to Research"
        // REDESIGN and REJECT paths stop here and wait for user action

      } catch (err) {
        showError(err.message);
        addLog(`Generation failed: ${err.message}`, 'error');
      } finally {
        isGenerating = false;
        document.getElementById('generateBtn').disabled = false;
        document.getElementById('generateBtn').textContent = 'Generate This Skill →';
      }
    }

    function downloadSkill() {
      if (!generatedSkillData) return;

      const url = URL.createObjectURL(generatedSkillData.package);
      const a = document.createElement('a');
      a.href = url;
      a.download = generatedSkillData.filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`Downloaded ${generatedSkillData.filename}`, 'success');
    }

    async function copyPromptToClipboard() {
      if (!generatedSkillData || !generatedSkillData.package) {
        addLog('No skill available to copy', 'error');
        return;
      }

      try {
        // Extract SKILL.md content from the ZIP
        const zip = await JSZip.loadAsync(generatedSkillData.package);
        const skillMdFile = Object.keys(zip.files).find(f => f.endsWith('SKILL.md'));

        if (!skillMdFile) {
          throw new Error('SKILL.md not found in package');
        }

        const skillContent = await zip.files[skillMdFile].async('text');

        // Format as a prompt
        const prompt = `You are now equipped with the following skill:

---
${skillContent}
---

When the user asks questions or requests tasks related to the topics covered in this skill, use the knowledge and guidelines from this skill to assist them.`;

        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          try {
            await navigator.clipboard.writeText(prompt);
            showCopySuccess();
            addLog('Skill prompt copied to clipboard!', 'success');
          } catch (clipboardError) {
            // Clipboard API exists but rejected (Safari, insecure origin, permission denied)
            // Fall back to legacy method
            console.warn('Clipboard API rejected, using fallback:', clipboardError);
            showCopyFallback(prompt);
          }
        } else {
          // Fallback for browsers without clipboard API
          showCopyFallback(prompt);
        }

      } catch (error) {
        addLog(`Failed to copy: ${error.message}`, 'error');
        console.error('Copy error:', error);
      }
    }

    function showCopySuccess() {
      const button = document.getElementById('copyPromptBtn');
      const originalText = button.innerHTML;
      button.innerHTML = '✓ Copied!';
      button.disabled = true;

      setTimeout(() => {
        button.innerHTML = originalText;
        button.disabled = false;
      }, 2000);
    }

    function showCopyFallback(text) {
      // Create a temporary textarea for fallback copying
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.top = '0';
      textarea.style.left = '0';
      textarea.style.width = '2em';
      textarea.style.height = '2em';
      textarea.style.padding = '0';
      textarea.style.border = 'none';
      textarea.style.outline = 'none';
      textarea.style.boxShadow = 'none';
      textarea.style.background = 'transparent';

      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showCopySuccess();
          addLog('Skill prompt copied to clipboard!', 'success');
        } else {
          throw new Error('Copy command failed');
        }
      } catch (err) {
        addLog('Please copy the text manually (Ctrl/Cmd+C)', 'warning');
        alert('Automatic copy failed. Please press Ctrl/Cmd+C to copy the selected text.');
      } finally {
        document.body.removeChild(textarea);
      }
    }

    function resetFactory() {
      location.reload();
    }

    init();
  </script>
</body>
</html>
